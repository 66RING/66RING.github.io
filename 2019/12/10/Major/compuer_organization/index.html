<!DOCTYPE html>
<html lang="en">
  <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.0'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <link rel="preload" href="/css/first.css" as="style">
  

  <!-- 页面元数据 -->
  
  <title>Computer Organization - 66Ring&#39;s Blog</title>
  
    <meta name="keywords" content="计算机组成">
  

  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        '<h1><b>抱歉，您的浏览器无法访问本站</b></h1>'+
        '<h3>微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>'+
        '继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</h3><br/>'+
        '<a href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support" target="_blank" rel="noopener"><strong>了解详情 ></strong></a>'+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
	</style>
    <div class="kill-noscript">
        <h1><b>抱歉，您的浏览器无法访问本站</b></h1>
        <h3>本页面需要浏览器支持（启用）JavaScript</h3><br/>
        <a href="https://www.baidu.com/s?wd=启用JavaScript" target="_blank" rel="noopener"><strong>了解详情 ></strong></a>
    </div>
</noscript>

</head>

  <body>
    

<header id="l_header" class="l_header auto shadow blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://raw.githubusercontent.com/66RING/66RING/master/.github/images/the_dark_side_of_the_moon_tranp.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fas fa-moon fa-fw'></i>Dark Mode
                </a>
              <li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fas fa-moon fa-fw'></i>Dark Mode
                </a>
              <li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post dock' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Mens et Manus</p>
    
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f5c3.svg'><p>首页</p>
            </a>
          
            <a href="/faqs/"
              
              
              id="faqs">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              id="examples">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f396.svg'><p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              id="contributors">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f389.svg'><p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f4f0.svg'><p>档归</p>
            </a>
          
            <a href="https://github.com/66RING"
              
              
              id="https:githubcom66RING">
              <img src='https://cdn.jsdelivr.net/gh/twitter/twemoji@13.0/assets/svg/1f9ec.svg'><p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

      <div id="safearea">
        <div class="body-wrapper" id="pjax-container">
          

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        Computer Organization
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="">
    <p>请设置文章作者</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Dec 10, 2019</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="Computer Organization" data-path="/2019/12/10/Major/compuer_organization/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  
  <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>从纯文本的程序到可执行的编码，以<code>hello.c</code>为例<ul>
<li>预处理：把头文件的内容直接插入程序文本。结果得到另一个c程序，通常以.i结尾</li>
<li>编译：编译器将本文文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序</li>
<li>汇编：汇编器将hello.s翻译成机器指令(编码)，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中(一个二进制文件)。</li>
<li>链接：hello程序可能会用到许多函数，如printf。printf函数存在与一个名为printf.o的单独编译的与编译好了的目标文件中，这个文件需要以某种形式合并到我们的hello.o程序中。链接器就负责处理这种合并</li>
</ul>
</li>
</ul>
<ul>
<li>虚拟内存：虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都在单独的使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间</li>
<li>虚拟地址空间的结构：<ul>
<li>程序代码和数据</li>
<li>堆：代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的函数时，堆可以在运行时动态伸缩</li>
<li>共享库：大约在地址空间的中间部分是一块用来存放像C标准这样的共享库的代码和数据的区域</li>
<li>栈</li>
<li>内核虚拟内存：地址空间的顶部区域是为内核保留的。不允许任何程序的读写</li>
</ul>
</li>
</ul>
<h2 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h2><h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><h4 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h4><p>考虑两个非负整数x和y，满足$0 \leq x, y&lt;2^w$。每个数都能表示为w为无符号数字。如果计算他们的和，我们就有一个可能的范围$0 \leq x+y \leq 2^{w+1} - 2$，表示这个和可能需要w+1位。对于固定精度的编程语言会发生溢出。</p>
<p>我们为x和y定义运算$+^u_w, 其中0 \leq x, y &lt; 2^w$，该操作是把整数和x+y截断为w位得到的结果。这也可以被视为一种形式的模运算，对于x+y的位级表示，简单的丢弃任何权重大于$2^{w-1}$的位就可以计算出和模$2^w$。如考虑一个4位数字表示$x=12, y=9,x+y=21([10101])$如果丢掉最高位，我们的到[0101]，也就是十进制的5。也就和值21 mod 16 = 6一致。</p>
<blockquote>
<p>定义$+^u_w$:</p>
<p>对于满足$0 \leq x, y &lt; 2^w$的x和y有</p>
<p>$$<br>x+^u_w y =<br>\begin{cases}<br>x+y&amp; ,{x+y&lt;2^w}&amp; 正常\<br>x+y-2^w&amp; ,{2^w \leq x+y &lt; 2^{w+1}}&amp; 溢出<br>\end{cases}<br>$$</p>
</blockquote>
<p>如何判断是否发生了溢出：</p>
<ul>
<li>原理：对在范围$0 \leq x, y \leq UMax_w$中的x和y，令$s = x +^u_w y$。则对计算是，当且仅当s&lt;x(或等价地s&lt;y)时发生溢出</li>
<li>推导：显然$x+y \geq x$，因此如果s没有溢出$s \geq x$。如果s发生溢出，有$s = x+y-2^w$，假设$y &lt; 2^w$，有$y-2^w &lt; 0$，因此$s = x+(y-2^w) &lt; x$</li>
</ul>
<h4 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h4><p>整数乘法指令相当慢，需要多个时钟周期，然而其他的整数运算(如加法、减法、位移)之需要1个时钟周期。因此编译器使用了一项重要的优化：试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
<p>如$x \times 14$，$14=2^3+2^2+2^1$，编译器将乘法重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)，将一个乘法代替为3个移位和2个加法。甚至还可以$14=2^4-2^1$。</p>
<p>到这里，无符号数和补码的结果还是相同的</p>
<h4 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h4><p>在大多数机器上，整数除法要比整数乘法更慢：需要30个或者更多的时钟周期。除以2的幂也可以通过用移位(左移)运算来实现。</p>
<p>无符号和补码数分别使用逻辑移位和算数移位来达到目的：</p>
<ul>
<li>逻辑移位<ul>
<li>移出的空位用0补上</li>
</ul>
</li>
<li>算术移位<ul>
<li>对于无符号型，算术移位等同于逻辑移位</li>
<li>对于有符号型，算数左移等同于逻辑左移，算数右移补的是符号位</li>
</ul>
</li>
</ul>
<blockquote>
<p>定义$\lfloor a \rfloor$为向下舍入，$\lceil a \rceil$为向上舍入。</p>
</blockquote>
<p>对于$x \geq 0$和$y&gt;0$，结果会是$\lfloor x/y \rfloor$，对于$x&lt;0$和$y&gt;0$，结果会是$\lceil x/y \rceil$。也就是说要向下舍入一个正值，而向上舍入一个负值。</p>
<ul>
<li>除以2的幂的无符号数除法<ul>
<li>很简单，就直接右移，产生$\lfloor x/2^k \rfloor$</li>
</ul>
</li>
<li>除以2的幂的补码，正值情况，向下舍入<ul>
<li>也是直接右移，直接右移的结果是向下舍入的</li>
</ul>
</li>
<li>除以2的幂的补码，负值情况，向上舍入<ul>
<li>不能直接右移，因为直接右移导致结果向下舍入，而我们需要向上舍入</li>
<li>执行算数右移前要加上一个适当的偏执量才能使得结果正确舍入</li>
<li>表达式：(x+(1&lt;&lt;k)-1)&gt;&gt;k产生数值$\lceil x/2^k \rceil$</li>
<li>偏置技术利用如下属性：对于整数x和y(y&gt;0)，$\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$。这样就可以通过逻辑移位来的到向上取整的结果了</li>
<li><strong>推导:</strong> $\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$，设$x = qy+r$，其中$0 \leq r &lt; y$，得到(x+y-1)/y=q+(r+y-1)，因此$\lfloor (x+y-1)/y \rfloor = q + \lfloor (r+y-1)/y \rfloor$。当r=0时，后面一项等于0，当r&gt;0时，等于1。级通过给x增加一个偏移量y-1,然后再将除法向下舍入，当y整除x时，我们得到q，否则，得到q+1。</li>
</ul>
</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="IEEE浮点数表示"><a href="#IEEE浮点数表示" class="headerlink" title="IEEE浮点数表示"></a>IEEE浮点数表示</h4><p>定点表示法不能很有效地表示非常大的数字。我们希望通过给定x和y的值，来表示形如$x \times 2^y$的数。</p>
<blockquote>
<p>IEEE浮点数标准用$V = (-1)^s \times M \times 2^E$的形式来表示一个数：</p>
<ul>
<li>符号(sign)<ul>
<li>s决定是负数(s=1)还是正数</li>
</ul>
</li>
<li>尾数(significand) M<ul>
<li>M是一个二进制小数，它的取值范围是<code>[1, 2)</code>或<code>[0, 1)</code></li>
<li>有n位小数字段$frac=f_{n-1}…f_0$编码尾数M，但编码出来的值也依赖于阶码字段是否等于0(规格化的和非规格化的)</li>
</ul>
</li>
<li>阶码(exponent) E<ul>
<li>E的作用是对浮点数加权，这个权重是2的E次幂</li>
<li>由k位的阶码字段组成$exp=e_{k-1}…f_0$来编码阶码E</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>以下是两种常见的格式：单精度和双精度<ul>
<li>单精度:s、exp、frac字段分别为1位、k=8位和n=23位，得到一个32位的表示</li>
<li>双精度:s、exp、frac字段分别为1位、k=11位和n=52位，得到一个64位的表示</li>
</ul>
</li>
<li>给定位的表示，根据exp的值，被编码的值可以分成三种不同的情况(最后一种情况有两种变种)<ul>
<li>规格化的<ul>
<li>exp字段既不全为0也不全为1</li>
<li>阶码的值E=e-Bias，e是无符号数，而$Bias=2^{k-1}-1$的偏置值</li>
<li>尾数M=1+f，f是frac字段描述的小数值$0 \leq f &lt; 1$</li>
</ul>
</li>
<li>非规格化的值<ul>
<li>exp字段全为0时</li>
<li>阶码E=1-Bias</li>
<li>尾数M=f</li>
<li>注意和规格化的区别</li>
</ul>
</li>
<li>特殊值<ul>
<li>当exp全为1，frac字段全为0时，得到的值表示无穷</li>
<li>当exp全为1，frac字段不全为0时，得到的值表示NaN(Not a Number)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例：假定用6位格式表示，k=3的阶码位和n=2的尾数位，如下</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>位表示</th>
<th>e</th>
<th>E</th>
<th>$2^E$</th>
<th>f</th>
<th>M</th>
<th>$2^E \times M$</th>
<th>V</th>
<th>十进制</th>
<th>公式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0 0000 000</td>
<td>0</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac08$</td>
<td>$\frac08$</td>
<td>$\frac0{512}$</td>
<td>0</td>
<td>0.0</td>
<td>E=1-Bias</td>
</tr>
<tr>
<td>最小非规格化数</td>
<td>0 0000 001</td>
<td>0</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac18$</td>
<td>$\frac18$</td>
<td>$\frac1{512}$</td>
<td>$\frac1{512}$</td>
<td>0.001953</td>
<td>M=f</td>
</tr>
<tr>
<td></td>
<td>0 0000 010</td>
<td>0</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac28$</td>
<td>$\frac38$</td>
<td>$\frac2{512}$</td>
<td>$\frac1{256}$</td>
<td>0.003906</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>..</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>最大非规格化数</td>
<td>0 0000 111</td>
<td>0</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac78$</td>
<td>$\frac78$</td>
<td>$\frac7{512}$</td>
<td>$\frac7{512}$</td>
<td>0.013672</td>
<td></td>
</tr>
<tr>
<td>——–</td>
<td>——</td>
<td>–</td>
<td>–</td>
<td>—</td>
<td>—-</td>
<td>—-</td>
<td>——</td>
<td>—–</td>
<td>—–</td>
<td></td>
</tr>
<tr>
<td>最小规格化数</td>
<td>0 0001 000</td>
<td>1</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac08$</td>
<td>$\frac88$</td>
<td>$\frac8{512}$</td>
<td>$\frac1{64}$</td>
<td>0.015625</td>
<td>E=e-Bias</td>
</tr>
<tr>
<td></td>
<td>0 0001 001</td>
<td>1</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac18$</td>
<td>$\frac98$</td>
<td>$\frac9{512}$</td>
<td>$\frac9{256}$</td>
<td>0.017578</td>
<td>M=1+f</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>..</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>0 1110 110</td>
<td>14</td>
<td>7</td>
<td>128</td>
<td>$\frac68$</td>
<td>$\frac{14}8$</td>
<td>$\frac{1792}8$</td>
<td>224</td>
<td>224</td>
<td></td>
</tr>
<tr>
<td>最大规格化数</td>
<td>0 1110 111</td>
<td>14</td>
<td>7</td>
<td>128</td>
<td>$\frac78$</td>
<td>$\frac{15}8$</td>
<td>$\frac{1920}8$</td>
<td>240</td>
<td>240</td>
<td></td>
</tr>
<tr>
<td>——–</td>
<td>——</td>
<td>–</td>
<td>–</td>
<td>—</td>
<td>—-</td>
<td>—-</td>
<td>——</td>
<td>—–</td>
<td>—–</td>
<td></td>
</tr>
<tr>
<td>无穷大</td>
<td>0 1111 000</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>无穷</td>
<td>-</td>
<td></td>
</tr>
</tbody></table>
<h2 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h2><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><table>
<thead>
<tr>
<th>C声明</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小(字节)</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>一个x86-64的CPU包含一组16个储存64位值的通用目的寄存器。每个寄存器都有特殊的用途，它们的名字就反映了这些用途。</p>
<table>
<thead>
<tr>
<th>64寄存器</th>
<th>32位寄存器</th>
<th>16位寄存器</th>
<th>8位寄存器</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>%rax</td>
<td>%eax</td>
<td>%ax</td>
<td>%ax</td>
<td>返回值</td>
</tr>
<tr>
<td>%rbx</td>
<td>%ebx</td>
<td>%bx</td>
<td>%bl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td>%ecx</td>
<td>%cx</td>
<td>%cl</td>
<td>第4个参数</td>
</tr>
<tr>
<td>%rdx</td>
<td>%edx</td>
<td>%dx</td>
<td>%dl</td>
<td>第3个参数</td>
</tr>
<tr>
<td>%rsi</td>
<td>%esi</td>
<td>%si</td>
<td>%sil</td>
<td>第2个参数</td>
</tr>
<tr>
<td>%rdi</td>
<td>%edi</td>
<td>%di</td>
<td>%dil</td>
<td>第1个参数</td>
</tr>
<tr>
<td>%rbp</td>
<td>%ebp</td>
<td>%bp</td>
<td>%bpl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td>%esp</td>
<td>%sp</td>
<td>%spl</td>
<td>栈指针</td>
</tr>
<tr>
<td>%r8</td>
<td>%r8d</td>
<td>%r8w</td>
<td>%r8b</td>
<td>第5个参数</td>
</tr>
<tr>
<td>%r9</td>
<td>%r9d</td>
<td>%r9w</td>
<td>%r9b</td>
<td>第6个参数</td>
</tr>
<tr>
<td>%r10</td>
<td>%r10d</td>
<td>%r10w</td>
<td>%r10b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>%r11d</td>
<td>%r11w</td>
<td>%r11b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>%r12d</td>
<td>%r12w</td>
<td>%r12b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>%r13d</td>
<td>%r13w</td>
<td>%r13b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>%r14d</td>
<td>%r14w</td>
<td>%r14b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>%r15d</td>
<td>%r15w</td>
<td>%r15b</td>
<td>被调用者保存</td>
</tr>
</tbody></table>
<p>指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>*AX</td>
<td>累加器Accumulator</td>
</tr>
<tr>
<td>*BX</td>
<td>基地址寄存器Base Register</td>
</tr>
<tr>
<td>*CX</td>
<td>计数寄存器Count Register</td>
</tr>
<tr>
<td>*DX</td>
<td>数据寄存器Data Register</td>
</tr>
<tr>
<td>*BP</td>
<td>堆栈基指针Base Pointer</td>
</tr>
<tr>
<td>*SI/*DI</td>
<td>变址寄存器Index Register</td>
</tr>
<tr>
<td>*SP</td>
<td>堆栈顶指针Stack Pointer</td>
</tr>
<tr>
<td>*S</td>
<td>段寄存器Segement Register</td>
</tr>
</tbody></table>
<h2 id="MIPS体系结构"><a href="#MIPS体系结构" class="headerlink" title="MIPS体系结构"></a>MIPS体系结构</h2><p>Microprocessor without Interlocked Piped Stage，流水线不会互锁的处理器。避免不同指令间的相互影响。如x86指令的标志寄存器，前一条指令作出的改动会对后面的产生影响，这MIPS所要避免的。</p>
<ul>
<li>它的主要关注点<ul>
<li>减少指令类型</li>
<li>降低指令复杂度</li>
</ul>
</li>
<li>基本原则是用非常简单的CPU解决非常复杂的系统<ul>
<li>越简单的CPU越快</li>
</ul>
</li>
<li>MIPS特点<ul>
<li>固定指令长度(32bit)<ul>
<li>简化了从存储器取指令</li>
</ul>
</li>
<li>简单的寻址模式<ul>
<li>简化了从存储器取操作数</li>
</ul>
</li>
<li>指令数量少，功能简单<ul>
<li>一条指令之完成一个操作</li>
<li>简化指令的执行过程</li>
</ul>
</li>
<li>只允许Load和Store指令访问存储器</li>
<li>MIPS这些特点让使用MIPS进行编程变得困难</li>
</ul>
</li>
</ul>
<h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><ul>
<li>格式：<code>OPT a, b, c</code><ul>
<li>如<code>add a, b, c</code>将b和c求和，结果存如a中</li>
<li>如此还有<ul>
<li><code>sub a, b, c</code></li>
<li><code>mul a, b, c</code></li>
<li><code>div a, b, c</code></li>
<li><code>and a, b, c</code></li>
<li><code>or a, b, c</code></li>
<li><code>sll a, b, c</code>，左移</li>
<li><code>srl a, b, c</code>，右移</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>指令高度统一，而且操作数都不可是存储器操作数，要使用存储器就必须使用专门的访存指令。</p>
<ul>
<li><code>lw $a, $b</code>, load word，读取寄存器b的字(32bit)，放入a中<ul>
<li>MIPS的寄存器编号用<code>$</code>符进行标记</li>
</ul>
</li>
<li><code>sw $a, $b</code>, store word，将寄存器a的字(32bit)，存到b中</li>
</ul>
<p>MIPS有32个通用寄存器，编号从0到31，可以实用<code>$</code>加编号进行指示，也可使用他们的名称(每个寄存器都另有一个名称，并约定了特定的用途)</p>
<h3 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h3><p>MIPS的指令非常的精简</p>
<ul>
<li>按照功能划分<ul>
<li>运算指令</li>
<li>访存指令</li>
<li>分支指令</li>
</ul>
</li>
<li>从指令的格式划分<ul>
<li>R：Register，寄存器</li>
<li>I：Immediate，立即数</li>
<li>J：Jump，转移</li>
</ul>
</li>
</ul>
<h4 id="R型"><a href="#R型" class="headerlink" title="R型"></a>R型</h4><table>
<thead>
<tr>
<th>R</th>
<th>opcode</th>
<th>rs</th>
<th>rt</th>
<th>rd</th>
<th>shamt</th>
<th>funct</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~21</td>
<td>20~16</td>
<td>15~11</td>
<td>10~6</td>
<td>5~0</td>
</tr>
</tbody></table>
<ul>
<li><p>R型指令的格式</p>
<ul>
<li>opcode域指定指令的类型，对于R型指令均为0</li>
<li>funct来精确指定指令的类型</li>
<li>rs：Source Register，通常指定第一个源操作数所在寄存器编号</li>
<li>rt：Target Register，通常指定第二个源操作数所在寄存器编号</li>
<li>rd：Destination Register，通常指定目的操作数所在寄存器编号</li>
<li>shamt用于指定移位指令进行操作数的位数，对于非移位指令为0</li>
</ul>
</li>
<li><p>通过指令得到编码，如<code>add $8, $9, $10</code></p>
<ul>
<li>查MIPS的指令编码表：对于add，opcode=0, funct=32, shamt=0</li>
<li>分析指令操作数：rd=8, rs=9, rt=10</li>
<li>把对应的值转化为二进制数即可得到编码</li>
</ul>
</li>
</ul>
<h4 id="I型"><a href="#I型" class="headerlink" title="I型"></a>I型</h4><p>如果只用5bit来表示立即数，显然不够用，所以对于I型指令需要新的格式</p>
<table>
<thead>
<tr>
<th>I</th>
<th>opcode</th>
<th>rs</th>
<th>rt</th>
<th>immediate</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>16</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~21</td>
<td>20~16</td>
<td>15~0</td>
</tr>
</tbody></table>
<ul>
<li><p>I型指令的格式</p>
<ul>
<li>opcode域指定指令的类型，没有funct</li>
<li>funct来精确指定指令的类型</li>
<li>rs：Source Register，通常指定第一个源操作数所在寄存器编号</li>
<li>rt：Target Register，通常指定第二个源操作数所在寄存器编号</li>
<li>immediate可以存放16位的立即数</li>
</ul>
</li>
<li><p>通过指令得到编码，如<code>add $21, $22, -50</code></p>
<ul>
<li>opcode=8</li>
<li>rs=22, rt=21, immedaite=-50</li>
</ul>
</li>
</ul>
<h4 id="分支指令-条件指令"><a href="#分支指令-条件指令" class="headerlink" title="分支指令(条件指令)"></a>分支指令(条件指令)</h4><ul>
<li>条件分支<ul>
<li>根据比较结果改变控制流</li>
<li><code>beq</code>(branch if equal)<ul>
<li>opcode=4</li>
</ul>
</li>
<li><code>bne</code>(branch if not equal)<ul>
<li>opcode=5</li>
</ul>
</li>
</ul>
</li>
<li>非条件分支<ul>
<li>无条件地改变控制流</li>
<li><code>j</code>(jump)</li>
</ul>
</li>
</ul>
<p>格式：<code>bep reg1, reg2, L1</code><br>    - 前两个是寄存器操作数，第三个是存储器地址(一个立即数，偏移量)<br>    - 不同于x86指令，没有标志寄存器，在一条语句中完成了比较和转移</p>
<table>
<thead>
<tr>
<th>I</th>
<th>opcode</th>
<th>rs</th>
<th>rt</th>
<th>immediate</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>16</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~21</td>
<td>20~16</td>
<td>15~0</td>
</tr>
</tbody></table>
<ul>
<li>如何发挥16bit的作用？<ul>
<li>以当前的PC为基准，16bit偏移量可以表示$\pm 2^{15}$bytes</li>
<li>由于MIPS指令长度固定为32bit，因此我们可以用16bit的立即数来表示每4个字节为一个单位的地址，这样目标地址范围可以扩大4倍。</li>
<li>16bit偏移量可以表示$\pm 2^{17}$bytes</li>
</ul>
</li>
<li>目标地址计算方法<ul>
<li>分支条件不成立时，PC = PC + 4 = 下一条语句</li>
<li>分支条件成立时，PC = PC + 4  + immediate*4</li>
</ul>
</li>
</ul>
<p>对于非条件分支指令</p>
<table>
<thead>
<tr>
<th>J</th>
<th>opcode</th>
<th>immediate</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>26</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~0</td>
</tr>
</tbody></table>
<ul>
<li>不同于条件分支，需要两个寄存器比较，所以可以表示更大的范围</li>
<li>目标地址计算方法：New PC = {(PC+4)后取最高4位, address, 00}</li>
<li>J型指令的目标地址范围：<code>\pm 2^{28}</code>bytes<ul>
<li>如何到达更远的目标地址？<ul>
<li>两次调用j指令</li>
<li>使用jr指令：<code>jr rs</code>，可把要转移的目标地址放在寄存器中，这样就可以使用32位的目标地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="算数逻辑单元"><a href="#算数逻辑单元" class="headerlink" title="算数逻辑单元"></a>算数逻辑单元</h2><p>通过MIPS指令来做示例</p>
<h3 id="算数运算和逻辑运算"><a href="#算数运算和逻辑运算" class="headerlink" title="算数运算和逻辑运算"></a>算数运算和逻辑运算</h3><p>把编码好的指令，如<code>add r1, r2, r3</code>放入IR寄存器中，根据各个域的数值控制电路向ALU发出信号：输入、输出、运算方法等。</p>
<p>在如对于立即数加法：<code>addi</code>，ALU接受到信号，通过opcode知道要进行立即数加法，把把源寄存器作为输入，把输出放入目标寄存器。</p>
<ul>
<li>立即数是16bit的，但寄存器是32bit的，要能成功相加，需要扩展16bit<ul>
<li>MIPS使用补码，所以这个立即数采用符号扩展，不会改变补码的值</li>
</ul>
</li>
</ul>
<p>对于逻辑运算，与算数运算类似，只是立即数采用0扩展。</p>
<h3 id="门电路的基本原理"><a href="#门电路的基本原理" class="headerlink" title="门电路的基本原理"></a>门电路的基本原理</h3><p>现代集成电路通常使用MOS晶体管</p>
<ul>
<li>N型MOS管<ul>
<li>Source源：电流流入</li>
<li>Drain漏：电流流出</li>
<li>Gate门：控制，高电频导通</li>
</ul>
</li>
<li>P型MOS管<ul>
<li>Source源：电流流入</li>
<li>Drain漏：电流流出</li>
<li>Gate门：控制，低电频导通</li>
</ul>
</li>
<li>用这两种晶体管就构成了互补型的MOS关：CMOS</li>
</ul>
<p>逻辑门由晶体管构成，各种逻辑门的结构这里就不说了</p>
<h3 id="寄存器的原理"><a href="#寄存器的原理" class="headerlink" title="寄存器的原理"></a>寄存器的原理</h3><p>在MIPS结构中，寄存器是由32个位组成，从电路上来说每个bit都是一样的，都是一个 <strong>D触发器</strong>。</p>
<ul>
<li>D触发器<ul>
<li>具有存储信息能力的基本单元</li>
<li>由若干逻辑门构成，有多种实现方式</li>
<li>主要有1个数据输入、1个数据输出和1个时钟输入</li>
<li>在上升沿，采样输入D的值，传送到输出Q，其余时间输出Q的值不变</li>
<li>要求采样信号前后有一段很短的稳定时间</li>
</ul>
</li>
</ul>
<p>用32个D触发器构成MIPS的寄存器，在将寄存器用逻辑门相连，就构成了CPU。</p>
<h3 id="逻辑运算的实现"><a href="#逻辑运算的实现" class="headerlink" title="逻辑运算的实现"></a>逻辑运算的实现</h3><p>ALU中包含很多中运算单元，以与元算单元为例：32位的输入需要32个与逻辑门处理，得到对应的32位输出。ALU包含多个单元，一组输入通过不同的单元，的到多组输出，这时需要一个多选器根据选择信号(opcode)对这些输出进行选择，得到一个32位的输出。</p>
<h3 id="加减法的实现"><a href="#加减法的实现" class="headerlink" title="加减法的实现"></a>加减法的实现</h3><ul>
<li><p>半加器</p>
<ul>
<li>将两个一位二进制数相加</li>
<li>不能将进位位用与加法</li>
</ul>
</li>
<li><p>全加器</p>
<ul>
<li>由两个半加器组成</li>
<li>能将进位位用与加法</li>
</ul>
</li>
<li><p>MIPS对溢出的处理方式</p>
<ul>
<li>将操作数看做有符号数<code>add</code>和<code>addi</code><ul>
<li>发生溢出时会产生异常</li>
</ul>
</li>
<li>将操作数看做无符号数<code>addu</code>和<code>addiu</code><ul>
<li>不处理溢出</li>
</ul>
</li>
</ul>
</li>
<li><p>x86对溢出的处理方式</p>
<ul>
<li>采用溢出标志OF，根据标志寄存器OF来进行相应的操作</li>
</ul>
</li>
</ul>
<p>对于减法运算，减法可以转换成加法，那么就要对一个数进行取反操作</p>
<ul>
<li>补码表示的二进制数取反<ul>
<li>规则：按位取反，末位加一</li>
<li>推导 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x :010101</span><br><span class="line">~x:101010</span><br><span class="line">----------</span><br><span class="line">-1:111111</span><br><span class="line"></span><br><span class="line">x + (~x) &#x3D; -1</span><br><span class="line"></span><br><span class="line">(~x) + 1 &#x3D; -x</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="加法器的优化"><a href="#加法器的优化" class="headerlink" title="加法器的优化"></a>加法器的优化</h3><p>前面将的加法有一个个的全加器串联而成，需要等待进位输入，延迟长。进位像波一样传递，这样的加法器也称为 <strong>行波进位加法器(RCA)</strong> 。</p>
<ul>
<li>超前进位加法器(CLA)<ul>
<li>优点： <ul>
<li>计算延迟时间固定为三级门延迟</li>
</ul>
</li>
<li>缺点：<ul>
<li>进一步扩宽加法器的位数，则电路变得非常复杂</li>
</ul>
</li>
<li>因此通常使用小规模的CLA拼接形成加法器</li>
</ul>
</li>
</ul>
<h2 id="乘法器和除法器"><a href="#乘法器和除法器" class="headerlink" title="乘法器和除法器"></a>乘法器和除法器</h2><p>整数乘法指令相当慢，需要多个时钟周期，然而其他的整数运算(如加法、减法、位移)之需要1个时钟周期。因此编译器使用了一项重要的优化：试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
<p>如$x \times 14$，$14=2^3+2^2+2^1$，编译器将乘法重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)，将一个乘法代替为3个移位和2个加法。甚至还可以$14=2^4-2^1$。</p>
<h3 id="乘法器的实现"><a href="#乘法器的实现" class="headerlink" title="乘法器的实现"></a>乘法器的实现</h3><p>观察下列乘法过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   1000</span><br><span class="line">   1001</span><br><span class="line">   ------</span><br><span class="line">   1000</span><br><span class="line">  0000_   好似乘数左移乘</span><br><span class="line"> 0000__</span><br><span class="line">1000___</span><br></pre></td></tr></table></figure>

<p>一个N位乘法器需要3个寄存器，分别设为被乘数md，乘mr，结果res。由上列过程得到启发，过程如下：</p>
<ul>
<li><p>如果被乘数第一位不为0则乘以乘数</p>
</li>
<li><p>把结果加到res中</p>
</li>
<li><p>乘数右移，被乘数左移</p>
</li>
<li><p>如果执行了N次则乘法结束，否则回到第一步</p>
</li>
<li><p>对N位乘法器进行优化</p>
<ul>
<li><ol>
<li>加法移位并行<ul>
<li>通过控制器，控制移位，在一个时钟周期完成移位操作</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>减少不必要的硬件资源<ul>
<li>md由于左移，储存需要的位数是它原始位宽的两倍<ul>
<li>取消左移</li>
</ul>
</li>
<li>mr右移有效数字每个周期减少1位<ul>
<li>用res的低4为存放，因此可以取消mr</li>
</ul>
</li>
<li>res每个周期增加1位<ul>
<li>增加右移，来代替md的左移，乘积始终放在高4位</li>
</ul>
</li>
<li>加法器参加运输，但实际有效数字自由其位宽的一半<ul>
<li>md和res的高4位进行运算</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="除法的运算过程"><a href="#除法的运算过程" class="headerlink" title="除法的运算过程"></a>除法的运算过程</h3><p>观察除法的运算过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">         0001        结果累加，相当于左移</span><br><span class="line">        0001</span><br><span class="line">       0000</span><br><span class="line">      0000</span><br><span class="line">     0000            0010&lt;0000所以商为0</span><br><span class="line">0010&#x2F;00000111</span><br><span class="line">     0010____        相当于右移</span><br><span class="line">      0010</span><br><span class="line">       0010</span><br><span class="line">        0010</span><br><span class="line">        ----</span><br><span class="line">         0011</span><br><span class="line">         0010</span><br><span class="line">         ----</span><br><span class="line">            1        记录余数</span><br></pre></td></tr></table></figure>

<p>过程如下</p>
<ul>
<li>余数寄存器减去除数，检测最高位判断大小</li>
<li>除数右移</li>
<li>商左移，累加</li>
</ul>
<p>除法器的优化:</p>
<ul>
<li><ol>
<li>硬件资源优化<ul>
<li>除数寄存器实际只用了一半</li>
<li>商寄存器初始的空的，从右到左逐位填满</li>
<li>余数初始是满的，有意义的位从左到右逐位减少</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>性能资源优化</li>
</ol>
</li>
</ul>
<h2 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h2><h3 id="处理器设计的主要步骤"><a href="#处理器设计的主要步骤" class="headerlink" title="处理器设计的主要步骤"></a>处理器设计的主要步骤</h3><ul>
<li><ol>
<li>分析指令系统，得出对数据通路的需求</li>
</ol>
</li>
<li><ol start="2">
<li>为数据通路选择合适的组件</li>
</ol>
</li>
<li><ol start="3">
<li>连接组件建立数据通路</li>
</ol>
</li>
<li><ol start="4">
<li>分析每条指令的实现，以确定控制信号</li>
</ol>
</li>
<li><ol start="5">
<li>集成控制信号，形成完整的控制逻辑，控制器</li>
</ol>
</li>
</ul>
<p>下面以一个简化的MIPS指令系统作为实例，改系统的指令有：</p>
<ul>
<li>无符号加法和和减法<ul>
<li><code>addu rd, rs, rt</code></li>
<li><code>subu rd, rs, rt</code></li>
</ul>
</li>
<li>立即数的逻辑或<ul>
<li><code>ori rt, rs, imm16</code></li>
</ul>
</li>
<li>装载和储存一个字<ul>
<li><code>lw rt, imm16(rs)</code></li>
<li><code>sw rt, imm16(rs)</code></li>
</ul>
</li>
<li>条件分支<ul>
<li><code>bep rs, rt, imm16</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>R</th>
<th>opcode</th>
<th>rs</th>
<th>rt</th>
<th>rd</th>
<th>shamt</th>
<th>funct</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~21</td>
<td>20~16</td>
<td>15~11</td>
<td>10~6</td>
<td>5~0</td>
</tr>
</tbody></table>
<ul>
<li><p>指令位域分解</p>
<ul>
<li>R型指令：{op, rs, rt, rd, shamt, funct}</li>
<li>I型指令：{op, rs, rt, imm16}</li>
<li>需求：<ul>
<li>存放指令的存储器</li>
<li>PC:存放地址的32位寄存器</li>
</ul>
</li>
</ul>
</li>
<li><p>通过指令操作分析需求</p>
<ul>
<li>运算指令需求：<ul>
<li>一组存放数据的通用寄存器，这些寄存器称为寄存器堆</li>
<li>同时读取两个寄存器的内容</li>
<li>写入一个寄存器的内容，保存结果</li>
<li>将16位的立即数扩展到32位，供I型指令需要</li>
<li>提供加、减、逻辑或功能的运算器</li>
<li>运算器的操作数可以时寄存器或立即数</li>
</ul>
</li>
<li>访存指令<ul>
<li>存放数据的储存器，可读可写</li>
<li>将16位的立即数扩展到32位，供I型指令需要</li>
</ul>
</li>
<li>分支指令<ul>
<li>比较内容，判断是否相等</li>
<li>PC寄存器支持两种自增方式，加4或加一个立即数</li>
</ul>
</li>
</ul>
</li>
<li><p>整理：</p>
<ul>
<li>算数逻辑单元(ALU)<ul>
<li>支持运算类型</li>
<li>操作数</li>
</ul>
</li>
<li>立即数扩展部件<ul>
<li>支持0扩展、符号扩展</li>
</ul>
</li>
<li>程序计数器(PC)<ul>
<li>支持两种自增方式，加4或加一个立即数</li>
</ul>
</li>
<li>寄存器堆<ul>
<li>支持读操作：rs和rt</li>
<li>支持写操作：rt和rd</li>
</ul>
</li>
<li>存储器<ul>
<li>一个只读指令存储器</li>
<li>一个可读写的数据存储器</li>
</ul>
</li>
</ul>
</li>
<li><p>寄存器堆</p>
<ul>
<li>内部构成<ul>
<li>32个32位的寄存器</li>
</ul>
</li>
<li>数据接口信号<ul>
<li>busA、busB：两组32位的数据输出</li>
<li>busW：一组32位的数据输入</li>
</ul>
</li>
<li>读写控制<ul>
<li>Ra(5bit)：选中对应编号的寄存器，将其内容放到busA</li>
<li>Rb(5bit)：选中对应编号的寄存器，将其内容放到busB</li>
<li>Rw(5bit)：选中对应编号的寄存器，在时钟信号的上升沿，如果写使能信号有效，将busW的内容写入改寄存器</li>
<li>读操作不受时钟信号控制</li>
</ul>
</li>
</ul>
</li>
<li><p>存储器</p>
<ul>
<li>数据接口信号<ul>
<li>Date In：32位的数据输入信号</li>
<li>Data Out：32位的数据输出信号</li>
</ul>
</li>
<li>读写操作<ul>
<li>Address：32位的地址信号。该信号指定一个存储单元，将其内容送到数据输入信号</li>
<li>Write Enable：写使能信号，在时钟上升沿，如果写使能信号有效，将数据输入信号的内容存入地址信号指定的存储单元</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据通路的建立"><a href="#数据通路的建立" class="headerlink" title="数据通路的建立"></a>数据通路的建立</h3><ul>
<li>基本原则<ul>
<li>根据指令需求，连接组件，建立数据通路</li>
</ul>
</li>
<li>指令的需求<ul>
<li>所有指令的共同需求<ul>
<li>取指令，由IFU(Instruction Fetch Unit)完成<ul>
<li>程序计数器(PC)的内容是指令的地址</li>
<li>用PC的内容作为地址，访问指令存储器获得指令编码</li>
</ul>
</li>
<li>更新程序计数器PC<ul>
<li>顺序时PC+=4</li>
<li>分支时PC=目标地址</li>
</ul>
</li>
</ul>
</li>
<li>不同指令的各自需求<ul>
<li>加减法指令的需求</li>
<li>逻辑运算指令的需求</li>
<li>访存指令需求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="运算指令的控制信号"><a href="#运算指令的控制信号" class="headerlink" title="运算指令的控制信号"></a>运算指令的控制信号</h3><p>以加法运算指令为例：</p>
<ul>
<li><ol>
<li>通过IFU取指令</li>
</ol>
</li>
<li><ol start="2">
<li>执行加法<ul>
<li>解析IFU的输出，放入寄存器堆对应的输入中</li>
<li>busB如果是立即数需要扩展<ul>
<li>扩展又有0扩展和符号扩展</li>
</ul>
</li>
<li>对ALU：给ALU信号使其执行加法计算</li>
<li>对数据存储器：如果不需要数据存储器，写使能信号关闭，防止对结果修改</li>
<li>要写入寄存器，所有要把寄存器的写使能信号设为有效</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>更新PC寄存器的内容</li>
</ol>
</li>
</ul>
<p>访存指令、分支指令同理</p>
<h3 id="控制信号的集成"><a href="#控制信号的集成" class="headerlink" title="控制信号的集成"></a>控制信号的集成</h3><p>把之前的控制信号集成起来，形成完整的控制逻辑。</p>
<h2 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h2><h3 id="流水线的基本原理"><a href="#流水线的基本原理" class="headerlink" title="流水线的基本原理"></a>流水线的基本原理</h3><p>执行MIPS指令的主要步骤：</p>
<ul>
<li>取值</li>
<li>译码</li>
<li>执行</li>
<li>访存</li>
<li>回写</li>
</ul>
<p>分工明确好似非常适合使用流水线，每个人专注于自己的工作，每个硬件都有使用。</p>
<p>我们需要将每个部分的输出放入一个流水线寄存器，这样当输出保存在流水线寄存器后，前面的寄存器就可以开始新的工作而不影响后面的工作。下一个硬件又从流水线寄存器中取上一个硬件的输入。</p>
<p>虽然每条指令要经历的时间不变，但是当流水线填满是，每个时钟周期都能产生一条指令，性能提升不少。</p>
<h3 id="流水线的优化"><a href="#流水线的优化" class="headerlink" title="流水线的优化"></a>流水线的优化</h3><p>如果只是简单的按照指令执行的步骤取切分流水线的话不能充分发挥流水线的优势。</p>
<p>时钟周期的大小取决于耗时最长的那个步骤，如果流水线平衡性较差，性能提升幅度下降。</p>
<p>流水线的深度并非越深越好，应用流水线寄存器也会产生时延。越深的流水线说明需要的流水线寄存器越多。单条指令的执行时间越长。</p>
<h3 id="超标量流水线"><a href="#超标量流水线" class="headerlink" title="超标量流水线"></a>超标量流水线</h3><p>除了增加流水线深度来提供速度，还有一种方式就是拓宽流水线，这样的流水线就称为超标量流水线。通常具有两条或以上并行工作的流水线称为超标量结构。也可称为超量。</p>
<h3 id="流水线的”冒险”"><a href="#流水线的”冒险”" class="headerlink" title="流水线的”冒险”"></a>流水线的”冒险”</h3><ul>
<li>“冒险”(Hazard)：阻止下一条指令在下一个时钟周期开始执行的情况<ul>
<li>结构冒险<ul>
<li>所有的硬件部件正在位之前的指令工作</li>
<li>对于只读存储器，一次只能有一个硬件进行读取<ul>
<li>解决方案1：流水线停顿(不同时使用这个硬件)，产生空泡(不会影响状态的值)<ul>
<li>但如果等待后有与另一个硬件冲突则又要停顿，这样效率很低</li>
</ul>
</li>
<li>解决方案2：指令和数据放在不同的存储器中</li>
</ul>
</li>
<li>对于可读写的寄存器，读写同时发生显然不是一个明智的选择<ul>
<li>解决方案：前半个时钟周期写，后半个读，并设置独立的读写口</li>
<li>支持这么做的原因是寄存器的读写速度较快</li>
</ul>
</li>
</ul>
</li>
<li>数据冒险<ul>
<li>需要等待之前的指令完成数据的读写</li>
<li>如果下一条指令需要上一条指令的数据，但是上一条指令可能还没写回<ul>
<li>解决方案1：停顿</li>
</ul>
</li>
</ul>
</li>
<li>控制冒险<ul>
<li>需要根据之前指令的结果决定下一步的行为</li>
<li>类似数据冒险，指令不能确定是否发生分支，需要几个周期后才知道<ul>
<li>解决方案1：停顿</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据冒险的处理"><a href="#数据冒险的处理" class="headerlink" title="数据冒险的处理"></a>数据冒险的处理</h3><ul>
<li>软件解决方案(停顿)：插入nop指令，什么都不干<ul>
<li>插入几条nop指令存在问题，不同的处理器的流水线深度可能不同，导致兼容。因此一般不通过软件层面解决硬件问题</li>
</ul>
</li>
<li>流水线停顿，产生空泡<ul>
<li>这样的空泡由硬件产生</li>
<li>检查数据冒险，如果有则插入空泡</li>
</ul>
</li>
<li>数据前递(或称为旁路)<ul>
<li>如加法运算，即使没有写回，它的运算结果其实已经在流水线寄存器中了，我们只需引用流水线寄存器上的值</li>
<li>但对于load指令数据前递不适用，因为load指令的值较迟产生</li>
</ul>
</li>
</ul>
<h3 id="控制冒险的处理"><a href="#控制冒险的处理" class="headerlink" title="控制冒险的处理"></a>控制冒险的处理</h3><ul>
<li>当执行了转移指令，并确实发生转移时，产生如下的开销，称为”转移开销”<ul>
<li><ol>
<li>将按顺序预取的指令废除(排空流水线)</li>
</ol>
</li>
<li><ol start="2">
<li>从转移目标地址重新取指定</li>
</ol>
</li>
</ul>
</li>
<li>转移开销的构成<ul>
<li>要不要转移，判断条件引起的开销</li>
<li>转移到哪，生成目标地址引起的开销</li>
</ul>
</li>
</ul>
<h2 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h2><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><ul>
<li>冯诺依曼计算机结构：<ul>
<li>运算器CA</li>
<li>控制器CC</li>
<li>存储器M<ul>
<li>层次结构：<ul>
<li>通用寄存器：CPU</li>
<li>高速缓存：SRAM</li>
<li>主存：DRAM</li>
<li>本地二级存储：Disk</li>
<li>越往上越快、容量越小价格越高</li>
</ul>
</li>
</ul>
</li>
<li>输入I</li>
<li>输出O</li>
</ul>
</li>
</ul>
<h3 id="DRAM和SRAM"><a href="#DRAM和SRAM" class="headerlink" title="DRAM和SRAM"></a>DRAM和SRAM</h3><table>
<thead>
<tr>
<th></th>
<th>DRAM</th>
<th>SRAM</th>
</tr>
</thead>
<tbody><tr>
<td>储存单元</td>
<td>电容</td>
<td>双稳态触发器</td>
</tr>
<tr>
<td>集成度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>功耗</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>价格</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>块</td>
</tr>
<tr>
<td>刷新</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="主存-内存-的工作原理"><a href="#主存-内存-的工作原理" class="headerlink" title="主存(内存)的工作原理"></a>主存(内存)的工作原理</h3><p>DRAM芯片以一个存储阵列位核心，通过指定行列地址取出对应的存储单元(4比特或8比特)。一个内存条往往有多个DRAM芯片(4的倍数)，构成一个内存模组。从外部给入行列地址后地址会同时送到每个DRAM芯片，每个DRAM芯片同时选择储存器单元，存储单元同时输出，组成一个64/32位的数。</p>
<p>缓存速度很快，一般放在CPU中。CPU访问内存的过程：SDRAM(同步DRAM)的访存过程为例：</p>
<ul>
<li>CPU通过系统总线连接到内存控制器，内存控制器再通过存储总线连接到内存条<ul>
<li>CPU需要访问控制器时：<ul>
<li>申请系统总线，获得总线控制权后把地址发到控制器中</li>
</ul>
</li>
<li>控制器对地址分解形成行地址和列地址，然后向DRAM发起访存操作<ul>
<li><ol>
<li>预充电</li>
</ol>
</li>
<li><ol start="2">
<li>行访问:DRAM中的行译码芯片，选出对应行，所有单元的信号放大后放在一个缓冲区</li>
</ol>
</li>
<li><ol start="3">
<li>缓冲区信号稳定后，才能发出列地址，其中tRCD是冲行选到列选的延迟</li>
</ol>
</li>
<li><ol start="4">
<li>列译码器接受到列地址后，从缓冲区读出对应的列，放到数据接受接口。其中从发出列地址到选出对应存储单元的数的过程称为列访问，这段时间称为CL</li>
</ol>
</li>
</ul>
</li>
<li>内存送出数据后，控制器采样并送到CPU<ul>
<li>如果CPU的下次请求是同一行，则控制器不再发送行地址，而是直接发送列地址</li>
<li>如果下次访问不是同一行则需把缓冲区的行关闭，这个过程就叫做 <strong>预充电</strong> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="主存技术的发展"><a href="#主存技术的发展" class="headerlink" title="主存技术的发展"></a>主存技术的发展</h3><ul>
<li>DDR:Double Data Rate<ul>
<li>时钟的上升沿和下降沿都传输</li>
</ul>
</li>
<li>SDR:Single Data Rate<ul>
<li>只在时钟的上升沿传输</li>
</ul>
</li>
</ul>
<p>building</p>
<h3 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h3><p>$$Cpu \leftrightarrow Cache \leftrightarrow Main Memory$$</p>
<ul>
<li>程序的局部性原理:计算机程序从空间和时间都表现出局部性<ul>
<li>时间局部性<ul>
<li>最近被访问的存储器单元(指令或数据)很快会被访问</li>
</ul>
</li>
<li>空间局部性<ul>
<li>正在被访问的存储器单元附近的单元很快会被访问到</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        sum+=a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i很快会(频繁)被访问</span></span><br><span class="line"><span class="comment">// a数组附件的单元很快会被访问</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>cache的基本原理</p>
<ul>
<li>cache对空间局部性的利用<ul>
<li>从主存中取回待访问数据时，会同时取回与位置相邻的主存单元的数据</li>
<li>以数据块(Block)为单位和主存进行数据交换</li>
</ul>
</li>
<li>cache对时间局部性的利用<ul>
<li>保存近期频繁被访问的主存单元的数据</li>
</ul>
</li>
<li>这样如果cache中有数据(cache命中)则从cache中获取</li>
</ul>
</li>
<li><p>cache的写策略</p>
<ul>
<li>cache命中时的写策略<ul>
<li>写穿透：数据同时写入cache和主存</li>
<li>写返回：数据只写入cache，仅当改数据块被替换时才写入主存</li>
</ul>
</li>
<li>cache失效时的写策略<ul>
<li>写不分配：直接写入主存</li>
<li>写分配：将该数据所在的块读入cache后，在将数据写入cache，利用局部性原理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="高速缓存的设计要点"><a href="#高速缓存的设计要点" class="headerlink" title="高速缓存的设计要点"></a>高速缓存的设计要点</h3><ul>
<li>平均访存时间(Average Memory Access Time)=Hit Time + Miss Penalty x Miss Rate<ul>
<li>Hit Time：命中时间，从cache将命中数据返回的时间</li>
<li>Miss Penalty：失效代价，从主存读取数据并返回的时间</li>
<li>Miss Rate：失效率，未命中的概率</li>
<li>降低访存时间主要就是降低这3个参数</li>
</ul>
</li>
<li>cache失效的原因<ul>
<li>义务失效：第一次访问<ul>
<li>无法避免</li>
</ul>
</li>
<li>容量失效：无法保存程序所需的所有数据块<ul>
<li>可增加cache容量缓解，但会增加命中时间</li>
</ul>
</li>
<li>冲突失效：多个存储器位置映射到同一个cache位置<ul>
<li>需要精心设计映射策略</li>
</ul>
</li>
</ul>
</li>
<li>映射策略<ul>
<li>直接映射</li>
<li>多路组相联(相当于用几个表来保存，但是表越多就要用越复杂的电路判断是否在其中一个表中)</li>
<li>常见的cache替换算法<ul>
<li>随机</li>
<li>轮换</li>
<li>最近最少使用(LRU)：效果最好但设计复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存储器容量的计算"><a href="#存储器容量的计算" class="headerlink" title="存储器容量的计算"></a>存储器容量的计算</h3><table>
<thead>
<tr>
<th>&lt;++&gt;</th>
<th>&lt;++&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>Ki:kibi</td>
<td>$1024^1$</td>
</tr>
<tr>
<td>Mi:mebi</td>
<td>$1024^2$</td>
</tr>
<tr>
<td>..</td>
<td>..</td>
</tr>
</tbody></table>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="中断向量表的结构"><a href="#中断向量表的结构" class="headerlink" title="中断向量表的结构"></a>中断向量表的结构</h3><p>不同的中断产生不同的中断码，根据中断向量表查询得到对应的处理方法。</p>
<ul>
<li>中断向量：中断服务程序的入口地址</li>
<li>中断向量表存放在固定的地址</li>
<li>处理方法会事先存放在中断向量对应的地址处</li>
</ul>
<h3 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h3><ul>
<li><ol>
<li>关中断<ul>
<li>CPU关闭中断响应，不再接受其他外部中断请求</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>保存断点<ul>
<li>将发送中断处理的指令压入堆栈，处理完后正确返回</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>识别中断源<ul>
<li>确定中断类型号，从而找到相应的中断处理程序的入口地址</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>保存现场<ul>
<li>保存正在处理的程序</li>
</ul>
</li>
</ol>
</li>
<li><ol start="5">
<li>执行中断服务程序<ul>
<li>转到中断服务程序入口开始执行，可在适当的时刻重新开放中断，以便允许相应较高优先级的外部中断</li>
<li>重新开放由标识寄存器控制</li>
</ul>
</li>
</ol>
</li>
<li><ol start="6">
<li>恢复现场(8086为例)<ul>
<li>IRET指令(中断返回)，从栈顶弹出3个字分别送入IP、CS和FLAGS寄存器</li>
<li>放在中断服务程序的末尾</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="基于中断的功能调用"><a href="#基于中断的功能调用" class="headerlink" title="基于中断的功能调用"></a>基于中断的功能调用</h3><ul>
<li>指令<code>int N</code><ul>
<li>调用n号中断,由运行指令主动触发</li>
</ul>
</li>
</ul>
<h2 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h2><h3 id="输入输出接口的基本功能"><a href="#输入输出接口的基本功能" class="headerlink" title="输入输出接口的基本功能"></a>输入输出接口的基本功能</h3><ul>
<li>I/O接口改的基本功能<ul>
<li>数据缓冲<ul>
<li>解决CPU和外设之间的速度差距</li>
</ul>
</li>
<li>提供联络信息<ul>
<li>协调与同步数据交换过程</li>
</ul>
</li>
<li>信号与信息格式的转换<ul>
<li>模/数、数/模交换，串/并、并/串交换，电平转换</li>
</ul>
</li>
<li>设备选择</li>
<li>中断管理</li>
<li>可编程功能</li>
</ul>
</li>
</ul>
<h3 id="输入输出接口的编址方式"><a href="#输入输出接口的编址方式" class="headerlink" title="输入输出接口的编址方式"></a>输入输出接口的编址方式</h3><ul>
<li>I/O端口和存储器分开编址<ul>
<li>I/O映像的I/O方式，I/O Mapped I/O</li>
<li>x86就是这种方式</li>
<li>I/O指令<ul>
<li>IN指令<ul>
<li><code>IN AC, PORT</code></li>
<li>把外设端口内容输入到AL或AX</li>
</ul>
</li>
<li>OUT指令<ul>
<li><code>OUT PORT, AC</code></li>
<li>把AL或AX的内容输出到外设端口</li>
</ul>
</li>
<li>端口地址小于255时可以用立即数，否则需要寄存器</li>
</ul>
</li>
</ul>
</li>
<li>I/O端口和存储器统一编址<ul>
<li>存储器映像的I/O方式，Memory Mapped I/O</li>
<li>MIPS就是这种方式</li>
<li>优点<ul>
<li>可以用访问存储器的指令访问I/O端口，可以实现直接对I/O端口内的数据进行处理</li>
<li>CPU中的I/O操作与访问存储器的操作统一为一套控制逻辑，简化内部结构，减少PCU引脚的数目</li>
</ul>
</li>
<li>缺点<ul>
<li>I/O端口占用一部分存储器地址空间，使得存储器地址空间减小</li>
<li>由于利用访问存储器的指令来进行IO操作，指令的长度通常比单独IO指令要长，执行时间也较长</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="输入输出的控制方式"><a href="#输入输出的控制方式" class="headerlink" title="输入输出的控制方式"></a>输入输出的控制方式</h3><ul>
<li>IO控制方式的分类<ul>
<li>程序控制方式<ul>
<li>无条件传送方式<ul>
<li>假设外设已经准备号</li>
<li>CPU直接使用指令与外设传送数据</li>
<li>不查询外设的工作状态</li>
</ul>
</li>
<li>程序查询传送方式<ul>
<li>CPU通过指令一段程序，不断查询外设的工作状态<ul>
<li>握手信号，检查输入输出缓冲</li>
</ul>
</li>
<li>在外设准备就绪后草进行数据传送</li>
<li>CPU的不断查询浪费了很多资源</li>
</ul>
</li>
</ul>
</li>
<li>中断控制方式<ul>
<li>通过中断的方式，将数据”一块一块”地传送，当输入输出缓冲达到一定条件时，引发中断，提醒CPU的继续输入或读取等</li>
<li>优点<ul>
<li>CPU可和外设并行工作</li>
<li>外围设备具有申请父亲的主动权</li>
<li>一定程度上满足了IO处理的实时性要求</li>
</ul>
</li>
<li>缺点<ul>
<li>输入输出的数据仍由CPU承担</li>
<li>进入和退出中断增加消耗</li>
</ul>
</li>
</ul>
</li>
<li>直接存储器访问(DMA)方式<ul>
<li>前面的方式的共同确定是数据传输仍由CPU承担，但是如果是显示器，网络等需要大量数据传输的设备就难以应对了</li>
<li>Direct Memory Access(DMA)<ul>
<li>数据传送过程不需要CPU干预(不需要指令程序指令)</li>
<li>由专门的硬件控制电路控制，进行外设与存储器间直接数据传送</li>
<li>该专门硬件控制电路称为DMA控制器，简称DMAC</li>
</ul>
</li>
<li>DMAC的基本工作步骤(以使用独立DMAC进行外设到内存传送为例)<ul>
<li><ol>
<li>CPU设置DMAC内部配置寄存器<ul>
<li>源地址的初始值以及传送是的地址增减方式</li>
<li>目的地址的初始值以及传送是的地址增减方式</li>
<li>待传送数据的长度</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>DMAC处于空闲等待状态</li>
</ol>
</li>
<li><ol start="3">
<li>IO接口向DMAC传送申请</li>
</ol>
</li>
<li><ol start="4">
<li>DMAC响应IO接口的申请</li>
</ol>
</li>
<li><ol start="5">
<li>DMAC向IO接口发起总线读传输</li>
</ol>
</li>
<li><ol start="6">
<li>DMAC向存储器发起总线写传输</li>
</ol>
</li>
<li><ol start="7">
<li>重复5～6直到本次DMA传送完成</li>
</ol>
</li>
<li><ol start="8">
<li>返回2，等待下一次DMA传送申请</li>
</ol>
</li>
</ul>
</li>
<li>通常，DMA传送完成后DMAC会通过中断信号通知CPU</li>
</ul>
</li>
</ul>
</li>
</ul>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=http://github.com/66ring/2019/12/10/Major/compuer_organization/>http://github.com/66ring/2019/12/10/Major/compuer_organization/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>计算机组成</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2020/01/19/universe/operate/load_balance_in_nginx/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>nginx中的负载均衡</p>
          <p class='content'>Abstract一个网页为了应对高并发的情景，常常会使用多台后台服务器还处理用户的响应，这种增加节点个数的扩展方式就称为”水平扩展”。而即使后台使用了成百上千台服务器，用户可以不需要跟每个服务器...</p>
        </a>
      
      
        <a class='next' href='/2019/12/04/universe/c/c_fragments/'>
          <p class='title'>c/cpp语言碎片知识<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>c读写读取字符串
读取单个字符
getchar()是scanf(&quot;%c&quot;, c)的简化版本，除了更简介无其他优势
getche()，没有缓冲区，输入一个字符后立即读取，不等待...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>





  <script>
  // https://github.com/theme-next/hexo-theme-next/blob/master/layout/_third-party/math/mathjax.swig
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.0/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    // 文章章节标题不能为 “MathJax” ，否则会报错。
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序结构和执行"><span class="toc-text">程序结构和执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整数运算"><span class="toc-text">整数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无符号加法"><span class="toc-text">无符号加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#乘以常数"><span class="toc-text">乘以常数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#除以2的幂"><span class="toc-text">除以2的幂</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮点数"><span class="toc-text">浮点数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IEEE浮点数表示"><span class="toc-text">IEEE浮点数表示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序的机器级表示"><span class="toc-text">程序的机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据格式"><span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问信息"><span class="toc-text">访问信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MIPS体系结构"><span class="toc-text">MIPS体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本指令"><span class="toc-text">基本指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指令的基本格式"><span class="toc-text">指令的基本格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#R型"><span class="toc-text">R型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I型"><span class="toc-text">I型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分支指令-条件指令"><span class="toc-text">分支指令(条件指令)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算数逻辑单元"><span class="toc-text">算数逻辑单元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算数运算和逻辑运算"><span class="toc-text">算数运算和逻辑运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#门电路的基本原理"><span class="toc-text">门电路的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器的原理"><span class="toc-text">寄存器的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逻辑运算的实现"><span class="toc-text">逻辑运算的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加减法的实现"><span class="toc-text">加减法的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加法器的优化"><span class="toc-text">加法器的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#乘法器和除法器"><span class="toc-text">乘法器和除法器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#乘法器的实现"><span class="toc-text">乘法器的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#除法的运算过程"><span class="toc-text">除法的运算过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单周期处理器"><span class="toc-text">单周期处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#处理器设计的主要步骤"><span class="toc-text">处理器设计的主要步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据通路的建立"><span class="toc-text">数据通路的建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算指令的控制信号"><span class="toc-text">运算指令的控制信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制信号的集成"><span class="toc-text">控制信号的集成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流水线处理器"><span class="toc-text">流水线处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#流水线的基本原理"><span class="toc-text">流水线的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流水线的优化"><span class="toc-text">流水线的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超标量流水线"><span class="toc-text">超标量流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流水线的”冒险”"><span class="toc-text">流水线的”冒险”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据冒险的处理"><span class="toc-text">数据冒险的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制冒险的处理"><span class="toc-text">控制冒险的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储层次结构"><span class="toc-text">存储层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概况"><span class="toc-text">概况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DRAM和SRAM"><span class="toc-text">DRAM和SRAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主存-内存-的工作原理"><span class="toc-text">主存(内存)的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主存技术的发展"><span class="toc-text">主存技术的发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高速缓存的工作原理"><span class="toc-text">高速缓存的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高速缓存的设计要点"><span class="toc-text">高速缓存的设计要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储器容量的计算"><span class="toc-text">存储器容量的计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断和异常"><span class="toc-text">中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#中断向量表的结构"><span class="toc-text">中断向量表的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断的处理过程"><span class="toc-text">中断的处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于中断的功能调用"><span class="toc-text">基于中断的功能调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入输出设备"><span class="toc-text">输入输出设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#输入输出接口的基本功能"><span class="toc-text">输入输出接口的基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入输出接口的编址方式"><span class="toc-text">输入输出接口的编址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入输出的控制方式"><span class="toc-text">输入输出的控制方式</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>



		  
		  <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="Computer Organization";
  pdata.commentPath="";
  pdata.commentPlaceholder="";

  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
</script>

        </div>
        
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.0" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2017-2020 XXX</a></p>

        </div>
      
    
  </footer>


        <a id="s-top" class="fas fa-arrow-up fa-fw" href="javascript:void(0)"></a>
      </div>
    </div>
    <div>
      <script>
/************这个文件存放不需要重载的全局变量和全局函数*********/
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/******************** Pjax ********************************/
function VPjax(){
	this.list=[] // 存放回调函数
	this.start=()=>{
	  for(var i=0;i<this.list.length;i++){
		this.list[i].run();
	  }
	}
	this.push=(fn,name)=>{
		var f=new PjaxItem(fn,name);
		this.list.push(f);
	}
	// 构造一个可以run的对象
	function PjaxItem(fn,name){
		// 函数名称
		this.name = name || fn.name
		// run方法
		this.run=()=>{
			fn()
		}
	}
}
volantis.pjax={}
volantis.pjax.method={
	complete: new VPjax(),
	error: new VPjax(),
	send: new VPjax()
}
volantis.pjax={
	...volantis.pjax,
	push: volantis.pjax.method.complete.push,
	error: volantis.pjax.method.error.push,
	send: volantis.pjax.method.send.push
}
/********************脚本懒加载函数********************************/
// 已经加入了setTimeout
function loadScript(src, cb) {
	setTimeout(function() {
		var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
		var script = document.createElement('script');
		script.setAttribute('type','text/javascript');
		if (cb) script.onload = cb;
		script.setAttribute('src', src);
		HEAD.appendChild(script);
	});
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
  };
  $(function () {
    SCload_fancybox();
  });
  function Pjax_SCload_fancybox(){
	if (typeof $.fancybox == "undefined") {
	 SCload_fancybox();
    } else {
	 pjax_fancybox();
    }
  }
  volantis.pjax.push(Pjax_SCload_fancybox)
  volantis.pjax.send(()=>{
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
  },'fancybox')
</script>


<!-- internal -->




<script>
  function loadIssuesJS() {
    if ($(".md").find(".issues-api").length == 0) return;
	
	  loadScript('/js/issues.js');
	
  };
  $(function () {
    loadIssuesJS();
  });
  volantis.pjax.push(()=>{
	if (typeof IssuesAPI == "undefined") {
	  loadIssuesJS();
	}
  },"IssuesJS")
</script>



  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: [],
	maxRPS: 5,
	hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>











  
  
<script src="/js/valine.js"></script>


<script>
  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;
    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";
    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }
    var valine = new Valine();
    valine.init(Object.assign({"path":null,"placeholder":"快来评论吧~","appId":"EKmusUsvxKTWym4LJnmkk1eU-gzGzoHsz","appKey":"sdWXsEnYQvIqRVoEPSMsLCr6","meta":["nick","mail","link"],"requiredFields":["nick","mail"],"enableQQ":true,"recordIP":false,"avatar":"robohash","pageSize":10,"lang":"zh-cn","highlight":true,"mathJax":false}, {
      el: '#valine_container',
      path: path,
      placeholder: pagePlaceholder,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps,
    }))
  }
  $(function () {
    pjax_valine();
  });
  volantis.pjax.push(pjax_valine);
</script>






  
<script src="/js/app.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('/js/search/hexo.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>











  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'http://github.com/66ring' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'http://github.com/66ring' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'http://github.com/66ring' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>




  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "user-color-scheme";
const rootElementDarkModeAttributeName = "data-user-color-scheme";

const setLS = (k, v) => {
    localStorage.setItem(k, v);
};

const removeLS = (k) => {
    localStorage.removeItem(k);
};

const getLS = (k) => {
    return localStorage.getItem(k);
};

const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};

const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};

const validColorModeKeys = {
  dark: true,
  light: true,
};

const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);

  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};

const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};

/**
 * get target mode
 */
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);

  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};

/**
 * bind click event for toggle button
 */
function bindToggleButton() {
	var btn=$("#wrapper .toggle-mode-btn");
    btn.on('click',(e) => {
      const mode = toggleCustomDarkMode();
      applyCustomDarkModeSettings(mode);
    });
}

applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", bindToggleButton);
volantis.pjax.push(bindToggleButton);
volantis.pjax.send(()=>{
	$("#wrapper .toggle-mode-btn").unbind('click');
},'toggle-mode-btn-unbind');
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->

 
	   
	    


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#l_cover",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）

      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
		// 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
		volantis.pjax.method.complete.start();
      } catch (e) {
        console.log(e);
      }
    });

    document.addEventListener('pjax:error', function (e) {
	  // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.error.start();
      window.location.href = e.triggerElement.href;
    });
</script>
 
	  
    </div>
  </body>
</html>
