<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Mens et Manus">
<meta property="og:type" content="website">
<meta property="og:title" content="Ring&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ring&#39;s Blog">
<meta property="og:description" content="Mens et Manus">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Travis TuRing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Ring's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ring's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/23/universe/linux/iptables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/universe/linux/iptables/" class="post-title-link" itemprop="url">iptables使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-23 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-23T00:00:00+08:00">2020-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-24 19:17:22" itemprop="dateModified" datetime="2020-11-24T19:17:22+08:00">2020-11-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>对网络上一些数据包通过表的形式进行限定或修改</p>
</blockquote>
<h2 id="三种表"><a href="#三种表" class="headerlink" title="三种表"></a>三种表</h2><ul>
<li><del>Mangle</del><ul>
<li>一般在操作系统级别操作，这里讨论</li>
</ul>
</li>
<li>filter，过滤器<ul>
<li>对进出的数据包进行过滤</li>
</ul>
</li>
<li>nat，网络地址转换<ul>
<li>转换目的地址和目的端口，以及源地址源端口，做数据包转发</li>
<li>如修改进入机器数据包的目的地址，使其转发到其他机器</li>
</ul>
</li>
</ul>
<p>iptables以链的形式组织配置规则, <code>iptables -t &lt;table&gt; -L</code>，就可以列出对应表中的规则</p>
<h3 id="filter表"><a href="#filter表" class="headerlink" title="filter表"></a>filter表</h3><p>查看一下filter表的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t filter -L</span><br><span class="line">Chain INPUT (policy ACCEPT)  # policy 表默认，这里全部接受</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>

<p>INPUT，OUTPUT，FORWARD就是filter表默认的三个链。进入的数据包就通过INPUT这个链来过滤，出去的数据包通过OUTPUT这个链来过滤。而FORWARD是在中间环节(路由)做的过滤，与nat表有关。</p>
<ul>
<li>字段<ul>
<li>target，表示规则类型(即使用的方法ACCEPT，DROP等)</li>
<li>prot，表示协议</li>
<li>opt，一些额外的选项</li>
<li>source，源地址端口</li>
<li>destination，目的地址端口</li>
</ul>
</li>
<li>设置规则<code>iptables [OPTIONS...]</code><ul>
<li><code>-t &lt;table&gt;</code>，设置<code>table</code>表</li>
<li><code>-A &lt;Chain&gt;</code>，将规则append到指定链上，插在末尾</li>
<li><code>-I &lt;Chain&gt; rulenum</code>，将规则insert到指定链上，插在第rulenum条，默认1</li>
<li><code>-D &lt;Chain&gt; rulenum</code>，删除链上第rulenum条规则</li>
<li><code>-j &lt;target&gt;</code>，指定规则的类型，ACCEPT，DROP等</li>
<li><code>-p &lt;protocol&gt;</code>，过滤的协议<ul>
<li><code>--dport &lt;dest_port&gt;</code>，过滤的目的端口</li>
</ul>
</li>
<li><code>-d &lt;dest&gt;</code>，过滤的目的地址</li>
<li>例：<code>iptables -t filter -A INPUT -j DROP -p tcp --dport 8081</code><ul>
<li>如果收到一个包，这个包的目的端口是8081，用的tcp协议，则丢弃</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="nat表"><a href="#nat表" class="headerlink" title="nat表"></a>nat表</h3><p>nat表包含如下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t nat -L</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>

<p>当本机作为中间人做端口转发时，数据包经过如下路径1。如果是通过本机直接发出或接收数据包，即不是做转发，则不会经过<code>PREROUTING</code>和<code>POSTROUTING</code>的完整流程，修改源地址和目的地址需要使用nat表的<code>OUTPUT</code>和<code>INPUT</code>链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. packet in --&gt; PREROUTING(改目的) --&gt; FORWARD --&gt; POSTROUTING(改源) --&gt; packet out</span><br><span class="line">2. packet in --&gt; INPUT --&gt; APP</span><br><span class="line">3. APP --&gt; OUTPUT --&gt; packet out</span><br></pre></td></tr></table></figure>

<p>PREROUTING表示路由之前，用于改目的地址;POSTROUTING表示路由之后，用于改源。</p>
<ul>
<li>设置规则<code>iptables [OPTIONS...]</code><ul>
<li><code>-j DNAT</code>，对目的进行转换<ul>
<li><code>--to &lt;ip:port&gt;</code>，转换到ip</li>
</ul>
</li>
</ul>
<ul>
<li><code>-j SNAT</code>，对源进行转换<ul>
<li><code>--to &lt;ip:port&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>要求: 把192.168.0.12:7788端口的数据包转发到192.168.0.11:7799。如在192.168.0.11:7799开了一个nginx服务，现要在192.168.0.12:7788中访问</p>
<ul>
<li>服务器1<ul>
<li>外网ip：123.121.0.3</li>
<li>内网ip：192.168.0.11</li>
</ul>
</li>
<li>服务器2：<ul>
<li>内网ip：192.168.0.12<ul>
<li>7788端口提供服务</li>
</ul>
</li>
</ul>
</li>
<li><strong>要求</strong>：<ul>
<li>设使用ip为1.2.3.4:5的机器访问</li>
<li><ol>
<li>通过外网访问服务器1的7799端口来获取服务器2中7788端口的服务</li>
</ol>
</li>
<li><ol start="2">
<li>服务器1本地访问192.168.0.11:7799端口来访问服务器2中7788端口的服务</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><em>PS</em>，请求是发送的，别忘了处理响应。</p>
<h4 id="要求1"><a href="#要求1" class="headerlink" title="要求1"></a>要求1</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前机器：服务器1</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -d 123.121.0.3 --dport 7799 -j DNAT --to 192.168.0.12:7788</span><br><span class="line"><span class="comment"># 当请求服务器1 7799端口时，转发到服务器2的7788端口</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp --d 192.168.0.12 7799 -j SNAT --to 192.168.0.11</span><br><span class="line"></span><br><span class="line">iptables -t filter -A FORWARD -j ACCPET</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>时期</th>
<th>操作</th>
<th>源ip:port</th>
<th>目的ip:port</th>
</tr>
</thead>
<tbody><tr>
<td>packet in</td>
<td>访问</td>
<td>1.2.3.4:5</td>
<td>123.121.0.3:7799</td>
</tr>
<tr>
<td>PREROUTING</td>
<td>DNAT</td>
<td>1.2.3.4:5</td>
<td>192.168.0.12:7788</td>
</tr>
<tr>
<td>routing decision</td>
<td>判断是否转发</td>
<td>1.2.3.4:5</td>
<td>192.168.0.12:7788</td>
</tr>
<tr>
<td>POSTROUTING</td>
<td>SNAT</td>
<td>123.121.0.3:X</td>
<td>192.168.0.12:7788</td>
</tr>
<tr>
<td>packet out</td>
<td>转发</td>
<td>123.121.0.3:X</td>
<td>192.168.0.12:7788</td>
</tr>
</tbody></table>
<h4 id="要求2"><a href="#要求2" class="headerlink" title="要求2"></a>要求2</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前机器：服务器1</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -d 192.168.0.11 --dport 7799 -j DNAT --to 192.168.0.12:7788</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -d 123.121.0.3 --dport 7799 -j DNAT --to 192.168.0.12:7788</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当请求服务器1 7799端口时，转发到服务器2的7788端口</span></span><br><span class="line"><span class="comment"># 因为是本地访问，不会经过PREROUTING的过程，因此只能通过OUTPUT链转发</span></span><br><span class="line"></span><br><span class="line">iptables -t filter -A FORWARD -j ACCPET</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>时期</th>
<th>操作</th>
<th>源ip:port</th>
<th>目的ip:port</th>
</tr>
</thead>
<tbody><tr>
<td>packet in</td>
<td>访问</td>
<td>192.168.0.11:X</td>
<td>192.168.0.11:7799</td>
</tr>
<tr>
<td>OUTPUT</td>
<td>DNAT</td>
<td>192.168.0.11:X</td>
<td>192.168.0.12:7788</td>
</tr>
<tr>
<td>packet out</td>
<td>转发</td>
<td>192.168.0.11:X</td>
<td>192.168.0.12:7788</td>
</tr>
</tbody></table>
<h4 id="开启内核转发"><a href="#开启内核转发" class="headerlink" title="开启内核转发"></a>开启内核转发</h4><p>去掉注释<code>/etc/sysctl.conf</code>，使生效<code>sudo sysctl -p</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># net.ipv4.ipv4_forward=1</span></span><br></pre></td></tr></table></figure>

<p>或临时修改</p>
<p><code>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/22/universe/operate/CI_CD_intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/universe/operate/CI_CD_intro/" class="post-title-link" itemprop="url">CI/CD简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-22 00:00:00 / Modified: 11:57:00" itemprop="dateCreated datePublished" datetime="2020-11-22T00:00:00+08:00">2020-11-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是CI-CD"><a href="#什么是CI-CD" class="headerlink" title="什么是CI/CD"></a>什么是CI/CD</h2><p>CI/CD：持续集成和持续交互。代码提交到代码仓库后自动触发一些自动化的流程。CI/CD的工具就是干这用的。</p>
<ul>
<li>什么是DevOps<ul>
<li>DevOps是一种思想方法论，涵盖开发、测试、运维的整个过程。强调通过自动化的方法管理软件变更，软件集成</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plan    --&gt; code    --&gt; build  --&gt; test         Dev</span><br><span class="line">  ^                                 |</span><br><span class="line">  |                                 V</span><br><span class="line">monitor &lt;-- operate &lt;-- deploy &lt;-- release      Ops</span><br></pre></td></tr></table></figure>


<h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><ul>
<li>原理：<ul>
<li>代码提交到远程仓库</li>
<li>如果检查到远程仓库有更新，则拉到本地然后执行构建脚本</li>
</ul>
</li>
<li>在本机运行，所以需要一个自己的机器</li>
</ul>
<h3 id="TravisCI"><a href="#TravisCI" class="headerlink" title="TravisCI"></a>TravisCI</h3><p>TravisCI是github的一个合作伙伴，提供云端机器运行自动化脚本，通过TravisCI官网就能开启github项目的CI服务，之后要在项目中添加<code>.travis.yml</code>文件</p>
<p><em>PS</em> : github自带类似的工具，github action</p>
<p>基本用法：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .travis.yml</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">lang</span>  <span class="comment"># 写执行脚本前要先指定语言</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">some</span> <span class="string">scirpt</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">some</span> <span class="string">scirpt</span></span><br></pre></td></tr></table></figure>


<h3 id="DaoCloud"><a href="#DaoCloud" class="headerlink" title="DaoCloud"></a>DaoCloud</h3><h4 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h4><p>同样是关注远程仓库，然后执行一些自动化的脚本。DaoCloud的云端的基于一个docker镜像的，所以在配置测试环境时可以选择合适的docker镜像。</p>
<h4 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h4><p>在构建完成后会将镜像上传的daocloud的docker镜像仓库，方便以后通过<code>docker pull</code>部署到自己机器。当然可以在集群管理中配置主机，就可将主机绑定到daocloud平台，然后实现自动部署。</p>
<h4 id="发布阶段"><a href="#发布阶段" class="headerlink" title="发布阶段"></a>发布阶段</h4><p>添加部署到主机</p>
<p><em>PS</em> :daocloud还提供了内网穿透，通过合理配置就可通过访问daocloud的域名访问(即只http)部署在内网的应用了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/22/universe/operate/docekr_multi_container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/22/universe/operate/docekr_multi_container/" class="post-title-link" itemprop="url">docker多容器项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-22 00:00:00 / Modified: 15:24:19" itemprop="dateCreated datePublished" datetime="2020-11-22T00:00:00+08:00">2020-11-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="docker容器交互"><a href="#docker容器交互" class="headerlink" title="docker容器交互"></a>docker容器交互</h2><p>docker会通过一块虚拟的docker网卡为容器分配ip地址，即这些容器将在一个网段中，可以直接通过ip进行访问进行交互。但这里存在一个问题，我们需要手动登录一台机器查看ip，然后再另一台机器中访问，这在实际开发中是不可行的。</p>
<p>更方便的交互方式是使用<code>--link &lt;name|id&gt;[:&lt;alias&gt;]</code>，这样就可以通过,如<code>curl &lt;alias&gt;</code>自动解析域名。其本质就是在<code>hosts</code>文件中加入了<code>ip &lt;alias&gt; &lt;id&gt;</code>，把别名了容器id映射到了指定容器的ip。</p>
<p>看如下一个通信模型，只在nginx中暴露80端口，通过link的方式跟php通信，php又通过link的方式根mysql通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nginx   link php expose 80</span><br><span class="line">  |</span><br><span class="line">  V</span><br><span class="line">php     link mysql</span><br><span class="line">  |</span><br><span class="line">  V</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure>

<p><strong>存在的问题</strong> 通过link的通信时，容器的启动顺序很关键(容器都没启动，link到哪？)。所以在以后的重启/部署时指令输起来将比较麻烦</p>
<p>因此，可以将部署的指令记录到一个配置文件中，即使用<code>docker-compose</code></p>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>通过yml配置需要的服务，然后从yml中启动所有服务</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">serv1:</span></span><br><span class="line">        <span class="attr">image:</span></span><br><span class="line">        <span class="attr">links:</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">        <span class="attr">and_some_other_docker_option:</span></span><br><span class="line">    <span class="attr">serv2:</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">.</span>  <span class="comment"># 服务从dockerfile构建</span></span><br><span class="line">        <span class="attr">and_some_other_docker_option:</span></span><br></pre></td></tr></table></figure>

<p><code>docker-compose up</code>启动</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/21/universe/linux/schedule/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/universe/linux/schedule/" class="post-title-link" itemprop="url">linux进程调度机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-21T00:00:00+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-22 16:35:54" itemprop="dateModified" datetime="2020-11-22T16:35:54+08:00">2020-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>看爆！<a href="https://zorrozou.github.io/" target="_blank" rel="noopener">https://zorrozou.github.io/</a></p>
</blockquote>
<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><ul>
<li>进程分类<ul>
<li>实时进程(runtime)<ul>
<li>跟用户交互需要及时相应</li>
</ul>
</li>
<li>普通进行<ul>
<li>不需要那么及时，如编码解码等</li>
</ul>
</li>
<li>对于不同类型的进程应该采用不同的调度方法，实时进程序需要及时响应</li>
</ul>
</li>
<li>上下文切换<ul>
<li>发生进程调度时，保存当前进程的信息后(如程序计数器，变量，寄存器等context)才能加载另一个进程。这个过程就是上下文切换</li>
</ul>
</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul>
<li>FIFO<ul>
<li>实现简单，但需要等待前面进程执行完才能执行后面的。what if前面是一个要执行很长时间的进程</li>
</ul>
</li>
<li>STF(Shortest Time First)<ul>
<li>整体等待时间下降，但如果是长时间进程先到达时短时间进程还是需要等待</li>
</ul>
</li>
</ul>
<p>上面的调度算法都是<strong>非抢占</strong>的，一个执行完成才会执行下一个进程，都会导致个别进程需要长时间等待</p>
<ul>
<li>STCF(Shortest Time-to-Completion First)，短快优先<ul>
<li><strong>会抢占</strong> 。如p1需要100ms，当p1执行了10ms，p2到来只需要10ms，所有会先执行p2，再调度回p1<ul>
<li>抢占：一个进程未必执行完才会执行另一个</li>
</ul>
</li>
<li>但这样会执行时间长的进程可能会由于抢占而饥饿</li>
</ul>
</li>
<li>RR(Round robin)，轮循<ul>
<li>每个进程执行一小段时间片然后切换</li>
</ul>
</li>
</ul>
<h2 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h2><ul>
<li>全局队列<ul>
<li>早期多核cpu下使用全局队列保存进程，因此调度时需要加锁，加锁机制导致这种方式性能很低。</li>
</ul>
</li>
<li>局部队列<ul>
<li>每个cpu有自己的队列，进程在多个队列中负载均衡</li>
</ul>
</li>
</ul>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><ul>
<li>优先级越小优先级越高<ul>
<li>用位图表示有优先级时从低到高找(find first)更快</li>
</ul>
</li>
<li><strong>nice值</strong><ul>
<li>linux中用户可以设置nice值来 <strong>影响优先级</strong> (priority)，范围到<code>[-20, 19]</code><ul>
<li><code>ps -l</code>，PRI字段可看到优先级，NI字段可看到nice值</li>
</ul>
</li>
<li><strong>nice值越高优先级越低</strong><ul>
<li>简记：一个nice的人往往是谦虚礼貌的，吃饭都是说”你先吃你先吃”，结果最后这个nice的人饿着了</li>
<li>一个进程对别的进程越nice就越不会抢占cpu，得到的时间越少，优先级越低</li>
</ul>
</li>
<li>可以通过<code>nice</code>命令设置进程优先级，<code>renice</code>命令来修改nice值</li>
</ul>
</li>
<li>静态优先级<ul>
<li>选择权在用户，用户可以设置nice值来影响优先级</li>
</ul>
</li>
<li>动态优先级<ul>
<li>选择权在内核，内核根据一些机制调整优先级，如超时的进程会受到降低优先级的惩罚</li>
</ul>
</li>
</ul>
<h2 id="linux调度器"><a href="#linux调度器" class="headerlink" title="linux调度器"></a>linux调度器</h2><ul>
<li><del>O(n)调度器</del><ul>
<li>起初采用线性表遍历寻找最高优先级进程O(n)，效率很低</li>
</ul>
</li>
<li>O(1)调度器<ul>
<li>时间片分配，优先级被映射成一定bitmap，在一个优先级上有进程则对应的bitmap会置1，cpu可以通过位运算快速取出优先级最高的进程</li>
</ul>
</li>
<li>CFS完全公平调度器<ul>
<li>分时间片，每个进程相对公平</li>
<li><strong>vruntime</strong>，优先级高的进程虚拟时间增长慢，优先级低的进程虚拟时间增长慢<ul>
<li>如高优先级进程分到时间片10ms，而虚拟时间1ms</li>
</ul>
</li>
<li>取红黑树中虚拟时间最短(优先级最高)的进程进行调度</li>
</ul>
</li>
</ul>
<h3 id="O1调度"><a href="#O1调度" class="headerlink" title="O1调度"></a>O1调度</h3><p>TODO <a href="https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-you-xian-ji.html" target="_blank" rel="noopener">https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-you-xian-ji.html</a></p>
<p>O1调度的Linux2.6开始引入的，到Linux 2.6.23之后替换成了CFS。</p>
<p>使用两个队列，活动队列和过期(expire)队列</p>
<h3 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h3><p>要做到完全公平，调度器要在一个较小的时间内把这n个进程调度执行一遍。这个较小的时间就是任意一个进程被调度的最大延迟时间，也叫做<strong>调度周期<code>sched_latency_ns</code></strong></p>
<p>CPU只要对所有进程维护一个累积占用CPU时间数，就可以衡量出每个进程目前占用的CPU时间总量是多还是少，这个数字记录在 <strong>vruntime</strong> 中。进程以vruntime为key放到一个红黑数组成的队列中，每次调度都选择最左子树上的那个进程，即vruntime最少的进程，这样就能保证所有进程相对公平。</p>
<h4 id="CFS的优先级"><a href="#CFS的优先级" class="headerlink" title="CFS的优先级"></a>CFS的优先级</h4><p>虽说完全公平，但CFS还是需要支持优先级的。优先级是通过时间消耗(vruntime增长)的快慢来决定的。高优先级进程时间增长慢，低优先级进程时间增长快。如低优先级的进程实际运行了1s，vruntime是1s，而高优先级的进程实际已经运行了10s，而vruntime才是1s，这样高优先级的进程就更大概率在最左子树，得到调度。</p>
<p>调度并不在一个进程的vruntime大于最小vruntime的进程时发生，为了减少切换频率，CFS设计了<code>sched_min_granularity_ns</code>参数来设定进程执行之后的最小cpu占用时间。</p>
<h4 id="新进程的vruntime值"><a href="#新进程的vruntime值" class="headerlink" title="新进程的vruntime值"></a>新进程的vruntime值</h4><p>当已经有多个进程执行的很长时间时，新起一个进程，并让它vruntime为0，这显然是不公平的。因为需要分配给它很多时间来追赶其他进程的vruntime。所有CFS对每个CPU的执行队列都维护了一个<code>min_vruntime</code>值，用于记录这个CPU执行队列的最小vruntime值。因此新进程vruntime不是直接设为0，而是以<code>min_vruntime</code>为基础进行调整。</p>
<p>需要考虑的因素很多，如子进程是否要先于父进程执行、还要防止进程不停的fork来获得很多的执行时间</p>
<p>TODO: <a href="https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-you-xian-ji.html" target="_blank" rel="noopener">https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-you-xian-ji.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/21/universe/web/ajax_intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/universe/web/ajax_intro/" class="post-title-link" itemprop="url">JQuery, fetch, axios</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-21 00:00:00 / Modified: 22:23:38" itemprop="dateCreated datePublished" datetime="2020-11-21T00:00:00+08:00">2020-11-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h2><p>Ajax本质就是用来进行异步的请求提交，那是怎么个异步法？</p>
<ul>
<li>同步<ul>
<li>跳转或新开一个页面</li>
</ul>
</li>
<li>异步<ul>
<li>页面局部变动，异步请求然后更新局部页面，而不更新整个页面</li>
</ul>
</li>
</ul>
<p>早期进行异步请求是通过XMLHttpRequest(xhr)，但是这种方法代码非常长，冗余严重。后来JQuery出现<code>$.ajax</code>，对xhr进行封装，又有了后来的fetch和axios。</p>
<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本请求</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    method: <span class="string">""</span>,</span><br><span class="line">    headers: &#123;<span class="string">"key"</span>: <span class="string">"value"</span>&#125;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    url: <span class="string">""</span>,</span><br><span class="line">    success: funciotn()&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可简写方法</span></span><br><span class="line">$.<span class="keyword">get</span>(url, data, callback)</span><br><span class="line">$.post(url, data, callback)</span><br></pre></td></tr></table></figure>

<p><em>PS</em> :默认使用表单形式提交，需要提交json数据数据时，在headers中设置<code>content-type:application/json</code>，然后data中传入<strong>json字符串</strong></p>
<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>现代的浏览器中一般都会自带fetch方法，不需要下载任何js包</p>
<ul>
<li>基本用法：<code>fetch(&quot;usl&quot;, {&lt;args&gt;})</code><ul>
<li>返回一个promise对象</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"url"</span>, &#123;</span><br><span class="line">    method: <span class="string">""</span>,</span><br><span class="line">    headers: &#123;&#125;,</span><br><span class="line">    body: <span class="string">""</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>不单单可以在前端使用，还可以通过nodejs在后端使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">""</span>,</span><br><span class="line">    method: <span class="string">""</span>,</span><br><span class="line">    headers: &#123;&#125;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同fetch一样返回promise对象，可以通过<code>then()</code>进一步处理</p>
<p><em>PS</em> :默认使用json形式提交，需要表单提交数据数据时，在headers中设置form的header，如<code>content-type:application/x-www-form-urlencoded</code>，然后data中传入这种形式(查询字符串)的数据<code>&quot;a=123&amp;b=321&quot;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/15/universe/c/how_cpp_overload/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/15/universe/c/how_cpp_overload/" class="post-title-link" itemprop="url">重载是如何实现的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-15 00:00:00 / Modified: 15:04:40" itemprop="dateCreated datePublished" datetime="2020-11-15T00:00:00+08:00">2020-11-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>overload可直译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时就会根据不同的参数样式，来选择合适的方法执行。</p>
<p>–百度百科</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>重载本质上就是编译器根据原函数名和参数类型对原函数名进行改编，以区分接受不同参数的同名函数。</p>
<p>看下面一段cpp代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func(<span class="number">1</span>);</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规定是不能定义两个同名函数的，但是如果是不同参数的同名函数就可以，这就是重载的作用。</p>
<p>我们通过<code>objdump</code>查看反汇编查看源码来理解其中的原理。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.cpp -o a.o</span><br><span class="line">objump -d a.o</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gcc -c a.cpp -o a.o</code><ul>
<li>这条命令用来汇编生成的目标文件<code>.o</code>结尾</li>
</ul>
</li>
<li><code>objdump -d a.o</code><ul>
<li><code>-d</code>反汇编我们刚才生成目标文件</li>
</ul>
</li>
</ul>
<p>反汇编后将会看到汇编代码，我们抓取我们的重点：接受不同参数的同名函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;_Z4funci&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">   7:   90                      nop</span><br><span class="line">   8:   5d                      pop    %rbp</span><br><span class="line">   9:   c3                      retq</span><br><span class="line"></span><br><span class="line">000000000000000a &lt;_Z4funcii&gt;:</span><br><span class="line">   a:   55                      push   %rbp</span><br><span class="line">   b:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   e:   89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">  11:   89 75 f8                mov    %esi,-0x8(%rbp)</span><br><span class="line">  14:   90                      nop</span><br><span class="line">  15:   5d                      pop    %rbp</span><br><span class="line">  16:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>上面看到我们定义的两个同名函数<code>&lt;_Z4funci&gt;</code>和<code>&lt;_Z4funcii&gt;</code>，仔细一看好似有规律可寻。</p>
<ul>
<li><code>_Z</code>后跟的数字表示函数名的长度和函数名，这里是4对应后面<code>func</code>的长度</li>
<li>在函数名的后面跟的就是参数的类型，这里我们分别是一个整形，和两个整形的函数所以就是<code>i</code>和<code>ii</code></li>
</ul>
<p>所以编译器通过这么一个简单的对函数名的改编(name mangling)就可以做到区分接受不同参数的同名函数的功能。</p>
<p><strong>tips:</strong> 使用<code>c++filt</code>可以查看原函数名。</p>
<p>看这么一个函数<code>void func(s string){}</code>，反汇编后的函数名为<code>&lt;_Z4funcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE&gt;</code>。</p>
<p>使用<code>c++filt</code>查看其原函数名：<code>c++filt _Z4funcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> c++filt _Z4funcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE </span></span><br><span class="line">func(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;)</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/15/universe/linux/cron/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/15/universe/linux/cron/" class="post-title-link" itemprop="url">cron程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-15 00:00:00 / Modified: 20:54:02" itemprop="dateCreated datePublished" datetime="2020-11-15T00:00:00+08:00">2020-11-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h2><p>cron程序有如下五个字段：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分  时  日  月  星期    [年]</span><br><span class="line">* * * * *  &lt;shell script&gt;</span><br></pre></td></tr></table></figure>

<p>语法如下</p>
<ul>
<li><code>*</code>，表示<strong>每一</strong><ul>
<li><code>* 1 * 3 *</code>表示每年三月每天1点的每一分钟执行</li>
</ul>
</li>
<li><code>,</code>，表示并列<ul>
<li><code>1,3</code>表示1和3都执行</li>
</ul>
</li>
<li><code>-</code>，表示连续<ul>
<li><code>1-5</code>表示1-5这个区间执行</li>
</ul>
</li>
<li><code>/</code>，表示整除时执行<ul>
<li><code>*/2</code>表示<code>0 2 4...</code>时执行</li>
<li><code>n/2</code>左边有数字的情况，表示减去该数字后被整除时执行</li>
</ul>
</li>
<li>简写<ul>
<li>为提高可读性，有的cron程序支持简写，如Wed表示星期三，Jul表示七月</li>
<li>W表示工作日</li>
<li>L表示最后一天</li>
</ul>
</li>
<li>每秒<ul>
<li>cron程序的字段中并没有提供秒，但是我们可以通过sleep来进行模拟</li>
<li><code>* * * * * sleep n-1 echo &quot;hello&quot; &gt; &lt;FIlE&gt;</code>，这么的第一个sleep 0秒，第n个sleep n-1秒就可以模拟每秒执行的效果</li>
</ul>
</li>
</ul>
<h2 id="Linux环境使用"><a href="#Linux环境使用" class="headerlink" title="Linux环境使用"></a>Linux环境使用</h2><p>详见帮助文档</p>
<ul>
<li><code>crontab</code><ul>
<li><code>-e</code>，编辑cron程序</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/15/universe/linux/curl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/15/universe/linux/curl/" class="post-title-link" itemprop="url">curl基本使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-15 00:00:00 / Modified: 21:12:24" itemprop="dateCreated datePublished" datetime="2020-11-15T00:00:00+08:00">2020-11-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>等读完curl(如果有时间)，就改成curl all in one</p>
<p>curl是一个http<strong>请求</strong>工具</p>
<ul>
<li><code>curl [options...] &lt;url&gt;</code><ul>
<li><code>queryString</code></li>
<li><code>-s | --silent</code>，不显示进度条</li>
<li><code>-o | --output</code>，指定请求结果输出到的文件</li>
<li><code>-H | --header</code>，设置请求头</li>
<li><code>-d | --data</code>，设置请求携带的数据</li>
<li><code>-X | --request</code>，设置请求使用的方法</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/11/universe/tech_tips/a_basic_middleware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/11/universe/tech_tips/a_basic_middleware/" class="post-title-link" itemprop="url">制作一个简易的中间件架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-11T00:00:00+08:00">2020-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-12 22:25:36" itemprop="dateModified" datetime="2020-11-12T22:25:36+08:00">2020-11-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为何需要中间件"><a href="#为何需要中间件" class="headerlink" title="为何需要中间件"></a>为何需要中间件</h2><p>我们不应该把业务逻辑和非业务逻辑揉在一起。非业务逻辑如打印日志、计时等。因为如果我们需要一个新的日志系统，而我们打印日志的逻辑杂揉在每个handler中，那我们就得修改每个handler，费时费力且不明智。</p>
<p>中间件就是一种剥离非业务逻辑的方法。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们可以使用函数闭包来轻松实现剥离业务逻辑和非业务逻辑。</p>
<p>假设我们的业务就是以各种姿势处理字符串然后打印。如处理成<code>===str===</code>然后打印。</p>
<p>然后现在我们有个业务逻辑之外的要求，那就是打印完成后在结尾打印<code>done</code>。我们可以简单想到下面业务逻辑和非业务逻辑杂糅的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 处理业务逻辑</span></span><br><span class="line">    fmt.Println(<span class="string">"==="</span>+str+<span class="string">"==="</span>)</span><br><span class="line">    <span class="comment">// 处理非业务逻辑</span></span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这个处理的逻辑还是比较简单的。如果我们有100个handler以不同姿势打印字符串，如<code>&quot;str&quot;</code>, <code>~str~</code>等，但是现在我们不说done了，要说ok。那我们就得为100个handler修改非业务逻辑的代码。单单这么一个简单的逻辑修改起来就挺费劲了。</p>
<p>那么我们现在用一种优雅的方式来分离业务逻辑和非业务逻辑， <strong>函数闭包</strong> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandleFunc <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">endPoint</span><span class="params">(h HandleFunc)</span> <span class="title">HandleFunc</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">        h(s)</span><br><span class="line">        fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">business</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"==="</span>+s+<span class="string">"==="</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f := endPoint(business)</span><br><span class="line">    f(<span class="string">"str"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们成功将业务逻辑和非业务逻辑分离，当需要修改非业务逻辑时只需要专注修改非业务逻辑部分(<code>endPoint</code>)，而不需要对每个handler进行修改。</p>
<p>我们的中间件就是通过包装handler(进行些处理)，再返回一个handler，实际上就是不断地进行函数的压栈出栈。</p>
<p><strong>中间件吃什么吐什么</strong>对用户是透明的</p>
<h2 id="优雅的中间件写法"><a href="#优雅的中间件写法" class="headerlink" title="优雅的中间件写法"></a>优雅的中间件写法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandleFunc <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件就是一个吃什么吐什么的函数</span></span><br><span class="line"><span class="keyword">type</span> middleware <span class="function"><span class="keyword">func</span><span class="params">(HandleFunc)</span> <span class="title">HandleFunc</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">	middlewareChain []middleware</span><br><span class="line">	route           <span class="keyword">map</span>[<span class="keyword">string</span>]HandleFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Router&#123;</span><br><span class="line">		route: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]HandleFunc),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Use</span><span class="params">(m middleware)</span></span> &#123;</span><br><span class="line">	r.middlewareChain = <span class="built_in">append</span>(r.middlewareChain, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Add</span><span class="params">(route <span class="keyword">string</span>, h HandleFunc)</span></span> &#123;</span><br><span class="line">    mergedHandler := h</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(r.middlewareChain) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="built_in">len</span>(r.middlewareChain) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">			mergedHandler = r.middlewareChain[i](mergedHandler)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r.route[route] = mergedHandler</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cors</span><span class="params">(h HandleFunc)</span> <span class="title">HandleFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"set cors"</span>)</span><br><span class="line">		h(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logger</span><span class="params">(h HandleFunc)</span> <span class="title">HandleFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"set logger"</span>)</span><br><span class="line">		h(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来我们就可以通过<code>Use</code>来直观地增删中间件，并为对应的route设置handler了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r := New()</span><br><span class="line">r.Use(logger)</span><br><span class="line">r.Use(cors)</span><br><span class="line">r.Add(<span class="string">"route1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;)</span><br><span class="line">r.route[<span class="string">"route1"</span>](<span class="string">"business 1"</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是代码中<code>middlewareChain</code>的遍历顺序和<code>Use</code>的顺序相反，因为调用过程是<code>logger(cors(HanderFunc(s)))</code>，故从内到外包装</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/20/Major/OS/Computer_System_A_Programmer's_Perspective/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/20/Major/OS/Computer_System_A_Programmer's_Perspective/" class="post-title-link" itemprop="url">深入理解计算机系统脑图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-10-20T00:00:00+08:00">2020-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-26 22:56:18" itemprop="dateModified" datetime="2020-10-26T22:56:18+08:00">2020-10-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PART1-计算机系统漫游"><a href="#PART1-计算机系统漫游" class="headerlink" title="PART1: 计算机系统漫游"></a>PART1: 计算机系统漫游</h2><ul>
<li>组成设备</li>
</ul>
<h2 id="PART3-程序的机器级表示"><a href="#PART3-程序的机器级表示" class="headerlink" title="PART3: 程序的机器级表示"></a>PART3: 程序的机器级表示</h2><ul>
<li>一个可执行程序<ul>
<li>编译过程<ul>
<li>预处理</li>
<li>编译</li>
<li>汇编</li>
<li>连接</li>
</ul>
</li>
<li>编译细节<ul>
<li><code>gcc -O[g|1|2] &lt;file&gt;</code>优化等级</li>
<li>编译器优化可能会调整代码次序，源代码会严重变形，导致并发时不满足顺序一致性内存模型</li>
</ul>
</li>
</ul>
</li>
<li>数据格式<ul>
<li>字节，字，双字，四字</li>
<li>数据类型的汇编代码表示<ul>
<li>b, w, l, q </li>
</ul>
</li>
</ul>
</li>
<li>操作数指示符<ul>
<li>操作数可以是立即数值、寄存器值和来自内存的值</li>
<li>立即数的形式<code>$Imm</code></li>
<li>寄存器的形式<code>%r</code></li>
<li>内存寻址的形式<code>Imm(rb, ri, si)</code><ul>
<li>表示<code>M[Imm + R[rb] + R[ri]*si</code>，参数是可以省略的，如<code>(,%rcx,)</code></li>
<li><code>M[]</code>表示取内存值，<code>R[]</code>表示取寄存器值</li>
</ul>
</li>
</ul>
</li>
<li>数据传送指令<ul>
<li><code>mov[数据大小]</code></li>
</ul>
</li>
<li>几类寄存器的格式<ul>
<li><code>r[a|b|c|d]x</code>、<code>eax</code>、<code>ax</code>、<code>al</code></li>
<li><code>r[s|d]i</code>、<code>esi</code>、<code>si</code>、<code>sil</code></li>
<li><code>r[b|s]p</code>、<code>esp</code>、<code>sp</code>、<code>spl</code></li>
<li><code>r[8-9]</code>、<code>r8d</code>、<code>r8w</code>、<code>r8b</code></li>
<li>简记：有r说明4字、e说明双字、l说明字节，剩下的就说明是单字</li>
</ul>
</li>
<li>lea(load effective address)取有效地址<ul>
<li><code>leaq 7(%rdi, %rsi, 4), %rax</code>，则<code>%rad=7+R[%rdi]+R[%rsi]*4</code></li>
<li>处理用在取地址，还可以用在简单的加法和乘法</li>
</ul>
</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">低地址：</span><br><span class="line">    栈顶：%rsp-&gt; |   |</span><br><span class="line">                |   |</span><br><span class="line">                .....</span><br><span class="line">    栈底        |   |</span><br><span class="line">高地址</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pushq S</code>(4字)<ul>
<li><code>R[%rsp] &lt;- R[%rsp]-8</code>，栈顶指针减8<ul>
<li>相当于<code>subq $8, %rsp</code></li>
</ul>
</li>
<li><code>M[R[%rsp]] &lt;- S</code>，入栈<ul>
<li>相当于<code>movq %rbp, (%rsp)</code></li>
</ul>
</li>
<li>区别在于<code>pushq</code>指令编码为1字节</li>
</ul>
</li>
<li>弹出同理<ul>
<li>出栈</li>
<li>指针加</li>
</ul>
</li>
<li>知道了栈内存的分布，则可用内存寻址访问栈<ul>
<li><code>movq 8(%rsp), %rdx</code>，把栈第二个元素存到rdx寄存器中</li>
</ul>
</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>算数运算符<ul>
<li>常见的算数运算符有加减乘除，与或非异或，算数(<code>sa[l|r]</code>)逻辑(<code>sh[l|r]</code>)左右移等<ul>
<li>这些运算符都会改变条件码，以实现条件控制</li>
</ul>
</li>
<li>特殊的算数操作</li>
</ul>
</li>
<li>条件码<ul>
<li>常用条件码有：<ul>
<li>CF：进位标志</li>
<li>ZF：零标志</li>
<li>SF：符号标志</li>
</ul>
</li>
<li>不改变条件码的操作<ul>
<li><code>cmp[b|w|l|q]</code>，与sub相同，只是不改变条件码</li>
<li><code>test[b|w|l|q]</code>，与and相同，只是不改变条件码</li>
</ul>
</li>
<li>访问条件码<ul>
<li>根据条件码设置寄存器01，称为set操作，后缀指明 <strong>考虑的条件码组合</strong> ，如<code>setl R</code>(set less)将D设为<code>SF^OF</code></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Travis TuRing</p>
  <div class="site-description" itemprop="description">Mens et Manus</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Travis TuRing</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
