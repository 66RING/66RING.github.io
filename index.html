<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/10/universe/att_vs_Intel_assembly_language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/universe/att_vs_Intel_assembly_language/" class="post-title-link" itemprop="url">AT&T与Intel汇编语言的比较</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-10 00:00:00 / Modified: 17:09:11" itemprop="dateCreated datePublished" datetime="2020-06-10T00:00:00+08:00">2020-06-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GCC采用的是AT&amp;T的汇编格式，也叫GAS(Gnu Assembler)格式;微软采用Intel的汇编格式</p>
<h2 id="寄存器命名"><a href="#寄存器命名" class="headerlink" title="寄存器命名"></a>寄存器命名</h2><ul>
<li>ATT的汇编格式中，寄存器名前要加上”%”前缀</li>
<li>Inter格式中不用</li>
</ul>
<h2 id="操作数的顺序"><a href="#操作数的顺序" class="headerlink" title="操作数的顺序"></a>操作数的顺序</h2><ul>
<li>ATT目标操作数在源操作数的右边</li>
<li>Intel目标操作数在源操作数的左边</li>
<li>正好相反</li>
</ul>
<table>
<thead>
<tr>
<th>AT&amp;T</th>
<th>Intel</th>
</tr>
</thead>
<tbody><tr>
<td>movl %eax, %abx</td>
<td>mov ebx,eax</td>
</tr>
</tbody></table>
<h2 id="常数-立即数的格式"><a href="#常数-立即数的格式" class="headerlink" title="常数/立即数的格式"></a>常数/立即数的格式</h2><ul>
<li>ATT的汇编格式中，立即数要加上”$”前缀</li>
<li>Inter格式中不用</li>
</ul>
<h2 id="操作符长度标识"><a href="#操作符长度标识" class="headerlink" title="操作符长度标识"></a>操作符长度标识</h2><ul>
<li>ATT汇编格式中操作符的后缀”b”, “w”, “l”分别表示操作数为字节(byte, 8位)、字(word, 16位)、长字(long, 32位)</li>
<li>Intel中操作数长度会根据寄存器长度而定，也可用”byte ptr”、”word ptr”等前缀来表示</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><table>
<thead>
<tr>
<th>AT&amp;T</th>
<th>Intel</th>
</tr>
</thead>
<tbody><tr>
<td>imm32(basepointer,indexpointer,indexscale)</td>
<td>[base+indexpointer*indexscale+imm32]</td>
</tr>
</tbody></table>
<p>两种寻址效果都是：<code>imm32 + basepointer + indexpointer*indexscale</code></p>
<h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><ul>
<li><p>ATT汇编格式中，绝对跳转和调用指令(jump/call)的操作数前要加上”*“作为前缀</p>
<ul>
<li>远程跳转指令和远程子程序调用指令的操作码在ATT中为”ljump”和”lcall”</li>
<li>对应的返回指令为<code>lret</code></li>
</ul>
</li>
<li><p>Intel中不用</p>
<ul>
<li>远程跳转指令和远程子程序调用指令的操作码在Intel中为”jmp far”和”call far”</li>
<li>对应的返回指令为<code>ret</code></li>
</ul>
</li>
<li><p>ATT的汇编格式中，跳转指令有点特殊</p>
<ul>
<li>直接跳转，即跳转目标作为指令的一部分编码，如<code>ljump $a</code></li>
<li>间接跳转，即目标从寄存器或储存器位置中读出的。写法在”*“后面跟一个操作数指示符<ul>
<li><code>ljump *%eax</code>用寄存器%eax中的值作为目标</li>
<li><code>ljump *(%eax)</code>用寄存器%eax中的值作为读入地址，从存储器中读出跳转目标</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/Major/circuit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/Major/circuit/" class="post-title-link" itemprop="url">电路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-07 00:00:00 / Modified: 14:18:25" itemprop="dateCreated datePublished" datetime="2020-06-07T00:00:00+08:00">2020-06-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="半导体的工作原理"><a href="#半导体的工作原理" class="headerlink" title="半导体的工作原理"></a>半导体的工作原理</h2><p>半导体的材料一般是电子不多不少(不易获得也不易失去)的，如:硅(4最外层4电子)</p>
<p>电子多，说明核带正电多，对电子吸引力强; 电子少，说明核带正电少，对电子吸引力弱。</p>
<h3 id="晶体二极管"><a href="#晶体二极管" class="headerlink" title="晶体二极管"></a>晶体二极管</h3><p>纯硅电子不易得也不易失，我们称之为 <strong>本征半导体</strong> 。如果我们在硅中加入一点磷(最外层5电子)，则将不是在最外出4电子的基础上多了一个电子。这时这个电子将相对”自由”。这个整体带的电子比稳定的4电子多，我们就叫它N型半导体(Negetive)。</p>
<p>如果我们在本征半导体参入堋(最外层3个电子)，整体将变得渴望1个电子，我们将这个空的地方(为到达4电子)称为空穴。这些空穴有渴望电子的能力。相对4电子结构，空穴是Positive的，因此称为P型半导体。</p>
<p>采用特殊的技术，把P型半导体和N型半导体(P、N整体都是中性，别被PN误导)拼接在一起。那么由于P型半导体的空穴浓度高，N型半导体的空穴浓度低，空穴就会从P扩散到N;同理N型半导体的电子扩散到P型半导体，就像液体中的扩散一样。但扩散不会一直发生，当N中的空穴变多，变得带正电，P中的电子变多，变得带负电，形成电场。</p>
<p>随着电场的形成，电场将试图将P的电子拉到N，随着P的电子减少，电场减弱，扩散又发生，最后扩散和电场达到动态平衡。</p>
<ul>
<li>如果我们向N区通正电，新增的电场与内部的电场方向一致，电场将会变强。虽然仍会处于动态平衡，但是电场抑制了粒子移动，从而阻断电流。</li>
<li>如果我们向P区通整点，N区通负电，将压缩内电场，电子的束缚将变小从而导通电流</li>
<li>于是晶体二极管就诞生了</li>
</ul>
<h3 id="晶体三极管"><a href="#晶体三极管" class="headerlink" title="晶体三极管"></a>晶体三极管</h3><p>晶体三极管结构如下：</p>
<table>
<thead>
<tr>
<th>外</th>
<th>N</th>
<th>P</th>
<th>N</th>
<th>内</th>
</tr>
</thead>
<tbody><tr>
<td>通电电极</td>
<td>+</td>
<td>+</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>位置</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<p>每个PN接触面会形成PN节，一般0.7V的电压会导通PN节。</p>
<p>如果1号位和2号位电压大于0.7V，就通电了。需要注意的是，设计时，1号位故意参杂很多5电子元素，使得电子浓度很高;而2号位的半导体很薄，很难一次消耗掉这些涌入的电子;当2号涌入了很多电子又无法消耗，那么就打破了2号和3号的动态平衡。而且3号设计得很大电子浓度低，2号扩散过来的电子很快会被3号收集。又因为3号通的正电，电子得到了一个快速的泄洪通道，迅速通过电源正极。</p>
<p>这样一来，我们可以认为2号和3号通电了。又因为2号电子来自1号，所以1号也和3号通电了。</p>
<p>2号极小的信号改变就会导致1号电子涌入的巨大变化，从而引起1号与3号之间电流的巨大变化。</p>
<ul>
<li>1号连接负极，称为发射极</li>
<li>2号相当于阀门，操作这原始信号，称为基极</li>
<li>3号收集电子，称为集电极</li>
</ul>
<h3 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管"></a>场效应管</h3><p>将两个N型半导体浸如一个大的P型半导体中，两个N型半导体分别接入正极和负极，P型半导体接入正极，但与正极间隔这一个电容。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>N</th>
<th>P</th>
<th>N</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>通电电极</td>
<td>P</td>
<td>-</td>
<td>+电容</td>
<td>+</td>
<td>P</td>
</tr>
<tr>
<td>位置</td>
<td>P</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>P</td>
</tr>
<tr>
<td></td>
<td>P</td>
<td>P</td>
<td>P</td>
<td>P</td>
<td>P</td>
</tr>
</tbody></table>
<ul>
<li>1号由电源不断提供电子</li>
<li>2号不断吸引电子，但不会快速消耗电子</li>
<li>3号快速消耗电子</li>
</ul>
<p>由于2号电子处聚集了大量电子，3号消耗了很多电子，于是P型半导体由于电子聚集的位置与3号N型半导体由于电子消耗，半导体的类型发生了改变。即2号与3号之间，2号成了N型，3号成了P型，电子将扩散到3号并被快速消耗。又由于1号源源不断提供电子，不断涌向2号。于是1号和3号在2号的控制下形成了通电回路。</p>
<ul>
<li>1号提供电子，称为源极</li>
<li>2号像栅栏一样控制电路导通，称为栅极<ul>
<li>栅极的正负控制这电路的通阻，如果用01表示同断，那么计算机科学就开始了</li>
</ul>
</li>
<li>3号称为漏极</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/universe/Emacs_in_action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/29/universe/Emacs_in_action/" class="post-title-link" itemprop="url">emacs快速入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-29T00:00:00+08:00">2020-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-30 11:16:55" itemprop="dateModified" datetime="2020-05-30T11:16:55+08:00">2020-05-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Emacs细节"><a href="#Emacs细节" class="headerlink" title="Emacs细节"></a>Emacs细节</h2><ul>
<li>major mode和minor mode<ul>
<li>打开一个文件时会有默认的mode激活，这个默认的mode就是major mode</li>
<li>minor mode在配置文件中，状态栏不会显示，<code>c-h m</code>显示打开的minor mode</li>
</ul>
</li>
<li>org mode标签TODO/DONE<ul>
<li><code>c-t/c-s</code></li>
</ul>
</li>
</ul>
<h2 id="Emacs基本操作"><a href="#Emacs基本操作" class="headerlink" title="Emacs基本操作"></a>Emacs基本操作</h2><ul>
<li><p>M for meta, Alt or Command(MAC)</p>
</li>
<li><p>S for shift</p>
</li>
<li><p>C for control</p>
</li>
<li><p>s for super</p>
</li>
<li><p>Move</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>c-f</td>
<td>forward</td>
</tr>
<tr>
<td>c-b</td>
<td>backward</td>
</tr>
<tr>
<td>c-p</td>
<td>previous</td>
</tr>
<tr>
<td>c-n</td>
<td>next</td>
</tr>
<tr>
<td>c-a</td>
<td>ahead</td>
</tr>
<tr>
<td>c-e</td>
<td>end</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
<li><p>Action</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>c-w</td>
<td>cut</td>
</tr>
<tr>
<td>m-w</td>
<td>copy</td>
</tr>
<tr>
<td>c-y</td>
<td>yank(paste)</td>
</tr>
<tr>
<td>m-&lt;</td>
<td>begin of file</td>
</tr>
<tr>
<td>m-&gt;</td>
<td>end of file</td>
</tr>
<tr>
<td>c-k</td>
<td>del to end of line(kill)</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
<li><p>Edit</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>C-g</td>
<td>中断所有操作</td>
</tr>
<tr>
<td>C-x C-f</td>
<td>打开文件</td>
</tr>
<tr>
<td>C-x C-s</td>
<td>save</td>
</tr>
<tr>
<td>C-h key/var/func</td>
<td>help for key/var/func</td>
</tr>
<tr>
<td>C-x C-e</td>
<td>执行表达式，根据括号范围决定运行的指令</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
<li><p>Search</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>c-s</td>
<td>search below</td>
</tr>
<tr>
<td>c-r</td>
<td>search above</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="Elisp"><a href="#Elisp" class="headerlink" title="Elisp"></a>Elisp</h2><p>括号括起来是表达式，表达式第一个参数是函数，后面是参数。如</p>
<ul>
<li><code>(+ 2 2)</code>，+的函数，结果是2+2</li>
</ul>
<p>括号也起到了代码块的作用</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(setq var [value])</td>
<td>定义变量（赋值）</td>
</tr>
<tr>
<td>(message var)</td>
<td>格式化输出，同C</td>
</tr>
<tr>
<td>(defun func)</td>
<td>定义函数</td>
</tr>
<tr>
<td>(interactive)</td>
<td>声明函数是交互式的函数，<M-x>可以找到这个函数</td>
</tr>
<tr>
<td>(global-set-ket (kbd “<key>“) ‘func)</td>
<td>定义快捷键</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/universe/hacker_in_action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/universe/hacker_in_action/" class="post-title-link" itemprop="url">黑客攻防学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-21T00:00:00+08:00">2020-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-09 19:39:58" itemprop="dateModified" datetime="2020-06-09T19:39:58+08:00">2020-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前置知识：汇编语言</p>
<h1 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h1><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>缓冲区是一片有限的、连续的内存区域。在C语言中最常见的缓冲区是数组。</p>
<p>因为在C和C++语言中没有考虑检查缓冲区的内在边界，所以使栈溢出成为可能。当输入的数据足够大时，将会溢出缓冲区的范围，从而改写从而改写其他缓存区域。</p>
<h3 id="函数与栈"><a href="#函数与栈" class="headerlink" title="函数与栈"></a>函数与栈</h3><p>调用函数的整个过程如下</p>
<ul>
<li><ol>
<li>把函数的参数压入栈</li>
</ol>
</li>
<li><ol start="2">
<li>把函数的返回地址压入栈<ul>
<li>主程序调用子程序，子程序结束后继续上次的位置执行主程序</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>调用函数</li>
</ol>
</li>
</ul>
<p>为了使函数可以引用栈上的数据，必须改变栈底指针EBP的值，把EBP的当前值压入栈，把当前的栈顶ESP复制到EBP，函数接受后再恢复。这样我们就可以方便地引用栈地址了。</p>
<p>接着编译器计算函数的局部变量所需的地址空间和栈上的保留空间，然后从ESP减去变量的大小，为程序保留必要的空间，最后把函数的局部变量压入栈(这我们举例：数组)。结构如下：</p>
<table>
<thead>
<tr>
<th>低内存地址，栈顶</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
</tr>
<tr>
<td>EBP</td>
</tr>
<tr>
<td>RET</td>
</tr>
<tr>
<td>参数</td>
</tr>
<tr>
<td>高内存地址，栈底</td>
</tr>
</tbody></table>
<h3 id="栈上的缓冲区溢出"><a href="#栈上的缓冲区溢出" class="headerlink" title="栈上的缓冲区溢出"></a>栈上的缓冲区溢出</h3><p>由上述结构可见，如果数组很大，将会溢出，然后改写其他缓存区域。</p>
<ul>
<li>控制EIP<ul>
<li>CPU执行什么指令由CS:IP的指向决定</li>
<li>我们只要精心设计溢出的数据，这些地址将写入缓冲器并改写保留在缓冲区的EBP和RET。当系统从栈中取出RET的值并放入EIP时，这个地址指向的指令将被执行。</li>
</ul>
</li>
</ul>
<h3 id="利用漏洞获得root权限"><a href="#利用漏洞获得root权限" class="headerlink" title="利用漏洞获得root权限"></a>利用漏洞获得root权限</h3><p>我们可以攻击以root权限运行的进程，通过溢出强制它执行shell，这个shell将继承root权限。然而缓冲区只认得机器指令(opcode)。为了把opcode插入缓存区，必须吧派生的shell的C代码编译成汇编指令，然后从可读的汇编指令中提取opcode。这些被称为shellcode或opcode的代码可以注入缓冲区，并可执行。</p>
<h4 id="地址问题"><a href="#地址问题" class="headerlink" title="地址问题"></a>地址问题</h4><p>当试图执行用户提交的shellcode时，所面临的问题是找出shellcode的起始地址。(想办法使EIP指向这个地址)</p>
<p>先介绍一种使用最广的方法：猜。每个程序的栈都以同样的地址开始。(现在大多数操作系统故意变化栈地址，从而使这类的攻击变得困难)知道这个地址就可以猜测shellcode的起始地址和RET的地址。</p>
<ul>
<li>首先要知道ESP的地址，那么根据这个地址来猜测当前地址和shellcode之间的偏移距离。从而的到shellcode的起始地址</li>
<li>通过尝试输入过长数据造成溢出，从造成故障的长度来猜测RET地址</li>
<li>最后把RET地址改为shellcode的起始地址以达到执行shellcode的目的</li>
</ul>
<p><strong>例1</strong> ：简单试炼，破解以下程序，假设我们不知道被攻击程序的内部结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// victim.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="built_in">array</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果每个程序的栈都是以同样的地址开始，则固定的程序RET地址不会改变，我们可以通过溢出找出RET地址<ul>
<li><code>$ ./victim.c $(printf &quot;%0524&quot; 0)</code>利用bash快速尝试输入多个0(长数据)</li>
</ul>
</li>
<li>假设我们的shellcode有40B，上一步在524个数据时溢出，那么我们可以将上一步的长数据改成<code>shellcode+(524-len(shellcode))个0+shellcode起始地址</code><ul>
<li>这里还没获得shellcode起始地址，我们先用别的地址测试填充0的个数是否正确</li>
</ul>
</li>
</ul>
<p>building…</p>
<h4 id="NOP法"><a href="#NOP法" class="headerlink" title="NOP法"></a>NOP法</h4><p>一个个猜太过麻烦，可以选用NOP法来增加潜在的偏移量的数量。思路就是创建一大段不运行的指令区，放在shellcode前面，当执行完NOP之后，就会执行shellcode。这样就不用精确地猜到偏移量了。</p>
<h3 id="战胜不可执行栈"><a href="#战胜不可执行栈" class="headerlink" title="战胜不可执行栈"></a>战胜不可执行栈</h3><p>前面所讲的漏洞利用程序能工作，是因为可以在栈上执行指令。许多操作系统不允许在栈上执行代码。当遇到不可执行栈的时候，可以用”返回libc”方法。</p>
<p>栈溢出原理上其实是利用了EIP指针，那么如果我们可以完全EIP指针，那么就可以把任意想执行的代码放入EIP。返回libc是把控制权交给特定的动态库函数。动态库函数不在栈上，所以我们就可以绕开不可执行栈的限制。</p>
<p>为了攻击成功，需要仔细挑选动态库函数。理论上，它必须符合以下两个条件：</p>
<ul>
<li>它必须的常见的动态库函数，在绝大多数程序中出现，才便于利用</li>
<li>函数库里的函数应该给予我们很大的灵活性，以便我们能派生shell或做其他事</li>
</ul>
<p>libc就是满足条件的一个库函数。我们只要把执行流程指向想用的库函数的地址，它将被执行。</p>
<p>以下以派生shell讨论。最好用的libc函数是system()。system()接受一个参数，然后用/bin/sh/执行这个参数。根据经验主程序执行一个函数(设为func)时，参数入栈的顺序和它在代码里的顺序相反，根据这点，我们需要进行以下工作：</p>
<ul>
<li>确定system()地址<ul>
<li>主程序执行一个函数func时，call func，会把返回地址RET压入栈</li>
</ul>
</li>
<li>确定/bin/sh地址(参数地址)<ul>
<li>第一个参数位于RET之后</li>
</ul>
</li>
<li>找出exit()地址，以便干净地退出被攻击的程序</li>
</ul>
<p>用memfetch工具可以找到/bin/sh的地址，memfetch的功能是把指定进程的内存数据全部转存到一个二进制文件中，我们可以在这个文件里找/bin/sh的地址</p>
<p>破解过程如下：</p>
<ul>
<li><ol>
<li>用垃圾数据填满缓冲区和返回地址之间的空间</li>
</ol>
</li>
<li><ol start="2">
<li>用system()的地址改写返回地址</li>
</ol>
</li>
<li><ol start="3">
<li>在system()后加上exit()的地址</li>
</ol>
</li>
<li><ol start="4">
<li>再加上/bin/sh的地址</li>
</ol>
</li>
</ul>
<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>shellcode是一组可注入(机械码)的程序，可以在被攻击的程序里运行。因为shellcode要直接操作寄存器和程序的函数，所以通常用汇编语言编写并翻译为十六进制操作码。之所以叫shellcode是因为通常用这种操作来派生root权限的shell。</p>
<h3 id="理解系统调用"><a href="#理解系统调用" class="headerlink" title="理解系统调用"></a>理解系统调用</h3><p>我们想让目标程序不同于设计者预期的方式运行，而操纵程序的方法之一是强制它产生系统调用(中断)。可以通过系统调用访问特定的操作系统的函数，如接受输入、处理输出、退出进程、执行二进制文件等。</p>
<p>通过系统调用可以直接访问系统内核，即可以访问读写文件之类的低级函数。系统调用也是受保护的内核模式与用户模式之间的接口。受保护的内核模式会阻止用户的应用程序干涉或危及操作系统。当用户模式下的程序企图访问内核的内存空间时，系统将产生异常。但是，某些程序在正常运行时，需要请求一些系统级的服务，这时系统调用就作为正常用户模式和内核模式之间的接口，在保证安全的情况下尽量相应这些请求。</p>
<p>在Linux里有两种方法来执行系统调用：</p>
<ul>
<li>间接方法：C库函数(libc)</li>
<li>直接方法：汇编指令(把适当的参数加载到寄存器，然后调用中断)执行系统调用</li>
</ul>
<p>在Linux里，程序通过<code>int 0x80</code>软中断来执行系统调用。当程序在用户模式下执行<code>int 0x80</code>时，CPU切换到内核模式并执行相应的系统调用。系统调用的过程如下：</p>
<ul>
<li><ol>
<li>把系统调用编号载入EAX，通过载入编号来调用对应系统函数</li>
</ol>
</li>
<li><ol start="2">
<li>把系统调用的参数压入其它寄存器</li>
</ol>
</li>
<li><ol start="3">
<li>执行<code>int 0x80</code>指令</li>
</ol>
</li>
<li><ol start="4">
<li>CPU切换到内核模式</li>
</ol>
</li>
<li><ol start="5">
<li>执行系统函数</li>
</ol>
</li>
</ul>
<p>思考下列程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -static -o exit exit.c</span></span><br></pre></td></tr></table></figure>

<p>反汇编生成的二进制文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gdb exit</span><br><span class="line">(gdb) disas _exit</span><br><span class="line">address &lt;line&gt;: mov 0x4(%esp,1),%ebx</span><br><span class="line">address &lt;line&gt;: mov $Oxfc,%eax          ;对应的系统调用编号被放入%EAX中</span><br><span class="line">address &lt;line&gt;: int $0x80               ;通过int 0x80指令得知发生了系统调用</span><br><span class="line">address &lt;line&gt;: mov $0x1,%eax           ;对应的系统调用编号被放入%EAX中</span><br><span class="line">address &lt;line&gt;: int $0x80</span><br><span class="line">address &lt;line&gt;: hlt</span><br><span class="line">address &lt;line&gt;: nop</span><br></pre></td></tr></table></figure>

<p>exit()对应的系统调用编号是1，exit_group()对应的系统调用编号是252。在反汇编生成的代码里还有一条指令，它把系统调用的参数加载到EBX。这个参数是0，是在系统调用之前入栈的<code>mov 0x4(%esp,1),%ebx</code></p>
<p><code>int 0x80</code>指令把CPU切换到内核模式，并且执行系统调用</p>
<h3 id="为exit-系统调用写shellcode"><a href="#为exit-系统调用写shellcode" class="headerlink" title="为exit()系统调用写shellcode"></a>为exit()系统调用写shellcode</h3><blockquote>
<p>较小的shellcode可以注入更多的缓冲区，可以用来攻击更多的程序，所以要使shellcode尽量保持简单、紧凑。当攻击问题程序的时候，不仅要把shellcode复制到缓冲区，如果碰到n字节长的缓冲区，不仅要把整个shellcode复制到它里面，还要加上调用shellcode的指令，因此shellcode的长度必须小于n。基于这个原因，shellcode应尽量小。</p>
</blockquote>
<p>因为实际环境中，shellcode没有其他指令为它设置参数，所以我们要精心设计。在上面exit()例子里，通过把0放入EBX可以达到设置的目的。所以我们的shellcode应该完成以下任务：</p>
<ul>
<li><ol>
<li>把0存到EBX<ul>
<li>参数</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>把1存到EAX<ul>
<li>系统调用编号</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>执行<code>int 0x80</code>指令来产生系统调用</li>
</ol>
</li>
</ul>
<p>先用汇编指令实现这3步，的到ELF格式的二进制文件，然后从这个二进制文件中提取操作码。</p>
<ul>
<li>生成目标文件</li>
<li>链接目标文件</li>
<li>从生成的文件提取操作码</li>
</ul>
<h3 id="可注入的shellcode"><a href="#可注入的shellcode" class="headerlink" title="可注入的shellcode"></a>可注入的shellcode</h3><p>攻击时，最有可能用来保存shellcode的内存区域是为了保存用户输入而分配的缓冲区，甚至可以更进一步将，这个缓冲区就是一个数组。所以如果shellcode中有空值(0x00)的存在，当把shellcode复制到缓冲区(字符数组)的时候会出现异常，因为数组里空值是用来终止字符串的。所以我们要想办法把空值去掉，或把有空值的操作码转换成非空值的操作码。下面介绍一种方法：</p>
<ul>
<li>直接用其他具有相同功能的指令代替这些产生空值的指令</li>
</ul>
<p>如果直译，shellcode使用如下汇编指令和对应的操作码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,0       ;\xbb\x00\x00\x00\x00</span><br><span class="line">mov eax,1       ;\xb8\x00\x00\x00\x00</span><br><span class="line">int 0x80        ;\xcd\x80</span><br></pre></td></tr></table></figure>

<p>头两条是产生空值的罪魁祸首，我们可以用如下操作解决：</p>
<ul>
<li>第一条指令，我们可以用<code>xor</code>指令在不涉及空值的情况下给ebx赋值<ul>
<li><code>xor ebx ebx</code>，效果：ebx = ebx XOR ebx = 0000</li>
</ul>
</li>
<li>第二条指令汇编指令看似没有0的参与，为什么会出现空值呢？<ul>
<li>因为：这条指令使用了4B寄存器(EAX)，而我们复制了1B(1)到寄存器，默认情况下系统会自动用控制填充剩下部分</li>
<li>4B的EAX可以划分为2个2B(AX)和4个1B(AL、AH)，所以我们直接使用1B的AL就可以避免</li>
<li><code>mov al,1</code></li>
</ul>
</li>
</ul>
<h3 id="派生shell"><a href="#派生shell" class="headerlink" title="派生shell"></a>派生shell</h3><p>首先写派生shell的C程序。派生shell最方便、最快捷的方法是创建新进程。在Linux里有两种方法创建新进程：</p>
<ul>
<li><ol>
<li>通过现有进程创建它，并用它代替现有活动进程</li>
</ol>
</li>
<li><ol start="2">
<li>利用程序生成自己的副本，并在它的位置运行这个进程</li>
</ol>
</li>
</ul>
<p>下面是一个简单C程序的execve调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *cmd[<span class="number">2</span>];</span><br><span class="line">    cmd[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    cmd[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(cmd[<span class="number">0</span>], cmd, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在把它转换成原始十六进制指令，就像exit()一样。想观察execve的文档，提供的信息很有价值：</p>
<ul>
<li><code>int execve(const char* filename, char* const argv[], char* const envp[])</code></li>
<li>execve()执行filename(指针)指向的程序</li>
<li>argv是字符串数组，用来传递参数，envp是字符串数组，用来传递环境变量。argv和envp都以空指针结束</li>
</ul>
<p>执行execve()系统调用4个寄存器：1个用来保存系统调用值;3个用来保存系统调用参数。</p>
<p>在shellcode里不可以使用硬编码地址。我们希望shellcode容易移植，因此我们使用相对地址。下面介绍一种相对地址的实现方法</p>
<p>在shellcode里使用相对地址需要一些技巧。我们可以把shellcode在内存中的开始地址或shellcode的重要元素复制到寄存器，然后根据寄存器里的地址设计每条指令：</p>
<ul>
<li>shellcode以一条跳转指令开始，跳过shellcode，跳到调用指令</li>
<li>执行调用指令时，紧跟在调用指令之后的地址将被压入栈<ul>
<li>这里把想作为相对地址的基地址直接放在了调用指令之后</li>
<li>需要时可以从栈中找到地址</li>
</ul>
</li>
<li>当调用指令后，我们的的基地址将自动保存在栈上，而我们不必提前知道这个地址</li>
<li>之后，调用指令调用shellcode，执行<code>pop esi</code>把栈上的基地址送入ESI。至此就可以根据ESI的偏移量来引用shellcode里面的代码</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    jmp short GoToCall</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop esi     ;把&#39;&#x2F;bin&#x2F;sh&#39;送入esi，使用了相对地址</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">GoToCall:</span><br><span class="line">    call shellcode</span><br><span class="line">    db &#39;&#x2F;bin&#x2F;sh&#39;</span><br></pre></td></tr></table></figure>

<p>下面用真正的汇编指令替代伪代码。在编写过程中，还需要在字符串尾部保留一些占位符(这里是9B)，如下：</p>
<ul>
<li><code>/bin/shJAAAAKKKK</code></li>
</ul>
<p>这些占位符有什么用呢？我们将把系统调用所需的3个参数中的2个(将被载入ECX、EDX)保存在这些占位符里。因为字符串的第一个字节的地址保存在ESI里，所以对于替换和把这些值复制到寄存器来说，很容易就能确定它们所在内存中的位置。另外，可以通过”复制到占位符”方法，用空值有效终止这些字符串。步骤如下：</p>
<ul>
<li><ol>
<li>用xor EAX EAX的结果(空值)填充EAX</li>
</ol>
</li>
<li><ol start="2">
<li>把AL复制到紧挨着/bin/sh的字符位置(J)来终止/bin/sh字符串。<ul>
<li>因为EAX是空值，所以AL也是空值</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>得到保存在ESI里的字符串开头地址，把它复制到EBX</li>
</ol>
</li>
<li><ol start="4">
<li>把EBX里的值(字符串开头的地址)复制到AAAA占位符<ul>
<li>这是execve系统调用要求的、被执行文件的参数指针</li>
</ul>
</li>
</ol>
</li>
<li><ol start="5">
<li>用正确的偏移量吧保存在EAX中的空值复制到KKKK占位符</li>
</ol>
</li>
<li><ol start="6">
<li>把字符串的地址载入EBX</li>
</ol>
</li>
<li><ol start="7">
<li>把保存在AAAA占位符里的地址(一个指向字符串的指针)载入ECX</li>
</ol>
</li>
<li><ol start="8">
<li>把保存在KKKK占位符里的地址(一个指向空值的指针)载入EDX</li>
</ol>
</li>
<li><ol start="9">
<li>执行<code>int 0x80</code></li>
</ol>
</li>
</ul>
<p>得到汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    jmp short GoToCall</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop esi</span><br><span class="line"></span><br><span class="line">    xor eax, eax                ; 1</span><br><span class="line">    </span><br><span class="line">    mov byte [esi+7], al        ; 2</span><br><span class="line"></span><br><span class="line">    lea ebx, [esi]              ; 3</span><br><span class="line">    mov long [esi+8], ebx       ; 4</span><br><span class="line">    mov long [esi+12], eax      ; 5</span><br><span class="line">    mov byte al, 0x0b</span><br><span class="line">    mov ebx, esi</span><br><span class="line">    lea ecx, [esi + 8]</span><br><span class="line">    lea edx, [esi + 12]</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">GoToCall:</span><br><span class="line">    call shellcode</span><br><span class="line">    db &#39;&#x2F;bin&#x2F;shJAAAAKKKK&#39;</span><br></pre></td></tr></table></figure>

<p>编译并反汇编的到操作码</p>
<h2 id="格式化串漏洞"><a href="#格式化串漏洞" class="headerlink" title="格式化串漏洞"></a>格式化串漏洞</h2><p>何为格式化串：</p>
<ul>
<li><code>printf(&quot;%d %x&quot;, a, b);</code></li>
<li>printf是一个参数保存在栈上的函数，即a、b从栈中取出</li>
</ul>
<p>出现格式化串漏洞最常见的原因是，在C语言里没有处理带有可变参数的函数。</p>
<h3 id="什么是格式化串"><a href="#什么是格式化串" class="headerlink" title="什么是格式化串"></a>什么是格式化串</h3><p>当 <strong>printf系列函数</strong> 的格式化串里包含用户提交的数据时(如用户输入)，就可能出现格式化串漏洞。</p>
<p>攻击者可以提交很多格式符(而不给出对应的变量)，这样的话，栈上就没有和格式符相对应的参数，从而导致信息泄漏和执行任意代码。</p>
<p>如果我们不给格式符提供变量，将会出现奇怪的事情。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmt.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用如下形式执行<ul>
<li><code>./fmt &quot;%x %x %x %x&quot;</code></li>
</ul>
</li>
<li>就相当于用如下形式调用printf<ul>
<li><code>printf(&quot;%x %x %x %x&quot;);</code></li>
</ul>
</li>
<li>这个语句会透露出一些重要的信息：我们提供了格式符，但没提供对应的参数。printf也没有报错，而是输出一下内容：<ul>
<li><code>4015c98c 4001526c bffff944 bffff8e8</code></li>
</ul>
</li>
<li>攻击者可以利用它来获取栈上的数据</li>
</ul>
<p>有许多格式符，下面介绍一个：</p>
<ul>
<li>n，这个参数被视为指向整数指针(或整数变量)，在这个参数之前输出的字符的数量被保存到这个参数指针的地址里<ul>
<li><code>./fmt &quot;AAAAAAAAAA%n%n%n%n%n%n%n%n&quot;</code></li>
<li>%n格式符把它的参数作为内存地址，把前面输出的字符的数量写到这个地址</li>
<li>这意味着我们有机会改写某个内存地址的数据，从而控制程序的执行</li>
</ul>
</li>
</ul>
<p>利用%n格式符把控制的数据写入选择的地址。如果满足一下条件，就可以利用格式化串漏洞执行任意代码：</p>
<ul>
<li>我们能够控制参数，并可以把输出的字符的数量写入内存的任意区域</li>
<li>宽度格式符允许我们用任意长度填充输出。如：<code>&quot;%23d&quot;</code>。因此可以用选择的值改写单个字节</li>
<li>通常来说，我们可以猜测函数指针的地址，因此我们可以促成系统把提交的字符串当作代码执行</li>
</ul>
<h3 id="Building"><a href="#Building" class="headerlink" title="Building"></a>Building</h3><h3 id="格式化串技术概述"><a href="#格式化串技术概述" class="headerlink" title="格式化串技术概述"></a>格式化串技术概述</h3><ul>
<li><p>如果格式化串在栈上，当增加字符串的格式符时，可以为格式符提供参数</p>
<ul>
<li>一旦可以指定参数：</li>
<li>可以用%s从目标进程读取内存数据</li>
<li>可以用%n把输出的字符的数量写入任意地址</li>
<li>可以用宽度修饰符修改输出的字符的数量</li>
<li>可以用%hn修饰符每次写入16位数值</li>
</ul>
</li>
<li><p>直接参数访问允许多次重用同一格式化串里的栈参数，也允许直接用这些我们感兴趣的参数。直接参数访问使用$修饰符，如：</p>
<ul>
<li><code>%272$x</code>，将显示栈上第272个参数</li>
</ul>
</li>
<li><p>利用格式化串漏洞、写内存的技术，可以：</p>
<ul>
<li>改写保存的返回地址</li>
<li>改写其他特殊程序的函数指针</li>
<li>改写指向异常处理程序的指针</li>
<li>改写GOT(全局偏移表)条目</li>
<li>等等</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Web篇"><a href="#Web篇" class="headerlink" title="Web篇"></a>Web篇</h1><h2 id="解析应用程序"><a href="#解析应用程序" class="headerlink" title="解析应用程序"></a>解析应用程序</h2><ul>
<li>确定后端使用的技术<ul>
<li><ol>
<li>提取版本HTTP消息头中的版本信息，但后端程序员也可以伪造</li>
</ol>
</li>
<li><ol start="2">
<li>文件扩展名<ul>
<li>许多Web服务器将特殊的文件扩展名映射到特定的服务器组件中，不同组建处理错误的方式不同</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>目录名<ul>
<li>一些子目录名常常表示应用程序使用了相关技术</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>会话令牌<ul>
<li>许多Web服务器和Web应用程序平台默认生成的会话令牌名称会揭示其使用的技术</li>
</ul>
</li>
</ol>
</li>
<li>等等</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/18/universe/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/18/universe/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">算法技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-18 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-18T00:00:00+08:00">2020-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-11 12:01:47" itemprop="dateModified" datetime="2020-06-11T12:01:47+08:00">2020-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>从结束条件开始分析</li>
</ul>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针的选择会出现在很多情况，如：快速排序算法m值的选择、列出排列组合的所有情况。</p>
<ul>
<li>一般先对数组排序，然后从边界开始就能简单的定一议二</li>
</ul>
<h2 id="复杂条件"><a href="#复杂条件" class="headerlink" title="复杂条件"></a>复杂条件</h2><h3 id="问题允许存在变量"><a href="#问题允许存在变量" class="headerlink" title="问题允许存在变量"></a>问题允许存在变量</h3><p>如判断一个字符串是否回文，而且允许删除一个字符。那么对于这个问题的变量就是如果要删除，是删除左边还是右边。但是主要的判断依旧是相同的<code>str[i++]==str[j--]</code>。</p>
<p>所以可以分离主要的判断程序，在主程序中使用<code>||</code>运算符来解决变量引起的讨论。如：<code>return func(删左边)||func(删右边)</code></p>
<h2 id="删除链表上第n个结点"><a href="#删除链表上第n个结点" class="headerlink" title="删除链表上第n个结点"></a>删除链表上第n个结点</h2><ul>
<li>快慢指针，当快指针的next是空的时候，慢指针刚好指到倒数第n个节点</li>
</ul>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>通常，涉及连续子数组问题的时候，我们使用前缀和来解决。</p>
<p>我们令$P[i] = A[0] + A[1] + … + A[i]$。那么每个连续子数组的和sum(i,j)就可以写成$P[j] - P[i-1]（其中 0 &lt; i &lt; j;0 &lt; i &lt; j）$的形式。</p>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>使用哨兵能简化我们的讨论，去掉不必要的分类讨论。如在链表中使用虚拟的头和尾，省去了分类讨论。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li>遍历一个 <strong>完整</strong> 的循环会节省很多讨论，何为完整，类似与判断波的一个完整周期</li>
</ul>
<h2 id="单向栈"><a href="#单向栈" class="headerlink" title="单向栈"></a>单向栈</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/Major/cpp_level_up/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/Major/cpp_level_up/" class="post-title-link" itemprop="url">c++进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-15T00:00:00+08:00">2020-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-11 13:45:31" itemprop="dateModified" datetime="2020-06-11T13:45:31+08:00">2020-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-补完计划"><a href="#C-补完计划" class="headerlink" title="C++补完计划"></a>C++补完计划</h2><h3 id="关键字decltype-c-11"><a href="#关键字decltype-c-11" class="headerlink" title="关键字decltype(c++11)"></a>关键字decltype(c++11)</h3><p>关键字decltype(x)用于自动检测x的类型，并作为关键字。使用方法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">decltype</span>(x) y;   <span class="comment">// 声明y，其中y的类型取决于x</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) xpy;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式如下</span></span><br><span class="line"><span class="keyword">decltype</span>(expression) var;  <span class="comment">// expression可以是函数调用</span></span><br></pre></td></tr></table></figure>


<h4 id="另一种函数声明语法-c-11后置返回类型"><a href="#另一种函数声明语法-c-11后置返回类型" class="headerlink" title="另一种函数声明语法(c++11后置返回类型)"></a>另一种函数声明语法(c++11后置返回类型)</h4><p>考虑下面的情形：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;classs T1, <span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">?<span class="title">type</span>? <span class="title">gf</span>(<span class="title">T1</span> <span class="title">x</span>, <span class="title">T2</span> <span class="title">y</span>)&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line">那函数的返回类型是什么呢？</span><br></pre></td></tr></table></figure>

<p>显然只用decltype是解决不了问题了。使用新增的语法可编写成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;classs T1, <span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">gf</span>(<span class="title">T1</span> <span class="title">x</span>, <span class="title">T2</span> <span class="title">y</span>) -&gt; <span class="title">decltype</span>(<span class="title">x</span>+<span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern<ul>
<li>指出是对外部变量(相对当前代码块的外部)的引用</li>
</ul>
</li>
<li>thread_local(C++11)</li>
<li>mutable<ul>
<li>即使结构变量为const，mutable的成员也是可以被修改的</li>
</ul>
</li>
<li>volatile<ul>
<li>表明，即使程序代码没有对内存单元进行修改，其值也可能发生改变</li>
</ul>
</li>
</ul>
<h3 id="使用new运算符初始化"><a href="#使用new运算符初始化" class="headerlink" title="使用new运算符初始化"></a>使用new运算符初始化</h3><p>如果要为内置的标量类型分配存储空间并初始化，可以在类型名后面加上初始化值，并将其用括号括起：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* pd = <span class="keyword">new</span> <span class="keyword">double</span> (<span class="number">99.99</span>)  <span class="comment">// *pd=99.99</span></span><br></pre></td></tr></table></figure>

<p>要初始化常规结构或数组，需要使用打括号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">where</span>&#123;</span><span class="keyword">double</span> x; <span class="keyword">double</span> y; <span class="keyword">double</span> z;&#125;</span><br><span class="line">where* one = <span class="keyword">new</span> where&#123;<span class="number">2.3</span>, <span class="number">3.2</span>, <span class="number">6.4</span>&#125;</span><br><span class="line"><span class="keyword">int</span>* ar = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ListNode* ls&#x3D;new ListNode(0);</span><br><span class="line">&#x2F;&#x2F; ls-&gt;val&#x3D;0;ls-&gt;next&#x3D;NULL;</span><br></pre></td></tr></table></figure>


<h4 id="定位new运算符"><a href="#定位new运算符" class="headerlink" title="定位new运算符"></a>定位new运算符</h4><p>通常，new负责在堆中找到一个足以满足要求的内存块。new也可以指定要使用的位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p1 = <span class="keyword">new</span> (<span class="built_in">buffer</span>) <span class="keyword">int</span>; <span class="comment">//在buffer中找空间</span></span><br></pre></td></tr></table></figure>


<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>当项目很大的时候可能会发出重名的现象，这时可以使用名称空间进行区分。</p>
<p>C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Jack&#123;</span><br><span class="line">    <span class="keyword">double</span> pail;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fetch</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>using声明将特定的名称添加到它所属的声明区域中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chat fetch;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Jack::fetch</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">double</span> fetch;    <span class="comment">// 失败，因为已经声明了fetch</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; fetch;    <span class="comment">// Jack的fetch</span></span><br><span class="line">    cing &gt;&gt; ::fetch; <span class="comment">// 全局的fetch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>using声明使一个名称可用，而using编译指令使所有的名称都可用。using编译指令使用<code>using namespace</code>关键字。</p>
<p><code>using namespace Jack;</code></p>
<p>可以将名称空间声明进行嵌套</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Bob&#123;</span><br><span class="line">    <span class="keyword">namespace</span> Bill&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在名称空间中使用using编译指令和using声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace myth&#123;</span><br><span class="line">    using Jack::fetch;</span><br><span class="line">    using namespace Bob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>类需要构造函数来创建类对象，不能像下面的那样初始化对象，因为数据部分的访问状态是私有的，这意味着程序不能直接访问数据乘员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person one = &#123;<span class="string">"Bob"</span>, <span class="number">23</span>&#125;;  <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用构造函数的两种方法：</p>
<ul>
<li><code>Person one = Person(&quot;Bob&quot;, 23);</code></li>
<li><code>Person one(&quot;Bob&quot;, 23);</code></li>
</ul>
</li>
<li><p>将构造函数与new一起使用</p>
<ul>
<li><code>Person *one = new Person(&quot;Bob&quot;, 23);</code></li>
</ul>
</li>
<li><p>析构函数</p>
<ul>
<li><code>~Person(){}</code></li>
<li>构造函数创建对象后，程序负责跟踪该对象，直到过期。过期时自动调用析构函数</li>
<li>一般用于删除分配了的资源</li>
</ul>
</li>
<li><p>默认构造函数</p>
<ul>
<li><code>Person(){}</code></li>
</ul>
</li>
<li><p>列表初始化</p>
<ul>
<li>C++11中，可将列表初始化语法用于类中(构造函数)</li>
<li><code>Person one = {&quot;Bob&quot;, 23};</code></li>
<li><code>Person one{&quot;Bob&quot;, 23};</code></li>
<li><code>Person one{};</code> 调用默认构造函数<ul>
<li>不同于<code>Person one()</code>; 这是一个返回Person的函数</li>
</ul>
</li>
</ul>
</li>
<li><p>const成员函数</p>
<ul>
<li><code>const Person one(&quot;Bob&quot;, 23);</code><br><code>one.show()</code>，这样是不行的因为不能保证show方法不会修改对象</li>
<li>除非show方法为：<code>void show() const;</code>，这就是声明const成员函数的方法</li>
<li>因此只要类方法不修改调用对象，就应该将其声明为const</li>
</ul>
</li>
</ul>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h3><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><ul>
<li>格式：<code>operator op(argument-list)</code><ul>
<li>如<code>operator +()、operator *()</code></li>
<li>不能是一个虚构的符号</li>
</ul>
</li>
</ul>
<p>假设有个一个Bob类，并为它定义了一个<code>operator +()</code>成员函数，以重载+运算符。A、B和C都是Bob的对象。便可以编写如下等式：</p>
<ul>
<li><code>C = A + B</code></li>
<li>编译器发现操作数是Bob对象，因此使用相应的运算符函数代替上述运算符<ul>
<li><code>C = A.operator+(B)</code></li>
<li>这说明了运算符的原理</li>
</ul>
</li>
</ul>
<p>重载限制：</p>
<ul>
<li>重载的运算符必须至少有一个操作数是用户自定义的类型，防止用户为标准类型重载运算符</li>
<li>使用运算符不能违反运算符原来的语句规则</li>
<li>不能修改运算符的优先级</li>
<li>不能创造新的运算符</li>
</ul>
<p>在区分++运算符的前缀版本和后缀版本，C++将operator++作为前缀版本，将operator++(int)作为后缀版本;其中的参数永远不会被用到，所以不指定名称</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>C++提供形式的访问权限，：友元。友元有3中：</p>
<ul>
<li>友元函数</li>
<li>友元类</li>
<li>友元成员函数</li>
</ul>
<h4 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h4><p>友元成员函数可以访问类内的私有成员，通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。</p>
<p>考虑下面的情形：设A、B都是Bob类的对象，并且Bob类重载了*运算符。则<code>A = B * 2.5</code>可行，但<code>A = 2.5 * B</code>就会出现问题。原因在于，类内对运算符重载，隐式调用对象<code>A = B.operator*(2.5)</code>，而换位置后<code>2.5</code>对象并没有重载运算符。那难道要重载<code>double</code>类的运算符吗？那将会造成很大混乱。</p>
<p>还有种重载运算符的方法：使用非成员函数。如<code>Time operator*(double m, const Time&amp; t)</code>运算符左边对应第一个参数，右边对应第二个参数。</p>
<p>那如果Time类中有私有数据呢，非成员函数怎么访问？这时就需要友元了。</p>
<ul>
<li>创建友元<ul>
<li>将原型放在类声明中，并加上<code>friend</code>关键字<ul>
<li>该原型意味着下面两点</li>
<li>函数是在类中声明的，但不是类成员函数，因此不能用成员运算符来调用</li>
<li>不是成员函数，但数据的访问权限相同</li>
</ul>
</li>
</ul>
</li>
<li>编写函数定义<ul>
<li>因为不是成员函数，所以不能用<code>Class::</code>限定符，就像声明普通函数一样即可</li>
</ul>
</li>
</ul>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态类成员有一个特点：无论创建多少对象，程序都只创建一个静态类变量副本。即类的所有对象共享同一个静态成员。</p>
<p>不能在类声明中初始化静态成员变量，因为声明描述如何分配内存，但不执行分配。需要在声明之外使用单独的语句进行初始化， <strong>因为静态类是单独储存的，而不是对象的组成部分</strong> 。</p>
<h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><ul>
<li>C++自动提供下面这些成员函数(如果没有定义)<ul>
<li>默认构造函数</li>
<li>默认析构函数</li>
<li>复制构造函数<ul>
<li>它接受一个指向类对象的常量引用作为参数<code>Class_name(const Class_name&amp;);</code></li>
<li>何时调用<ul>
<li>用类对象生成另一个对象<code>Time a(b);</code></li>
<li><code>Time a = b;</code></li>
</ul>
</li>
<li>复制是按值复制的，也就是说a、b是同一个东西，因为传入的是引用。这样释放空间时可能会遇到问题。</li>
</ul>
</li>
<li>赋值运算函数</li>
<li>地址运算函数</li>
</ul>
</li>
</ul>
<h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><p>从一个类派生出另一个类时，原始类成为基类，继承类称为派生类。</p>
<ul>
<li>派生一个类：<code>class Son: public Base</code>，将Son类声明为从Base类派生而来<ul>
<li>冒号指出Son的基类是Base</li>
<li>pulic指出Base是一个公有基类，称为公有派生。<ul>
<li>基类的公有成员将成为派生类的公有成员，基类的私有部分也成为派生类的一部分，但只能通过基类的公有和保护方法访问</li>
<li>派生类不能直接访问基类私有成员，必须通过基类的方法进行访问</li>
</ul>
</li>
<li>private指出Base是一个私有基类<ul>
<li>基类的成员在派生类中中都(公有、保护私有成员)为私有</li>
</ul>
</li>
<li>保护继承<ul>
<li>基类的公有、保护私有成员在派生类中中都为保护成员</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>创建派生对象时，程序先创建基类对象。使用下列语法指定创建基类的构造函数。</p>
<ul>
<li><code>Son::Son(int age, string name, int Sex): Base(int age){}</code> </li>
<li>其中<code>:Base(int age)</code>是成员初始化列表。参数从派生类构造函数传入基类构造函数</li>
<li>也可对派生类的成员使用成员初始化列表语法：<ul>
<li><code>Son::Son(int age, string name, int Sex): Base(int age), age(age){}</code> </li>
<li>相当于<code>Son::Son(int age, string name, int Sex): Base(int age){ this.age = age;}</code></li>
</ul>
</li>
</ul>
</li>
<li><p>派生类和基类之间的特殊关系</p>
<ul>
<li>派生类对象可以使用基类的公有方法</li>
<li>基类指针可以不进行显示类型转换的情况下指向派生类对象<ul>
<li>基类范围更广，派生类可以是基类。但是基类不能是派生类，因为派生类更具体</li>
</ul>
</li>
<li>基类引用可以不进行显示类型转换的情况下引用派生类对象</li>
<li>虽然基类指针或引用只能调用基类方法</li>
</ul>
</li>
<li><p>多态：方法的行为取决于调用该方法的对象</p>
<ul>
<li>两种机制实现多态<ul>
<li>在派生类中重新定义</li>
<li>使用虚方法</li>
</ul>
</li>
<li>其他容易理解，这里特别介绍虚方法，它将决定指针或引用调用那种方法<ul>
<li>如果没有使用虚方法关键字virtual，程序将根据引用类型或指针类型选择方法</li>
<li>如果使用虚方法关键字virtual，程序将根据引用或指针指向的对象的类型选择方法<ul>
<li>即”虚方法将看到指针或引用的本质”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)</p>
<ul>
<li>在编译过程中进行联编被称为静态联编或早联编</li>
<li>在程序运行时进行联编称为动态联编或晚联编(如多态)</li>
</ul>
</li>
<li><p>访问控制：protected</p>
<ul>
<li>protected与private类似，区别之在基类和派生类之间才会表现出来</li>
<li>对外界来说protected成员的行为与private相似;但对于派生类来说protected成员的行为与公有成员相似</li>
</ul>
</li>
<li><p><strong>抽象基类(abstract base class, ABC)</strong></p>
<ul>
<li>将类的共性抽象出来，放到一个ABC类中，然后再用ABC类派生有这些共性的类<ul>
<li>这么做便可以使用基类指针(配合虚函数)数组同时管理多个类的对象了</li>
</ul>
</li>
<li>C++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾处为=0，原型中的=0是虚函数成为纯虚函数：<code>virtual void func(int arg) = 0;</code></li>
<li>当类声明中包含纯虚函数时，不能创建该类的对象，只能作为基类。成为真正的ABC至少包含一个纯虚函数</li>
<li>C++允许在基类中定义(只是不能创建对象)</li>
</ul>
</li>
</ul>
<h2 id="C-中代码重用"><a href="#C-中代码重用" class="headerlink" title="C++中代码重用"></a>C++中代码重用</h2><ul>
<li><p>包含对象成员的类</p>
<ul>
<li>has-a</li>
<li>有一些类为表示类中的组建提供了方便，用这些类作为成员以就不需要重复的定义<ul>
<li>如<code>valarray&lt;T&gt;</code>类，类似<code>vector&lt;T&gt;</code>，但valarray提供的算数支持更多，如max、sum。如果类的成员需要算数数组就可用valarray，而不用重新定义数组和sum、max等类方法，因为valarray对象成员包含了这些方法</li>
</ul>
</li>
</ul>
</li>
<li><p>使用using重新定义访问权限</p>
<ul>
<li>使用保护派生或私有派生时，要让基类的方法在派生类外面可用的一种方法是将函数调用包装在另一个函数调用中，即使用using来指出派生类可以使用特定的基类成员</li>
</ul>
</li>
<li><p>多重继承<code>class Son: public Dad, private Mom{...};</code></p>
<ul>
<li><strong>虚基类</strong>：使得从多个类(它们的基类相同)派生出的对象只继承一个基类对象，而不是重复的两个<ul>
<li><code>class Singer: virtual public Worker{...};</code></li>
<li><code>class Waiter: public virtual Worker{...};</code></li>
<li><code>class SingerWaiter: public Singer, public Waiter{...};</code>，SingerWaiter对象将只包含worker对象的副本，而不是引入各自(Singer、Waiter)的Worker对象副本</li>
</ul>
</li>
</ul>
</li>
<li><p>类也有模板类、同样的类成员、友元也是，定义方法同模板函数</p>
<ul>
<li>有模板类就会有隐式实例化、显式实例化和显式具体化，同模板函数</li>
</ul>
</li>
</ul>
<h2 id="友元、异常和其他"><a href="#友元、异常和其他" class="headerlink" title="友元、异常和其他"></a>友元、异常和其他</h2><h3 id="友元-1"><a href="#友元-1" class="headerlink" title="友元"></a>友元</h3><p>友元一般用于类的扩展接口中，类并非只能拥有友元函数，也可以将类作为友元。</p>
<h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>如电视机和遥控器，它们两并不是is-a或has-a的关系，但是遥控器能够改变电视机的状态，这表明应将遥控作为电视机的一个友元类。电视机的面板也提供了换台、修改音量等功能。遥控器的功能和电视机内置的功能相同，但是遥控器可以任意的选择频道以及其他许多功能。使遥控成为电视的友元类，这样遥控就能访问电视的私有数据了。</p>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>C++中可以将类声明放在另一个类中。在另一个类中声明的类称为嵌套类，它通过提供新的类型类作用域来避免名称混乱。包含类的成员函数可以使用和创建被嵌套类的对象;而仅当声明位于公有部分，才能在包含类的外部使用嵌套类，而且必须使用作用域解析运算符(class::class::func)</p>
<p>对类进行嵌套通常是为了帮助实现另一个类，避免名称冲突。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>try{}<ul>
<li>花括号表明要注意这些代码引发的异常</li>
</ul>
</li>
<li>throw Object<ul>
<li>抛出异常，回到try的位置，并跳过try。通常抛出类类型，类似返回语句return</li>
<li>类似return是原理，使用栈解退来跳转到try</li>
</ul>
</li>
<li>catch(Type){}<ul>
<li>catch关键字表示异常捕获，括号中指出捕获的类型，并接受异常抛出的对象，花括号指出采取的措施</li>
</ul>
</li>
<li>exception类<ul>
<li>exception类位于exception头文件中，可以把它用作其他异常的基类</li>
</ul>
</li>
</ul>
<h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3><p>RTTI是运行阶段类型识别(Runtime Type Identification)的简称。</p>
<ul>
<li>C++有3个支持的RTTI元素<ul>
<li>dynamic_cast：如果可能的话，将使用一个指向基类的指针来生成一个指向派生类的指针;否则返回空指针</li>
<li>typeid：返回一个指出对象的类型的值</li>
<li>type_info：存储了有关特定类型的信息</li>
</ul>
</li>
<li>只能将RTTI用于包含虚函数的类层次结构，原因在与只有对于这种层次结构，才应该将派生类对象的地址赋给基类指针<ul>
<li>因为如果使用虚方法关键字virtual，程序将根据引用或指针指向的对象的类型选择方法，就算使用基类指针接收，也会选择引用或指针指向的对象方法</li>
</ul>
</li>
</ul>
<ul>
<li>dynamic_cast:<ul>
<li><code>dynamic_cast&lt;Type *&gt;(ps)</code>，ps指向一个对象</li>
<li>如果ps的类型可以安全的转换为<code>Type*</code>，运算符返回对象的地址;否则返回空指针</li>
<li>因此可以安全地<code>Base* pb = dynamic_cast&lt;Base *&gt;(ps)</code></li>
</ul>
</li>
<li>typeid和type_info<ul>
<li><code>typeid</code>运算符接收类名或者一个对象，返回一个对type_info的的引用</li>
<li>type_info是在头文件typeinfo中定义的一个类。type_info重载了==和!=运算符，以便可以对类进行对比<ul>
<li><code>typeid(Base) == typeid(*pg)</code>如果pg是空指针将发生异常，异常类型是exception类派生来的</li>
<li>type_info的实现随厂商而异，但包含一个<code>name()</code>成员，该函数返回一个随实现而异的字符串，通常是类的名称</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="string类输入"><a href="#string类输入" class="headerlink" title="string类输入"></a>string类输入</h4><ul>
<li>对于类，有3中输入方式。<code>char str[100]</code><ul>
<li><code>cin &gt;&gt; str</code>，读一个词</li>
<li><code>cin.getline(str, 100);</code>，读一行，去掉<code>\n</code>，有一个可选参数用来指定使用哪个字符来确定输入边界</li>
<li><code>cin.get(info, 100)</code>，读一行，保留<code>\n</code></li>
</ul>
</li>
<li>对于string对象，有两种方式<ul>
<li><code>cin &gt;&gt; str</code>，读一个词</li>
<li><code>getline(cin, stuff)</code>，读一行，去掉<code>\n</code>，有一个可选参数用来指定使用哪个字符来确定输入边界</li>
</ul>
</li>
</ul>
<h3 id="智能指针模板类"><a href="#智能指针模板类" class="headerlink" title="智能指针模板类"></a>智能指针模板类</h3><p>智能指针是行为类似指针的 <strong>类对象</strong> ，这种对象还有其他功能。看下面代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>* ps = <span class="keyword">new</span> <span class="built_in">string</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(hasException)&#123;</span><br><span class="line">        <span class="keyword">throw</span> exception();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    str = ps;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到这段代码分配了堆中的内存，但是没有释放，从而导致内存泄漏。</p>
<ul>
<li>那在结尾加delete不就行了？<ul>
<li>这是中可能忘记的解决方案，存在隐患</li>
</ul>
</li>
<li>就算加了delete如果出现异常，delete将不被执行，也导致内存泄漏</li>
<li>因此如果它是一个对象，那在它过期的时候析构函数删除指向的内存就好了。由此得到了使用智能指针的解决方案</li>
</ul>
<h4 id="智能指针的使用"><a href="#智能指针的使用" class="headerlink" title="智能指针的使用"></a>智能指针的使用</h4><p><code>auto_ptr</code>,<code>unique_ptr</code>和<code>shared_ptr</code>都定义了类似指针的对象，可以将new获得(直接或间接)的地址赋给这种对象。当智能指针过期时，其析构函数将使用delete来释放内存。要创建智能指针对象，必须引入头文件memory。</p>
<ul>
<li>语法：<code>auto_ptr&lt;Type&gt; pointer(new Type)</code>(其他两种相同)</li>
<li>所有智能指针类都有一个explicit构造函数，该构造函数将指针作为参数。因此不需要自动将指针转换为智能指针对象</li>
</ul>
<h4 id="智能指针的注意事项"><a href="#智能指针的注意事项" class="headerlink" title="智能指针的注意事项"></a>智能指针的注意事项</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>))</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; pd;</span><br><span class="line">pd = ps;</span><br></pre></td></tr></table></figure>

<p>如果ps和pd是常规指针，那这两个指针指向同一个string对象。这是不能接受的，因为程序将试图将同一个对象删除两次：ps过期时删除，pd过期时删除。要避免这个问题有如下方法：</p>
<ul>
<li>定义赋值运算符<ul>
<li>使之执行深复制。这样两个指针指向不同的对象</li>
</ul>
</li>
<li>建立所有权(ownership)概念<ul>
<li>对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的指针能够删除该对象</li>
<li><strong>auto_ptr和unique_ptr就是使用这种策略</strong> ，但是<code>unique_ptr</code>的策略更加严格</li>
<li>当所有权转移，将不能通过原来的指针进行访问<ul>
<li><code>auto_ptr</code>编译时不会检测所有权是否转移</li>
<li>使用<code>unique_ptr</code>，将在编译阶段检测到所有权转移错误，因此<code>unique_ptr</code>比较安全</li>
</ul>
</li>
</ul>
</li>
<li>创建只能更高的指针，跟踪引用特定对象的智能指针<ul>
<li>如，赋值时计数加1，过期时计数减1.当最后一个指针过期(计数减为0)时才调用delete，这是share_ptr采用的策略</li>
</ul>
</li>
</ul>
<h3 id="标准模板库-Standard-Template-Library"><a href="#标准模板库-Standard-Template-Library" class="headerlink" title="标准模板库(Standard Template Library)"></a>标准模板库(Standard Template Library)</h3><p>STL容器是同质的，即存储的值的类型相同。</p>
<h4 id="模板类vector"><a href="#模板类vector" class="headerlink" title="模板类vector"></a>模板类vector</h4><p>vector类提供了与前面将的valarray和Array类似的操作，即可以创造vector对象，将一个vector对象赋值给另一个vector对象，可以随机访问。</p>
<h4 id="可对vector执行的操作"><a href="#可对vector执行的操作" class="headerlink" title="可对vector执行的操作"></a>可对vector执行的操作</h4><p>所有STL容器都提供了一些基本方法，如：<code>size(), swap(), begin()</code>等。其中<code>begin(), end()</code>返回第一个元素的迭代器和返回超过容量尾的迭代器。</p>
<p>迭代器是一个广义的指针。事实上它可以是指针，也可以是一个可对其执行类似指针操作(如解除引用<code>operator*()</code>和递增<code>operator++()</code>)的对象。通过将指针广义化为迭代器，让STL能够为各种不同的容器类提供统一的接口。每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为<code>iterator</code>的typedef，其作用域是整个类。如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个迭代器变量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores;</span><br><span class="line">pd = scores.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="comment">//或者auto pd = scores.begin();</span></span><br><span class="line"></span><br><span class="line">*pd = <span class="number">2</span>;</span><br><span class="line">++pd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如上，迭代器的行为就像指针</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>erase(iterator1, iterator2)</code>方法删除矢量中给定区间[iterator1, iterator2)的元素<ul>
<li>它接受两个迭代器参数</li>
</ul>
</li>
<li><code>insert()</code>与erase相反<ul>
<li>它接受三个迭代器参数</li>
<li>第一个参数指定了新元素的插入位置，第二个和第三个迭代器定义了被插入区间，该区间通常来自另一个容器对象</li>
<li>拥有超尾元素使得在尾部附加元素非常简单</li>
</ul>
</li>
</ul>
<h4 id="对vector可执行的其他操作"><a href="#对vector可执行的其他操作" class="headerlink" title="对vector可执行的其他操作"></a>对vector可执行的其他操作</h4><p>STL从更广泛的角度定义了非成员函数来执行这些操作，即不是为每个容器类定义find()成员函数，而是定义了一个适用于所有容器类的非成员函数。这种设计省去了大量重复的工作。</p>
<p>下面是3个代表性的STL函数：</p>
<ul>
<li><code>for_each()</code><ul>
<li>接受3个参数，前两个是定义容器区间的迭代器，最后一个是指向函数的指针，被指向的函数应用于区间内的每个元素。被指向的函数不能修改容器元素的值</li>
</ul>
</li>
<li><code>random_shuffle()</code><ul>
<li>接受两个指定区间的迭代器参数，并随机排序该区间中的元素</li>
<li>该函数要求容器类支持随机访问</li>
</ul>
</li>
<li><code>sort()</code><ul>
<li>有两个格式：<ul>
<li>第一个版本接受两个定义区间的迭代器参数，并使用储存在容器中的类型元素定义的&lt;运算符，对区间中的元素进行操作，如果元素是用户定义的对象，要使用sort必须定义能够处理该类型的opertator&lt;()函数</li>
<li>另一种格式的sort接受3个参数，前两个是指定区间的迭代器，最后一个是要使用的函数，而不是用opertator&lt;()。返回值可转换为bool，false表示两个参数的顺序不正确</li>
</ul>
</li>
<li>该函数要求容器类支持随机访问</li>
</ul>
</li>
</ul>
<h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><p>STL是一种泛型编程，泛型编程关注的是算法。如模板能够按泛型定义函数或类，高效地代码复用。</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>模板使得算法独立于储存的数据类型，而迭代器使算法独立于使用的容器类型。如果泛型编程想要使用同一个find函数处理数组、链表或其他容器类型那么就需要一个东西来对容器中的值进行通用表示，迭代器正是这样的通用表示。</p>
<p>每个容器类(vector、list等)定义了相应的迭代器类型。</p>
<ul>
<li>每个容器都有<code>begin()</code>和<code>end()</code>方法，分别返回第一个容器和超尾位置的迭代器</li>
<li>每个容器都实现了*和++等方法，从而可以对迭代器进行操作</li>
</ul>
<h4 id="迭代器的类型"><a href="#迭代器的类型" class="headerlink" title="迭代器的类型"></a>迭代器的类型</h4><ul>
<li>输入迭代器<ul>
<li>这里的”输入”是从程序的角度来说的，即容器的信息被视为输入</li>
<li>输入迭代器可以被程序用来读取容器的信息，但不能修改容器的值</li>
<li>支持++运算符来访问所有元素</li>
<li>输入迭代器是单向的、可递增的、不能倒退的</li>
</ul>
</li>
<li>输出迭代器<ul>
<li>这里的”输出”指用于信息从程序传输到容器</li>
<li>输出迭代器是单通行的、只写的</li>
</ul>
</li>
<li>正向迭代器<ul>
<li>只能使用++运算符遍历容器</li>
<li>总是按一定的顺序</li>
<li>递增后仍可以对前面的迭代器解除引用，并可的到相同的值</li>
<li>可读可写也可只读<code>int *p; const int* p</code></li>
</ul>
</li>
<li>双向迭代器<ul>
<li>具有正向迭代器的所有特性，同时支持两种增减运算符</li>
</ul>
</li>
<li>随机访问迭代器<ul>
<li>具有双向迭代器的所以特性，同时支持随机访问</li>
</ul>
</li>
</ul>
<h2 id="输入输出和文件"><a href="#输入输出和文件" class="headerlink" title="输入输出和文件"></a>输入输出和文件</h2><h3 id="流和缓冲区"><a href="#流和缓冲区" class="headerlink" title="流和缓冲区"></a>流和缓冲区</h3><p>输入流需要两个连接，每端各一个。文件端(文件端可以是文件也可以是设备)连接提供流的来源，程序端连接将流的流出部分转储到程序中。同样，输出的管理包括将输出流连接到程序以及将输出目标与流关联。</p>
<p>缓冲区是用作中介的内存块，它是将信息从设备传输到程序或从程序传输给设备的临时储存工具。使用缓冲区可以高效地处理输入和输出。缓冲区帮助匹配两种不同的信息传输速率。C++程序通常在用户按下回车键时刷新入缓冲区，对键盘输入进行缓冲可以让用户将输入传输给程序之前返回并更正。</p>
<h3 id="流、缓冲区和iostream文件"><a href="#流、缓冲区和iostream文件" class="headerlink" title="流、缓冲区和iostream文件"></a>流、缓冲区和iostream文件</h3><p>iostream文件中包含一些专门设计来实现、管理流和缓冲区的类。</p>
<ul>
<li>stream类<ul>
<li>为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法</li>
</ul>
</li>
<li>ios_base类<ul>
<li>表示流的一般特征，如是否可读取、是二进制流还是文本流等</li>
<li>ios类基于ios_base，其中包括了一个指向streambuf对象的指针成员</li>
</ul>
</li>
<li>ostream类<ul>
<li>从ios类派生而来的，提供了输出方法</li>
</ul>
</li>
<li>istream类<ul>
<li>从ios类派生而来，提供了输入方法</li>
</ul>
</li>
<li>这些工具必须使用适当的类对象，如ostream对象cout。创建这样的对象将打开一个流，自动创建缓冲区，并将其与流关联起来。</li>
</ul>
<p>iostream库管理了很多细节。如在程序中包含iostream文件将自动创建8个流对象(4个用于窄字符流、4个用于宽字符流)</p>
<ul>
<li>cin<ul>
<li>标准输入流，默认情况下这个流被关联到标准输入设备</li>
<li>wcin对象与此类似，但处理的是wchar_t类型</li>
</ul>
</li>
<li>cout<ul>
<li>标准输出流，默认情况下这个流被关联到标准输出设备</li>
<li>wout对象与此类似，但处理的是wchar_t类型</li>
</ul>
</li>
<li>cerr<ul>
<li>标准错误流，可用于显示错误消息，默认情况下这个流被关联到标准输出设备</li>
<li>这个流没有缓冲，直接被发送到屏幕</li>
<li>werr对象与此类似，但处理的是wchar_t类型</li>
</ul>
</li>
<li>clog<ul>
<li>也是标准错误流，可用于显示错误消息，默认情况下这个流被关联到标准输出设备</li>
<li>wlog对象与此类似，但处理的是wchar_t类型</li>
</ul>
</li>
<li>对象代表流意味着什么？<ul>
<li>当iostream文件为程序声明一个cout对象时，该对象将包含储存了与输出有关的信息和数据成员，如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数方法以及描述用来处理输出流缓冲区的streambuf对象的地址</li>
<li><code>cout &lt;&lt; &quot;hello&quot;;</code>这个语句通过将指向的streambuf对象将字符串”hello”中的字符放到cout管理的缓冲区中</li>
</ul>
</li>
</ul>
<ul>
<li>重定向<ul>
<li>标准输入和输出流通常连接着键盘和屏幕，重定向使得能够改变标准输入和标准输出。</li>
</ul>
</li>
</ul>
<h3 id="使用cout进行输出"><a href="#使用cout进行输出" class="headerlink" title="使用cout进行输出"></a>使用cout进行输出</h3><p>C++将输出看做字节流，但在程序中，很多数据被组织成比字节流更大的单位，如，int类型可能有16位或32位的二进制值表示。但在将字节流发送给屏幕时，希望每个字节表示一个字符，如int类型的12可能是32位表示的，但在屏幕上要求3用一个字节表示，2用一个字节表示。</p>
<p>因此ostream类最重要的任务之一是将数值类型转换为文本形式表示的字符流。</p>
<ul>
<li>重载的&lt;&lt;运算符<ul>
<li>C/C++中<code>&lt;&lt;</code>运算符默认含义是按位左移，但ostream类重载了<code>&lt;&lt;</code>运算符，将其重载为输出。<code>&lt;&lt;</code>运算符被重载使之能识别C++中所有的基本类型。</li>
</ul>
</li>
<li>其他ostream方法<ul>
<li><code>put()</code>方法原型：<code>ostream&amp; put(char)</code><ul>
<li><code>cout.put(&#39;W&#39;);</code>，cout是调用方法的对象，put是类成员函数</li>
<li>返回一个指向调用对象的引用，因此可以用它将拼接输出</li>
</ul>
</li>
<li><code>write()</code>原型：<code>basic_ostream&lt;charT,traits&gt;&amp; write(const char_type* s, streamsize n);</code><ul>
<li>write方法显示整个字符串</li>
<li>第一个参数提供了要显示的字符串的地址，第二个参数指出要显示多少个字符</li>
<li>write方法不会在遇到空字符时停止打印，而是打印指定数目的字符，即使超出了字符串的边界！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="刷新缓冲区"><a href="#刷新缓冲区" class="headerlink" title="刷新缓冲区"></a>刷新缓冲区</h3><p>ostream类对cout对象处理的输出进行缓冲，所以输出不会立即发送到目标地址，而是被储存在缓冲区中，直至缓冲区填满。然后刷新(flush)缓冲区，把内容发送出去，并清空缓冲区。</p>
<ul>
<li>在屏幕输出时，程序不必等到缓冲区填满。如<ul>
<li>将换行号发送到缓冲区后将刷新缓冲区。</li>
<li>多数C++实现都会在输入即将发生时刷新缓冲区，即使没有换行符</li>
</ul>
</li>
<li>如果实现不能在所希望时刷新输出，可以使用两个控制符中的一个来强制进行刷新<ul>
<li>控制符flush刷新缓冲区：<code>cout &lt;&lt; &quot;hello&quot; &lt;&lt; flush;</code></li>
<li>控制符endl刷新缓冲区，并插入一个换行符：<code>cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;</code></li>
<li>实际上控制符也是函数，可以直接调用<code>flush(cout);</code>，ostream重载了<code>&lt;&lt;</code>，使得<code>cout &lt;&lt; flush;</code>可行。</li>
</ul>
</li>
</ul>
<h3 id="用cout进行格式化"><a href="#用cout进行格式化" class="headerlink" title="用cout进行格式化"></a>用cout进行格式化</h3><p>ostream类是从ios类派生而来的，而ios类从ios_base类派生而来。ios_base类存储了描述格式状态的信息。通过使用ios_base的成员函数，可以控制字段宽度和小数位数。由于ios_base类是ostream的间接基类，因此可将其方法用于ostream对象，如cout。</p>
<ul>
<li>调整进制，<strong>设置持续到将格式状态设置为其他选项为止</strong>，控制符不是成员函数，但也可<code>cout &lt;&lt; hex;</code>调用<ul>
<li><code>hex()</code>，设置后程序以十六进制形式打印整数值</li>
<li><code>oct()</code>，设置后程序以八进制形式打印整数值</li>
</ul>
</li>
<li>调整字段宽度<ul>
<li><code>width</code> <strong>成员函数</strong> 将长度不同的数字放到宽度相同的字段中<ul>
<li><code>width()</code>方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值<ul>
<li><code>cout.width(12);cout&lt;&lt;12&lt;&lt;&quot;#&quot;;</code>只有12被放宽到12个字符，并右对齐，后面的将不受影响</li>
</ul>
</li>
<li><code>int width()</code>，返回宽度当前值</li>
<li><code>int width(int i)</code>，将字段宽度设置为i个，并返回以前的字段宽度值</li>
<li>如果试图在宽度为2的字段中显示一个7位值，C++将增宽字段，以容纳该数据</li>
</ul>
</li>
</ul>
</li>
<li>填充字符，默认情况下cout使用空格填充字段中未被使用的部分<ul>
<li><code>fill()</code> <strong>成员函数</strong> 来改变填充的字符，如<code>cout.fill(&#39;*&#39;)</code>。新的填充字符将一直有效直到设置新的填充字符</li>
</ul>
</li>
<li>设置浮点数的显示精度有效位数<ul>
<li><code>precision()</code> <strong>成员函数</strong> 改变精度。如<code>cout.precision(2);</code>。精度设置一直有效直到被重新设置</li>
</ul>
</li>
<li>打印末尾的0和小数点<ul>
<li>iostream没有提供专门用于这项功能的函数，但ios_base类提供了一个<code>serf()</code>函数，能够控制多种格式化特性。这个类还定义了多个常量，可以用作改函数的参数</li>
<li>cout显示末尾小数点<code>cout.setf(ios_base::showpoint);</code><ul>
<li>这会显示小数后的0,如精度为6时2会显示为2.00000</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>setf()</code>除了可以控制小数点的显示还有几个格式选项。ios_base类有一个受保护的数据成员，其中的各位(这里称之为标记)分别控制着格式化的各个方面。打开一个标记称为设置标记(或位)，并意味着相应的位被设置为1.</p>
<p>hex、dec、oct等控制符实际上就是通过控制技术系统的3个标记位实现的。<code>setf()</code>函数提供了另一种调整标记位的途径。<code>setf()</code>函数有两个原型</p>
<ul>
<li><code>fmtflags setf(fmtflags);</code>，其中哦fmtflags是bitmask类型的别名(typedef)，用于储存格式标记。<ul>
<li>这个版本的setf用来设置单个控制位的格式信息，参数fmtflags是一个值，指出要设置哪一位。返回值是类型为fmtflags的数字，指出标记以前的设置</li>
<li>ios_base类定义了代表位值的常量：<ul>
<li><code>ios\_base::boolalpha</code>，输入和输出的bool值，可以为true或false</li>
<li><code>ios\_base::showbase</code>，对于输出，使用C++基数前缀(0, 0x等)</li>
<li><code>ios\_base::showpoint</code>，显示末尾的小数点</li>
<li><code>ios\_base::uppercase</code>，对于十六进制输出，使用大写字母，E表示法</li>
<li><code>ios\_base::showpos</code>，在正数前面加上+。十进制才有效，因为十六进制八进制都被视为无符号</li>
</ul>
</li>
<li>修改将一直有效直到被覆盖为止</li>
</ul>
</li>
<li><code>fmtflags setf(fmtflags, fmtflags);</code><ul>
<li>函数的这种格式用于设置有多位控制的格式选项</li>
<li>第一个参数包含了所需设置的fmtflags值，第二个参数指出要清理第一个参数中的哪些位<ul>
<li>如，第3位为1表示以10为基数，第4位为1表示以8为基数，第5位为1表示以16为基数，如果要输出原来以10为基数，要设置为以16为基数，则要将第5位设置为1,和将第3位设置为0：这叫做清除位</li>
</ul>
</li>
<li>ios_base类为此定义了常量<ul>
<li><code>setf(ios_base::dec, ios_base::basefield)</code>，使用10为基数</li>
<li><code>setf(ios_base::oct, ios_base::basefield)</code>，使用8为基数</li>
<li><code>setf(ios_base::hex, ios_base::basefield)</code>，使用16为基数</li>
<li><code>setf(ios_base::fixed, ios_base::floatfield)</code>，使用定点计数法</li>
<li><code>setf(ios_base::scientific, ios_base::floatfield)</code>，使用科学计数法</li>
<li><code>setf(ios_base::left, ios_base::adjustfield)</code>，使用左对齐</li>
<li><code>setf(ios_base::right, ios_base::adjustfield)</code>，使用右对齐</li>
<li><code>setf(ios_base::internal, ios_base::adjustfield)</code>，符号或基数前缀左对齐，值右对齐</li>
<li>第二个参数清理一批相关位，然后第一个参数将其中1位设置为1</li>
</ul>
</li>
</ul>
</li>
<li>调用setf的效果可通过<code>unsetf()</code>消除<ul>
<li>原型为：<code>void unsetf(fmtflags mask);</code>，mask中位设置为1,将使对应的位被复位</li>
</ul>
</li>
</ul>
<p>使用setf不是进行格式化、对用户友好的方法，C++提供了过个控制符，如hex、dex等。如：使用下列方式打开左对齐和定点选项<code>cout &lt;&lt; left &lt;&lt; fixed;</code></p>
<h3 id="使用cin进行输入"><a href="#使用cin进行输入" class="headerlink" title="使用cin进行输入"></a>使用cin进行输入</h3><p>istream类重载了抽取运算符<code>&gt;&gt;</code>，使之能识别基本类型。重载的原型为：<code>istream&amp; operator&gt;&gt;(Type&amp;)</code>参数和返回都是引用。引用参数意味着会修改参数本身;每个抽取运算符都返回调用对象本身，这使得能够将输入拼接。</p>
<p>可以将hex、oct和dec控制符与cin一起使用，来指定将整数输入解释为十六进制、八进制还是十进制格式。</p>
<h4 id="cin-gt-gt-如何检查输入"><a href="#cin-gt-gt-如何检查输入" class="headerlink" title="cin&gt;&gt;如何检查输入"></a>cin&gt;&gt;如何检查输入</h4><p>抽取运算符跳过空白(空格、换行、制表符)，直到遇到非空白字符。抽取运算符将读取指定类型是数据，即从非空白字符开始，到与指定类型不匹配的第一个字符之间的全部内容。不匹配的内容将留在流中，下一个cin语句将从这里开始读取。</p>
<p>如果istream对象的错误状态被设置，if或while将判定该对象为false。</p>
<h4 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h4><p>cin或cout对象包含一个描述流状态的数据成员。流状态由3个ios_base元素组成：eofbit、badbit、failbit，每个元素都是一位，可以是1或0。当全部3个状态都设置为0，则一切顺利。</p>
<ul>
<li>设置状态<ul>
<li><code>clear(eofbit)</code>方法将状态设置为它的参数(eofbit)，剩下的两个状态位置被清除<ul>
<li><code>clear()</code>将清除全部3个状态位</li>
</ul>
</li>
<li><code>setstate()</code>方法只影响其参数中已设置的位，如<code>setstate(eofbit)</code>如果已经设置了failbit，则仍将被设置</li>
</ul>
</li>
<li>I/O异常<ul>
<li>可以通过<code>exceptions()</code>方法来控制异常如何被处理<ul>
<li><code>exceptions()</code>方法返回一个位字段，它包含3个位，分别对应于eofbit、failbit、badbit</li>
<li>修改流状态后<code>clear()</code>方法将当前的流状态与<code>exceptions()</code>返回的值进行比较。如果当前状态中有”期望”的状态，则clear引发ios_base::failure异常，就可以通过<code>catch(ios_base::failure)</code>捕获</li>
<li>位运算符OR使得能够指定多位：<code>cin.exceptions(badbit|eofbit);</code></li>
</ul>
</li>
</ul>
</li>
<li>流状态的影响<ul>
<li>只有流状态良好这个语句才会返回true<code>while(cin&gt;&gt;input)</code>，但这么做有个 <strong>严重的后果</strong> ：流将对后面的输入或输出关闭，直到位被清除</li>
<li>如果希望程序在流状态被设置后能够读取后面的输入，就必须将流状态设置为良好(clear)和将引发错误的字符清空(<code>while(!isspace(cin.get()))</code>或<code>while(cin.get()!=&#39;\n&#39;)</code>)</li>
</ul>
</li>
</ul>
<h4 id="其他istream方法"><a href="#其他istream方法" class="headerlink" title="其他istream方法"></a>其他istream方法</h4><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Type, Type&gt; Hash;</span><br><span class="line"><span class="comment">//索引、添加、修改</span></span><br><span class="line">Hash[key];</span><br><span class="line">Hash[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">//添加</span></span><br><span class="line">Hash[<span class="number">2</span>] = <span class="number">3</span>; <span class="comment">//修改</span></span><br><span class="line"><span class="comment">//计数</span></span><br><span class="line">Hash.count(key);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">Hash.erase(key);</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/Major/assembly_language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/09/Major/assembly_language/" class="post-title-link" itemprop="url">汇编语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-09T00:00:00+08:00">2020-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-23 21:22:25" itemprop="dateModified" datetime="2020-05-23T21:22:25+08:00">2020-05-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>地址总线<ul>
<li>CPU通过地址总线来指定存储单元，N根导线可以传送N位二进制数，可选址$2^N$个内存单元，可表示最大的数为$2^N - 1$。</li>
</ul>
</li>
<li>数据总线<ul>
<li>CPU与内存或其他器件之间的数据传输是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传输速度。如8根数据总线一次可以传送8位(一个字节)二进制数据。</li>
</ul>
</li>
<li>控制总线<ul>
<li>CPU对外部器件的控制是通过控制总线来进行的。有多少跟控制总线就意味着CPU提供了对外部器件的多少种控制。</li>
</ul>
</li>
<li>主板<ul>
<li>主板上有核心器件和一些主要部件，这些部件通过总线(地址总线、数据总线、控制总线)相连</li>
</ul>
</li>
<li>接口卡<ul>
<li>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作</li>
</ul>
</li>
<li>各类储存器芯片<ul>
<li>从读写属性上分为两类：随机储存器(RAM)和只读储存器(ROM)<ul>
<li>随机储存器可读可写，关机后储存的内容丢失</li>
<li>只读储存器只读不能写入，关机后内容不会丢失</li>
</ul>
</li>
</ul>
</li>
<li>地址空间<ul>
<li>内存地址空间的大小受CPU地址总线宽度的限制，如CPU地址总线宽度是20,可以传送$2^{20}$个不同的地址信息。可定位$2^20$个内存单元，该CPU的内存地址空间大小为1MB</li>
</ul>
</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是CPU中程序员可以用指令读写的部件。不同的CPU寄存器的个数、结构是不同的。8086CPU有14个寄存器，每个寄存器有一个名字。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>8086CPU的所有寄存器都是16位的，可以储存两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性数据，被称为 <strong>通用寄存器</strong> 。这4个寄存器可以分为两个独立使用的8位寄存器来使用:</p>
<ul>
<li>AX可分为AH和AL<ul>
<li>AX的低8位构成了AL寄存器，高8位构成了AH寄存器，后面的同理</li>
</ul>
</li>
<li>BX可分为BH和BL</li>
<li>CX可分为CH和CL</li>
<li>DX可分为DH和DL</li>
</ul>
<h3 id="几条汇编命令"><a href="#几条汇编命令" class="headerlink" title="几条汇编命令"></a>几条汇编命令</h3><table>
<thead>
<tr>
<th>汇编命令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,18</td>
<td>将18送入寄存器AX</td>
<td>AX=18</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将寄存器bx的数据送入寄存器AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax,18</td>
<td>将寄存器AX的数值加上18</td>
<td>AX=AX+18</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>将寄存器AX的数值加上寄存器BX的数值</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。</p>
<h3 id="16位结构的CPU"><a href="#16位结构的CPU" class="headerlink" title="16位结构的CPU"></a>16位结构的CPU</h3><p>特征：</p>
<ul>
<li>运算器最多可处理16位的数据</li>
<li>寄存器的最大宽度为16</li>
<li>寄存器和运算器之间的通路为16位</li>
</ul>
<h3 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h3><p>8086CPU有20位地址总线，可以传送20位地址。8086CPU又是16位结构，在内部一次性处理、传输、暂时储存的地址为16位。</p>
<p>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址</p>
<p>8086CPU读写内存的过程如下：</p>
<ul>
<li><ol>
<li>CPU中相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</li>
</ol>
</li>
<li><ol start="2">
<li>段地址和偏移地址通过内部总线接入一个称为地址加法器的部件</li>
</ol>
</li>
<li><ol start="3">
<li>地址加法器将两个16位地址合成一个20位的物理地址</li>
</ol>
</li>
<li><ol start="4">
<li>地址加法器通过内部总线20位物理地址送入输入输出控制电路</li>
</ol>
</li>
<li><ol start="5">
<li>输入输出控制电路将20位物理地址送上地址总线</li>
</ol>
</li>
<li><ol start="6">
<li>20位物理地址被地址总线传送到储存器</li>
</ol>
</li>
</ul>
<p>地址加法器采用 <strong>物理地址=段地址×16+偏移地址</strong> 的方法合成物理地址。如1230+00C8=12300+00C8=123C8(十六进制表示)</p>
<h3 id="“物理地址-段地址×16-偏移地址”的本质含义"><a href="#“物理地址-段地址×16-偏移地址”的本质含义" class="headerlink" title="“物理地址=段地址×16+偏移地址”的本质含义"></a>“物理地址=段地址×16+偏移地址”的本质含义</h3><p>本质含义是：CPU在访问内存时，用一个基础地址(段地址×16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。(有点类似计网中的网段)</p>
<h3 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h3><p>其实内存没有分段，段的划分来自于CPU，如我们可以认为地址10000H<del>100FFH的内存单元组成一个段，基础地址为10000H，段地址为1000H;我们也可以认为10000H</del>10007FH、10080H～100FFH的内存单元为两段，基础地址为10000H和10080H，段地址为1000H和1008H。</p>
<p>在编程时根据需要，将若干地址连续的内存单元看作一个段。</p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS、DS、SS、ES。</p>
<h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3><p>CS和IP是8086CPU中最关键的两个寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器。</p>
<p>在8086PC机中，设CS中内容为M，IP中内容为N，8086CPU将从内存M×16+N单元开始，读取一条命令并执行。过程如下</p>
<ul>
<li><ol>
<li>8086CPU当前状态：CS中内容为2000H，IP中内容为0000H</li>
</ol>
</li>
<li><ol start="2">
<li>内存20000H～20009H单元中存放着的机器码对应的汇编指令如下：<ul>
<li>地址：20000H～20002H，内容：B8 23 01，长度：3Byte，对应汇编指令：mov ax，0123H</li>
<li>等等</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>CS和IP寄存器的内容传入地址加法器合成物理地址20000H</li>
</ol>
</li>
<li><ol start="4">
<li>输入输出控制电路将物理地址20000H送上地址总线</li>
</ol>
</li>
<li><ol start="5">
<li>从内存20000H单元开始存放的机器指令B8 23 01通过数据总线送入CPU</li>
</ol>
</li>
<li><ol start="6">
<li>输入输出控制电路将机器指令B8 23 01送入指令缓冲器</li>
</ol>
</li>
<li><ol start="7">
<li>IP中的值根据指令长度自动增加</li>
</ol>
</li>
<li>跳转到第1步，重复这个过程</li>
</ul>
<p>CPU工作的时候把有的信息看作指令，有的信息看作数据，那CPU根据什么将内容中的信息看着指令？</p>
<ul>
<li>CPU将CS:IP指向的内存单元中的内容看作指令，因为，在任何时候，CPU将CS、IP中的内容看作指令的段地址和偏移地址，来在内存中读取指令码</li>
</ul>
<h3 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="修改CS、IP的指令"></a>修改CS、IP的指令</h3><p>在CPU中程序员能用指令读写的部件只有寄存器，程序员可以通过寄存器实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，通过改变CS、IP中的内容来控制CPU执行目前指令。</p>
<p>8086CPU大部分寄存器的值都可以通过mov指令来改变，mov指令被称为传送指令。但mov指令不能用于设置CS、IP的值，因为8086没有提供这样的功能。要改变CS、IP的内容需要的指令被称为跳转指令。一下简单介绍jmp指令。</p>
<p>若想修改CS、IP的内容，可用<code>jmp 段地址:偏移地址</code>的指令完成，如<code>jmp 2AE3:3</code>执行后<code>CS=2AE3H, IP=0003H</code>。</p>
<p>若想仅修改IP的内容，可用形如<code>jmp 某一合法寄存器</code>的指令来完成，如<code>jmp ax</code>执行后<code>IP=ax</code>。含义上好似<code>mov IP,ax</code></p>
<h2 id="寄存器-内存访问"><a href="#寄存器-内存访问" class="headerlink" title="寄存器(内存访问)"></a>寄存器(内存访问)</h2><h3 id="内存中字的储存"><a href="#内存中字的储存" class="headerlink" title="内存中字的储存"></a>内存中字的储存</h3><p><strong>字单元的概念</strong> :字单元，即存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p>
<p>以后我们称起始地址为N的字单元简称为N地址字单元。</p>
<p>例子：<br>|   |     |<br>|—|—–|<br>| 0 | 20H |<br>| 1 | 4EH |<br>| 2 | 12H |<br>| 3 | 00H |</p>
<p>0地址单元中存放的字节型数据是：20H</p>
<p>0地址字单元中存放的字型数据是：4E20H</p>
<h3 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h3><p>CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。</p>
<p><code>mov al, [0]</code>，这个指令将内存单元中的内容送入寄存器al。”[address]”表示一个内存单元，其中<code>[0]</code>中的0表示内存单元的偏移地址。执行命令时8086CPU自动读取DS中的数据为内存单元的段地址。</p>
<p>如何把一个数据送入DS寄存器呢？我们以前用过类似<code>mov ax,a</code>这样的指令来完成，但是8086CPU不支持将数据直接放入段寄存器的操作，所有需要先将数据放入一个一般寄存器，然后把一般寄存器的内容送入DS寄存器，<code>mov ds,ax</code>。</p>
<h3 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h3><p>我们用mov指令在寄存器和内存之间进行字节型数据的传送。因为8086CPU是16位结构的，也就是说一次传送一个字。只要在mov指令中给出16位寄存器就可以进行16位的数据传送了，mov指令中给出8位寄存器就进行8位数据传输。</p>
<p>例子：<br>|   |     |<br>|—|—–|<br>| 0 | 20H |<br>| 1 | 4EH |<br>| 2 | 12H |<br>| 3 | 00H |</p>
<p><code>mov ax,[1]</code>的结果是<code>ax=124EH</code></p>
<h3 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h3><p>8086CPU提供相关的指令来以栈的方式访问内存空间，这意味着基于8086编程时，可以将一段内存当作栈来使用。</p>
<p>8086CPU提供<code>push</code>和<code>pop</code>的入栈和出栈指令。<code>push ax</code>表示将寄存器ax中的数据送入栈中，<code>pop ax</code>表示从栈顶取出数据送入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。</p>
<ul>
<li>CPU如何知道哪段地址空间被当作栈来使用？push和pop时如何知道哪个单元是栈顶单元？<ul>
<li>8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。<strong>任意时刻SS:SP指向栈顶元素</strong> 。</li>
</ul>
</li>
</ul>
<p><code>push ax</code>执行时，由一下两个两步完成</p>
<ul>
<li><ol>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶单元为新的栈顶</li>
</ol>
</li>
<li><ol start="2">
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>
</ol>
</li>
</ul>
<p>因为CPU执行顺序是从地址低到高，而栈的后进先出的结构，所以push时从后方的地址开始<br>|                |    |<br>|—————-|—-|<br>| 10000H         |    |<br>| 10001H         |    |<br>| …            |    |<br>| SS:SP-&gt;1000EH | 23 |<br>| 1000FH         | 01 |</p>
<p><code>pop ax</code>的执行过程和<code>push ax</code>刚好相反：</p>
<ul>
<li><ol>
<li>将SS:SP指向的内存单元处的数据送入ax中</li>
</ol>
</li>
<li><ol start="2">
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新栈顶</li>
</ol>
</li>
</ul>
<p>栈为空时，偏移地址的计算方法：最底部的字单元的偏移地址+2，如：<br>|                        |  |<br>|————————|–|<br>| 10000H                 |  |<br>| 10001H                 |  |<br>| …                    |  |<br>| (最底部的字单元)1000EH |  |<br>| 1000FH                 |  |<br>| SP=0010H               |  |</p>
<h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><p>将一段内存当作栈段仅仅是我们编程时的一种安排</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>字在内存中存储时，要用两个地址连续的内存单元来存放</li>
<li>用mov指令访问内存单元，可以在mov指令中给出内存单元的偏移地址，此时段地址默认在DS寄存器中</li>
<li>[address]表示一个偏移地址为address的内存单元</li>
<li>在内存和寄存器之间传送数据类型时，高地址单元和高8位寄存器、低地址单元个低8位寄存器相对应</li>
<li>mov、add、sub是具有两个操作对象的指令，jmp是具有一个操作对象的指令</li>
<li>CPU不提供栈顶越界的保护，我们要自己注意</li>
</ul>
<h2 id="一个程序"><a href="#一个程序" class="headerlink" title="一个程序"></a>一个程序</h2><h3 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程"></a>一个源程序从写出到执行的过程</h3><ul>
<li>编写汇编源程序<ul>
<li>产生一个储存源程序的文本文件</li>
</ul>
</li>
<li>对源程序进行编译链接<ul>
<li>使用编译程序对源程序进行编译生成目标文件，再用链接工具对目标文件进行链接，生成可在操作系统中直接运行的可执行文件</li>
</ul>
</li>
<li>执行</li>
</ul>
<h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><h4 id="伪命令"><a href="#伪命令" class="headerlink" title="伪命令"></a>伪命令</h4><p>在汇编语言源程序中，包含两种命令，一种是汇编指令，一种是伪指令。</p>
<ul>
<li>汇编指令是有对应机械码的指令，可以被编译为机械指令，最终被CPU执行</li>
<li>伪指令没有对应的机械码，最终不被CPU执行<ul>
<li>伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作</li>
</ul>
</li>
</ul>
<h5 id="segment和ends"><a href="#segment和ends" class="headerlink" title="segment和ends"></a>segment和ends</h5><p>segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时必须要用的一对为指令。segment和ends的功能是定义一个段，一个段必须有一个名称来标识，格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">    ...</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure>

<p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到不同的段中。</p>
<h5 id="end"><a href="#end" class="headerlink" title="end"></a>end</h5><p>end是一个汇编程序的结束标记，如果碰到了伪指令end，就结束对 <strong>源程序</strong> 的编译。所以我们在写程序的时候，如果程序写完了，要在结尾出加上伪指令end。否则编译器无法知道何时结束。</p>
<p>注意，不要搞混end和ends，ends是和segment成对使用的，标记一个段的结束。而end是标记整个程序的结束。</p>
<h5 id="assume"><a href="#assume" class="headerlink" title="assume"></a>assume</h5><p>这个为指令含义为”假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</p>
<p>如下就是将一个把一个叫做code的段和cs段寄存器联系起来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    ...</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>

<h4 id="源程序中的”程序”"><a href="#源程序中的”程序”" class="headerlink" title="源程序中的”程序”"></a>源程序中的”程序”</h4><p>程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机械码，储存在可执行文件中</p>
<h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为：程序返回。</p>
<p>在程序末尾使用两条指令可以实现程序返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>


<h2 id="BX-和loop命令"><a href="#BX-和loop命令" class="headerlink" title="[BX]和loop命令"></a>[BX]和loop命令</h2><ul>
<li>用[address]表示一个内存单元时，单元的长度(类型)可以由具体指令中的其他操作对象(比如说寄存器)指出，如<code>mov al,[0]</code>这个内存单元就是一字节</li>
<li>[bx]同样也表示一个内存单元，它的偏移地址在bx中</li>
<li>loop进行循环</li>
<li>约定符号idata表示常量</li>
<li>我们将使用符号”()”来表示一个寄存器或一个内存单元中的内容</li>
</ul>
<h3 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h3><p>看看如下命令的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>

<p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA中的数据送入ax，即:(ax)=((ds)*16+(bx))</p>
<p>值得注意的是，bx是寄存器，可以使用一些指令，如：<code>inc bx</code>。就可以方便的完成某些任务，如：把每个内存单元的内容变为1。</p>
<h3 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h3><p>loop指令的格式是：loop标号，CPU执行loop指令的时候，要进行两部操作：1. (cx)=(cx)-1; 2. 判断cx中的值，不为零则跳转至标号处执行程序，否则向下执行。</p>
<p>可以看到cx中的值影响着loop指令的结果，通常我们在cx中存放循环次数</p>
<p>例：计算2^12。(N*2=N+N)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,11</span><br><span class="line">s:  add ax,ax</span><br><span class="line">    loop s</span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行loop时(cx)先减1,然后若(cx)不为0，则跳转到s处。从上面的例子可以总结出用cx和loop配合实现循环的3个要点：</p>
<ul>
<li><ol>
<li>在cx中存放循环次数</li>
</ol>
</li>
<li><ol start="2">
<li>loop指令中的标号所标识地址要在前面</li>
</ol>
</li>
<li><ol start="3">
<li>要循环的程序段，要写在标号和loop指令中间</li>
</ol>
</li>
</ul>
<p>用cx和loop指令配合的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">    循环执行的程序段</span><br><span class="line">    loop s</span><br></pre></td></tr></table></figure>


<h3 id="loop和-bx-的联合应用"><a href="#loop和-bx-的联合应用" class="headerlink" title="loop和[bx]的联合应用"></a>loop和[bx]的联合应用</h3><p>若我们想要计算ffff:0~ffff:b单元中的元素的和，结果储存在dx中，分析：</p>
<ul>
<li><ol>
<li>dx是16位的寄存器，内存单元不能直接加到dx中，因为如果直接加会自动区一个字的大小，不满足题意</li>
</ol>
</li>
<li><ol start="2">
<li>不能用dl来做累加操作，因为dl大小不足以容纳所有内存单元的和导致进位丢失</li>
</ol>
</li>
</ul>
<p>所以我们需要引入一个16位寄存器ax作为中介，先把内存单元的内容送如al，在用ax和dx相加，通过bx和loop就可以完成。</p>
<h3 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h3><p>段地址默认在ds中，我们可以在访问的内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。如：<code>mov ax,ds:[bx]</code></p>
<h3 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h3><p>任意向一段内存空间写入内容是很危险的，因为这段内存空间可能存放着系统数据或代码。</p>
<h2 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h2><p>程序取得所需空间的方法有两种，一种是加载程序的时候为程序分配，另一种是程序在执行的过程中向系统申请。我们将介绍第一种。</p>
<p>我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。</p>
<h3 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h3><p>考虑这样一个问题，编程计算一下8个数据的和，结果存在ax寄存器中：2134h、5342h、6563h、…。如何将这些数据储存在一组地址连续的内存单元中？又在哪找到这段内存空间？</p>
<p>我们可以在程序中，定义我们希望处理的数据，这些数据会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也会被加载如内存中。这些数据自然而然地获得了储存空间。</p>
<p>具体看下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line"></span><br><span class="line">    mov ax,2345h</span><br><span class="line">    some code...</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>程序开头”dw”的含义是定义字型数据(define word)。那这些个数据在哪里呢？由于它们在代码段中，程序在运行的时候CS中存放代码段的地址，所以可以从CS中的到他们的段地址。那它们的偏移地址是多少？因为用dw定义的数据处于代码最开始，所以偏远地址为0～E。</p>
<p>但是编译、连接成可执行文件后，在系统直接运行可能出现问题，因为在程序的入口处不是我们希望执行的指令(而是一些数据)。因此，我们可以在源程序中指明程序的入口所在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line"></span><br><span class="line">    start:  mov ax,2345h   ; &lt;---- 在程序的第一条指令的前面加上标号start</span><br><span class="line"></span><br><span class="line">            some code...</span><br><span class="line">code ends</span><br><span class="line">end start       ; &lt;----</span><br></pre></td></tr></table></figure>

<p>在程序的第一条指令的前面加上标号start，这个标号在伪命令end的后面出现，用于通知编译器程序的入口在什么地方。</p>
<p>回顾可执行文件中的程序执行过程如下：</p>
<ul>
<li><ol>
<li>有其他的程序(shell等)将可执行文件中的程序加载入内存</li>
</ol>
</li>
<li><ol start="2">
<li>设置CS:IP指向程序的第一条要执行的指令(程序入口)，从而使程序得以运行</li>
</ol>
</li>
<li><ol start="3">
<li>程序结束后，返回到加载者</li>
</ol>
</li>
</ul>
<p>现在问题是，根据什么设置CPU的CS:IP指向程序的第一条要执行的指令？这一点，是由可执行文件中的描述信息指明的。可执行文件由描述信息和程序组成：程序来自源程序中的汇编指令和定义的数据;描述信息则主要是通过编译、连接程序对源程序中相关的伪指令进行处理所得到的信息。</p>
<h3 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h3><p>我们首先要有一段可当作栈的空间，可在程序中通过定义数据来获取一段空间，然后将这段空间当作栈空间来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">                            ;用dw定义8个字型数据，加载程序后将获得8个字的内存空间，这段空间可当作栈使用</span><br><span class="line"></span><br><span class="line">    start:      mov ax,cs</span><br><span class="line">                mov ss,ax</span><br><span class="line">                mov sp,20h  ;将栈顶ss:sp指向cs:20h</span><br><span class="line">                </span><br><span class="line">                some code...</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这段程序中定义了8个字型数据，它们的值都是0。这8个数据的值是多少对程序来说没有意义，只是用它们来开辟内存。</p>
<h3 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h3><p>我们在编程的时候要主要何处是数据，何处是代码，何处是栈。这样显然就有两个问题：</p>
<ul>
<li>把它们放在一个段中使程序显得混乱</li>
<li>一个段的容量是受限的，如果数据、栈和代码都放在一个段中，空间可能就不够</li>
</ul>
<p>所以用多个段来存放数据、代码和栈。我们用定义代码段一样的方法定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来获取栈空间。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,20h  ;设置栈顶ss:sp指向stack:20</span><br><span class="line">        ...</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li>定义了多个段方法<ul>
<li>对于不同的段，要用不同的段名</li>
</ul>
</li>
<li>对段地址引用<ul>
<li>段名就相当于一个符号，它代表这段地址</li>
</ul>
</li>
</ul>
<h2 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h2><h3 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h3><ul>
<li>and指令：逻辑与指令，按位进行运算<ul>
<li>通过该指令可将操作对象相应位设备0，其他位不变</li>
</ul>
</li>
<li>or指令：逻辑或指令，按位进行运算<ul>
<li>通过该指令可将操作对象相应位设备1，其他位不变</li>
</ul>
</li>
</ul>
<h3 id="以字符形式给出的数据"><a href="#以字符形式给出的数据" class="headerlink" title="以字符形式给出的数据"></a>以字符形式给出的数据</h3><p>可以在汇编程序中，用’…’的方式指明数据是以字符的形式给出的，编译器将它们转化成对应的ASCII码。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    db &#39;unIX&#39;  ;; db是define binary，用一个字节储存，与dw同理</span><br><span class="line">data ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>“db ‘unIX’”就相当于”db 75H, 6EH, 49H, 58H”</p>
<h3 id="大小写转换的问题"><a href="#大小写转换的问题" class="headerlink" title="大小写转换的问题"></a>大小写转换的问题</h3><p>常规的解法是ASCII码加上或减去一个数，但是我们还没说到条件控制，该怎么办呢？寻找新的规律可以看到，就ASCII码的二进制形式来看，除了第5位外，大写字母和小写字母的其他位都一样。因此我们要了新的方法：将第5位变为0或1就能改变成大小写了。</p>
<h3 id="用-bx-idata-的方式进行数组的处理"><a href="#用-bx-idata-的方式进行数组的处理" class="headerlink" title="用[bx+idata]的方式进行数组的处理"></a>用[bx+idata]的方式进行数组的处理</h3><p>我们知道在C语言中，数组实际上就是一段连续的内存空间。假设第一个数长5个字节，第二个数组有5个字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[bx]  ;; 定位第一个数组</span><br><span class="line">mov al,[5+bx]  ;; 定位第二个数组</span><br><span class="line">;;或写成</span><br><span class="line">mov al,5[bx]</span><br></pre></td></tr></table></figure>

<p>和C语言对比：</p>
<ul>
<li>C语言<ul>
<li><code>a[i], b[i]</code></li>
</ul>
</li>
<li>汇编语言<ul>
<li><code>0[bx], 5[bx]</code></li>
</ul>
</li>
</ul>
<h3 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h3><p>si和di是8086CPU中和bx功能近似的寄存器，si和di不能分成两个8位寄存器来使用。</p>
<p>我们可以灵活使用[bx+si+idata]和[bx+di+idata]来表示一个内存单元。</p>
<p>-对于[bx+si]和[bx+di]，有指令<code>mov ax,[bx+si]</code>等，该指令也可以写出如下格式(常用)<br>    - <code>mov ax,[bx][si]</code><br>-对于[bx+si+idata]和[bx+di+idata]，有指令<code>mov ax,[bx+si+200]</code>等，该指令也可以写出如下格式(常用)<br>    - <code>mov ax,200[bx][si]</code><br>    - <code>mov ax,[bx][si].200</code><br>    - <code>mov ax,[bx].200[si]</code></p>
<h2 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h2><ul>
<li><ol>
<li>处理的数据在什么地方?</li>
</ol>
</li>
<li><ol start="2">
<li>要处理的数据有多长?</li>
</ol>
</li>
</ul>
<p>我们定义两个描述性符号：reg和sreg。reg表示寄存器;sreg表示段寄存器。</p>
<h3 id="bx、si、di和bp"><a href="#bx、si、di和bp" class="headerlink" title="bx、si、di和bp"></a>bx、si、di和bp</h3><p>前面三个寄存器已经讲过，现在来进行一下总结：</p>
<ul>
<li><ol>
<li>在8086CPU中，只有这4个寄存器可以用在[…]中来进行内存单元的寻址</li>
</ol>
</li>
<li><ol start="2">
<li>在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di</li>
</ol>
</li>
<li><ol start="3">
<li>只要在[…]中使用寄存器bp，而指令没有显性地给出段地址，段地址默认在ss中</li>
</ol>
</li>
</ul>
<h3 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h3><p>汇编语言中用3个概念来表达数据的位置：</p>
<ul>
<li>立即数(idata)<ul>
<li>对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器中)，在汇编语言中称为：立即数，在汇编指令中直接给出</li>
</ul>
</li>
<li>寄存器<ul>
<li>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名</li>
</ul>
</li>
<li>段寄存器(SA)和偏移地址(EA)<ul>
<li>指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中(如ds)</li>
</ul>
</li>
</ul>
<h3 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h3><p>8086CPU的指令，可以处理两种尺寸的数据：byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。汇编语言用以下方法处理：</p>
<ul>
<li>根据寄存器名指明要处理的数据的尺寸</li>
<li>在没有寄存器名存在的情况下，用操作符<code>X ptr</code>指明内存单元的长度，X在汇编指令中可以为word或byte<ul>
<li>如：<code>mov word ptr ds:[0],1</code></li>
</ul>
</li>
<li>其他方法<ul>
<li>这些指令默认了访问的是字单元还是字节单元，如<code>push [1000H]</code>push指令只进行字操作</li>
</ul>
</li>
</ul>
<h3 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h3><p>div是除法指令，使用div做除法时应注意以下问题：</p>
<ul>
<li>除数：有8位和16位两种，在一个reg或内存单元中</li>
<li>被除数：默认放在AX或DX和AX中<ul>
<li>如果除数是8位，被除数则为16位，默认在AX中存放</li>
<li>如果除数是16位，被除数则为32位，默认在DX和AX中存放，DX存放高16位，AX存放低16位</li>
</ul>
</li>
<li>结果<ul>
<li>如果除数为8位，则AL储存除法操作的商，AH储存除法操作的余数</li>
<li>如果除数为16位，则AX储存除法操作的商，DX储存除法操作的余数</li>
</ul>
</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br></pre></td></tr></table></figure>

<p>例：计算100001/100</p>
<p>被除数100001远大于65535，所以只能用dx和ax两个寄存器联合存放100001(32位)。除数小于255,可以在一个8位寄存器中存放。但是因为被除数是32位的，除数应该为16位，所以用一个16位的寄存器储存100.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>


<h3 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h3><p>dd是用来定义dword(double word，双字)类型数据的</p>
<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p>dup是一个操作符，在汇编语言中和db、dw、dd等一样，也是由编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0,1,2)</span><br></pre></td></tr></table></figure>

<p>定义了9个字节，相当于<code>db 0,1,2,0,1,2,0,1,2</code></p>
<p>dup的使用格式如下：</p>
<ul>
<li>db 重复的次数 dup (重复的字节型数据)</li>
<li>dw 重复的次数 dup (重复的字型数据)</li>
<li>dd 重复的次数 dup (重复的双字型数据)</li>
</ul>
<h2 id="转移指令的原理"><a href="#转移指令的原理" class="headerlink" title="转移指令的原理"></a>转移指令的原理</h2><p><strong>可以修改IP，或同时修改CS和IP的指令统称为转移指令</strong>。</p>
<p>8086CPU的转移指令行为有以下几类：</p>
<ul>
<li>只修改IP时，称为段内转移，如：<code>jmp ax</code> </li>
<li>同时修改CS和IP时，称为段间转移，如：<code>jmp 1000:0</code></li>
</ul>
<h3 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h3><p>offset是由编译器处理的符号，它的功能是取得标号的偏移地址。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start:mov ax,offset start   ;; 相当于mov ax,0</span><br><span class="line">        s:mov ax,offset s       ;; 相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面的程序中，offset操作符取得了标号start和s的偏移地址0和3。</p>
<h3 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h3><p><code>jmp short 标号</code>转到标号处执行指令</p>
<p>这种格式的jmp指令实现的是段内短转移，它对IP修改的范围为-128~127，即最多可以向前跨越128个字节，向后127个字节。指令中的”标号”是代码段中的标号，指明了指令要转移的目的地，跳转指令结束后，CD:IP应该指向标号处的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start:mov mov ax, 0   </span><br><span class="line">          jmp short s</span><br><span class="line">          add ax, 1</span><br><span class="line">        s:inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面的程序就跳过了<code>add ax, 1</code></p>
<p><code>jmp short</code>依据位移进行转移，也就是说CPU执行jmp指令的时候并不需要转移的目的地址，只需要转移的位移，编译器后计算jmp到标号的位移。</p>
<p><code>jmp short 标号</code>的功能为：(IP)=(IP)+8位位移</p>
<ul>
<li>8位位移=标号处的地址-jmp指令后的第一个字节的地址</li>
<li>short指明此处的位移为8位位移</li>
<li>8位位移的范围为-127~128，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
<p>还有一种与<code>jmp short</code>功能类似的指令，<code>jmp near ptr 标号</code>，它实现的是段内转移，功能为：(IP)=(IP)+16</p>
<ul>
<li>17位位移=标号处的地址-jmp指令后的第一个字节的地址</li>
<li>near ptr指明此处的位移为16位位移</li>
<li>16位位移的范围为-32768~32767，用补码表示</li>
<li>16位位移由编译程序在编译时算出</li>
</ul>
<h3 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h3><p><code>jmp far ptr 标号</code>实现的是段间转移，又称远转移，功能如下：</p>
<ul>
<li>(CS)=标号所在的段地址;(IP)=标号所在段中的偏移地址。</li>
<li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP</li>
</ul>
<h3 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h3><p>转移地址在内存中的jmp指令有两种格式：</p>
<ul>
<li><code>jmp word ptr 内存单元地址(段内地址)</code><ul>
<li>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址</li>
</ul>
</li>
<li><code>jmp dword ptr 内存单元地址(段内地址)</code><ul>
<li>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处的转移的目的偏移地址</li>
<li>(CS)=(内存单元地址+2)</li>
<li>(IP)=(内存单元地址)</li>
</ul>
</li>
</ul>
<h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是转移的目的地址。对IP的修改范围都是：-127~128</p>
<p>指令格式：<code>jcxz 标号</code>如果(cx)=0，则转移到标号处执行</p>
<ul>
<li>操作：当(cx)=0时，(IP)=(IP)+8位位移<ul>
<li>8位位移=标号处的地址-jcxz指令后的第一个字节的地址</li>
<li>8位位移的范围为-127~128，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
</li>
<li>当(cx)!=0时，什么也不做，程序向下执行</li>
</ul>
<p>用C语言的话说，<code>jcxz 标号</code>的功能相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((cx)==<span class="number">0</span>)jmp short 标号;</span><br></pre></td></tr></table></figure>


<h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是转移的目的地址。对IP的修改范围都是：-127~128</p>
<p>指令格式：<code>loop 标号</code>(cx)=(cx)-1，如果(cx)!=0，则转移到标号处执行</p>
<ul>
<li>操作：(cx)=(cx)-1;如果(cx)!=0,(IP)=(IP)+8位位移<ul>
<li>8位位移=标号处的地址-jcxz指令后的第一个字节的地址</li>
<li>8位位移的范围为-127~128，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
</li>
<li>当(cx)=0时，什么也不做，程序向下执行</li>
</ul>
<p>用C语言的话说，<code>loop 标号</code>的功能相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line"><span class="keyword">if</span>((cx)!=<span class="number">0</span>)jmp short 标号;</span><br></pre></td></tr></table></figure>


<h3 id="根据位移转移的意义"><a href="#根据位移转移的意义" class="headerlink" title="根据位移转移的意义"></a>根据位移转移的意义</h3><p>这种设计方便了程序段在内存中的浮动配置。这段程序在内存中的不同位置都可以正确执行，只需要位移，而不需要具体的地址。因为当指令不存在具体地址处时，程序执行就会出错。</p>
<h2 id="CALL和RET指令"><a href="#CALL和RET指令" class="headerlink" title="CALL和RET指令"></a>CALL和RET指令</h2><p>call和ret指令都是转移指令，它们修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序(函数)的设计</p>
<h3 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h3><ul>
<li>ret指令用栈中的数据修改IP的内容，从而实现转移。执行ret指令时，进行下面两步操作：<ul>
<li><ol>
<li>(IP)=((ss)*16+(sp))<ul>
<li>出栈</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>(sp)=(sp)+2</li>
</ol>
</li>
<li>相当于<code>pop IP</code></li>
</ul>
</li>
<li>retf指令用栈中的数据修改cs和ip的内容，从而实现转移。执行retf指令时，进行下面4步操作：<ul>
<li><ol>
<li>(IP)=((ss)*16+(sp))</li>
</ol>
</li>
<li><ol start="2">
<li>(sp)=(sp)+2</li>
</ol>
</li>
<li><ol start="3">
<li>(CS)=((ss)*16+(sp))</li>
</ol>
</li>
<li><ol start="4">
<li>(sp)=(sp)+2</li>
</ol>
</li>
<li>相当于<code>pop IP; pop CS</code></li>
</ul>
</li>
</ul>
<h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>CPU执行call指令时，进行两步操作：</p>
<ul>
<li><ol>
<li>将当前的IP或CS和IP压入栈中</li>
</ol>
</li>
<li><ol start="2">
<li>转移</li>
</ol>
</li>
</ul>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令了原理相同</p>
<p>一下介绍call指令的主要应用格式</p>
<h3 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h3><p><code>call 标号</code>，将当前的IP压入栈后，转到标号处执行指令</p>
<p>CPU执行此种格式的call指令时，进行的操作如下：</p>
<ul>
<li><ol>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<ul>
<li>入栈，栈顶指针上移</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>(IP)=(IP)+16位位移<ul>
<li>根据标号</li>
</ul>
</li>
</ol>
</li>
<li>相当于:<code>push IP;jmp near ptr 标号</code></li>
</ul>
<h3 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h3><p><code>call far ptr 标号</code>，实现的是段间转移，CPU执行这种格式的call指令时，操作如下：</p>
<ul>
<li><ol>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(CS)<br>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<ul>
<li>入栈</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>(CS)=标号所在段的段地址<br>(IP)=标号所在段中的偏移地址</li>
</ol>
</li>
<li>相当于<br><code>push CS</code><br><code>push IP</code><br><code>jmp far ptr 标号</code></li>
</ul>
<h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p>格式:<code>call 16位reg</code>。功能：</p>
<ul>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(IP)=(16位reg)</li>
<li>相当于：<br><code>push IP</code><br><code>jmp 16位reg</code></li>
</ul>
<h3 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h3><p>转移地址在内存中的call指令有两种格式：</p>
<ul>
<li><code>call word ptr 内存单元地址</code><ul>
<li>相当于：<br><code>push IP</code><br><code>jmp word ptr 内存单元地址</code></li>
</ul>
</li>
<li><code>call dword ptr 内存单元地址</code><ul>
<li>相当于：<br><code>push CS</code><br><code>push IP</code><br><code>jmp dword ptr 内存单元地址</code></li>
</ul>
</li>
</ul>
<h3 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h3><p>我们可以写一个具有一定功能的程序段，我们称之为子程序，在需要的时候用call指令转去执行。执行完后用ret指令，用栈中的数据设置IP值，从而跳到call的下一条指令继续执行。</p>
<p>这样，我们可以利用call和ret来实现子程序的机制。子程序的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号：</span><br><span class="line">    指令</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>具有子程序的源程序的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    main:</span><br><span class="line">        :</span><br><span class="line">        call sub1   ;;调用子程序1</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    sub1:</span><br><span class="line">        :</span><br><span class="line">        call sub2</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    sub2:</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>

<p>使用call和ret可以实现模块化设计</p>
<h3 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h3><p>mul是乘法指令，使用mul时注意以下两点：</p>
<ul>
<li><ol>
<li>两个相乘的数：两个数要么都是8位，要么都是16位<ul>
<li>如果是8位乘法，一个默认放在AL中，另一个放在8位reg或内存字节单元中</li>
<li>如果是16位乘法，一个默认在AX中，另一个放在16为reg或内存字单元中</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>结果：<ul>
<li>8位乘法结果默认放在AX中</li>
<li>16位乘法结果高位默认放在DX中，低位放在AX中</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">;; 内存单元可以用不同的寻址方式给出：</span><br><span class="line">mul byte ptr ds:[0]</span><br><span class="line">mul word ptr [bx+si+8]</span><br></pre></td></tr></table></figure>


<h3 id="参数和结果传递的问题"><a href="#参数和结果传递的问题" class="headerlink" title="参数和结果传递的问题"></a>参数和结果传递的问题</h3><p>既然知道了如何调用子程序，那应该如何储存子程序需要的参数和产生的返回值呢？</p>
<ul>
<li>显然可以用寄存器来存。</li>
</ul>
<p>那么如果有N个参数和结果，寄存器的个数是有限的，该怎么存放呢？</p>
<ul>
<li>这个时候没将批量的数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给子程序。对于批量的结果也如此的方法。</li>
</ul>
<p><strong>看下面一个例子:</strong> 设计一个子程序，将一个全是字母的字符串转换为大写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#39;conversation&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:  mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0        ;ds:si指向字符串所在空间的首地址</span><br><span class="line">            mov cx,12       ;cx存放字符串的长度</span><br><span class="line">            call capital    ;调用子程序，就像调用函数</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">    capital:and byte ptr [si],11011111b</span><br><span class="line">            inc si</span><br><span class="line">            loop capital</span><br><span class="line">            ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数</strong></p>
<h4 id="用栈来传递参数"><a href="#用栈来传递参数" class="headerlink" title="用栈来传递参数"></a>用栈来传递参数</h4><p>由调用者将要传递给子程序的参数压入栈中，子程序从栈中取得参数。</p>
<ul>
<li>编写一个函数：计算(a-b)^3，a、b为字型数据，参数为a、b</li>
<li>栈顶存放IP、后面依次是a、b(注意参数顺序)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func:   push bp         ;子程序用到寄存器bp，先保存原来的值</span><br><span class="line">        mov bp,sp</span><br><span class="line">        mov ax,[bp+4]   ;将栈中a送入ax</span><br><span class="line">        sub ax,[bp+6]   ;减栈中b的值</span><br><span class="line">        mov bp,ax</span><br><span class="line">        mul bp</span><br><span class="line">        mul bp</span><br><span class="line">        pop bp</span><br><span class="line">        ret 4</span><br></pre></td></tr></table></figure>

<p>指令<code>ret 4</code>的含义用汇编语法描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip      ;即返回ip，并使将栈顶指针该为调用前的值。应为这个例子的参数是两个字，所以是4.</span><br><span class="line">add sp,n</span><br></pre></td></tr></table></figure>

<p>看一下对这个函数是如何调用的，设a=3、b=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mob ax,1</span><br><span class="line">push ax</span><br><span class="line">mov ax,3    ;注意顺序</span><br><span class="line">push ax</span><br><span class="line">call func</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>低地址单元</th>
</tr>
</thead>
<tbody><tr>
<td>BP</td>
</tr>
<tr>
<td>IP</td>
</tr>
<tr>
<td>3  [bp+4]</td>
</tr>
<tr>
<td>1  [bp+6]</td>
</tr>
<tr>
<td>高地址单元</td>
</tr>
</tbody></table>
<h3 id="寄存器冲突的问题"><a href="#寄存器冲突的问题" class="headerlink" title="寄存器冲突的问题"></a>寄存器冲突的问题</h3><p>问题在于：<strong>子程序中的寄存器，很可能在组程序中也要使用，造成寄存器使用上的冲突</strong></p>
<p>我们希望：</p>
<ul>
<li>编写调用子程序的时候不必关心子程序到底使用了那些寄存器</li>
<li>编写子程序的时候不必关心调用者使用了哪些寄存器</li>
<li>不会发生寄存器冲突</li>
</ul>
<p>解决这个问题的间捷方法是，在子程序的开始将子程序中所有用到的内容保存起来，在子程序返回前恢复。可以用栈来保存寄存器中的内容</p>
<p>以后我们编写子程序的标准框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序开始: 子程序使用的寄存器入栈</span><br><span class="line">            子程序内容</span><br><span class="line">            子程序中使用的寄存器出栈</span><br><span class="line">            返回(ret、retf)</span><br></pre></td></tr></table></figure>

<p>看下面一个例子，将一个全是字母，以0结尾的字符串转换为大写的子程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">capital:    push cx  ;使用的寄存器入栈</span><br><span class="line">            push si</span><br><span class="line"></span><br><span class="line">change:     mov cl,[si]</span><br><span class="line">            mov ch,0</span><br><span class="line">            jcxz ok</span><br><span class="line">            and byte ptr [si],11011111b</span><br><span class="line">            inc si</span><br><span class="line">            jmp short change</span><br><span class="line"></span><br><span class="line">        ok: pop si  ;使用的寄存器出栈</span><br><span class="line">            pop cx</span><br><span class="line">            ret</span><br></pre></td></tr></table></figure>


<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>在CPU内部的寄存器中，有一种特殊的寄存器(不同的CPU，个数结构可能不同)具有以下3种作用：</p>
<ul>
<li>用来存储相关指令的某些执行结果</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPu的相关工作方式</li>
</ul>
<p>这种特殊的寄存器在8086CPU中，被称为 <strong>标志寄存器</strong> 。以下称为flag寄存器。</p>
<p>8086CPU的flag寄存器的结构如下：</p>
<table>
<thead>
<tr>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>OF</td>
<td>DF</td>
<td>IF</td>
<td>TF</td>
<td>SF</td>
<td>ZF</td>
<td></td>
<td>AF</td>
<td></td>
<td>PF</td>
<td></td>
<td>CF</td>
</tr>
</tbody></table>
<h3 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h3><p>flag的第6位是ZF，零标志位。它记录相关指令执行后其结果是否为0。如果结果为0,则zf=1;否则zf=0。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br><span class="line"></span><br><span class="line">;zf&#x3D;1</span><br></pre></td></tr></table></figure>

<p>在8086CPU的指令集中，有的指令执行是影响标志位寄存器的，如：add、sub、mul、div、and、or等，它们大多都是运算指令;有的指令是不影响的，如mov、push、pop等，它们大多都是传送指令。</p>
<h3 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h3><p>flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数是偶数，pf=1。否则pf=0。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br><span class="line"></span><br><span class="line">;结果是00001011b，有奇数个1，pf&#x3D;0</span><br></pre></td></tr></table></figure>


<h3 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h3><p>flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果(对于有符号数)是否为负。如果结果为负，sf=1，否则sf=0。</p>
<p>计算机通常使用补码来表示有符号数，对于无符号数SF的值没有意义，虽然相关指令影响了它的值。</p>
<h3 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h3><p>flag的第0位是CF，进位标志。一般情况下，进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p>
<p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，就是它的最高有效位。</p>
<h3 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h3><p>由于进行有符号数运算的时候，可能发生溢出造成结果错误。则CPU需要对指令执行后产生的溢出进行记录。</p>
<p>flag的第11位是OF，溢出标志。一般情况下，OF记录了有符号数运算的结果是否溢出了。如果溢出，OF=1，否则OF=0。</p>
<p>注意CF和OF的区别：CF是对无符号数有意义的标志位，OF是对无符号数有意义的标志位。</p>
<h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><p>adc是带进位加法指令，它利用了CF上记录的进位值。</p>
<ul>
<li>指令格式：<code>adc 操作对象1 操作对象2</code></li>
<li>功能：操作对象1 = 操作对象1 + 操作对象2 + CF</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax  ;1-2借位，CF&#x3D;1</span><br><span class="line">adc ax,1   ;执行后(ax)&#x3D;4&#x3D;(ax)+1+CF</span><br></pre></td></tr></table></figure>

<p>在执行adc指令的时候加上的CF的值的含义，由adc指令前的指令决定的。</p>
<p>CPU提供adc指令是有目的的，就是来进行加法的第二步运算。</p>
<p>例：计算1EF0001000H+2010001EF0H，结果放在ax(最高16位)，bx(次高16位)，cx(低16位)中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">mov cx,1000H</span><br><span class="line">add cx,1EF0H</span><br><span class="line">adc bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure>


<h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>sbb是带借位减法指令，它利用CF位上记录的借位值。应用思路类似adc</p>
<h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果，而是cmp指令执行后对标志寄存器产生影响。</p>
<ul>
<li>cmp指令格式：<code>cmp 操作对象1 操作对象2</code></li>
<li>功能：操作对象1-操作对象2但不保留结果，仅仅根据结算结果来对标志寄存器进行设置</li>
<li>如，<code>cmp ax,ax</code>，结果为0，那么标志寄存器：zf=1,pf=1,sf=0,cf=0,of=0。</li>
</ul>
<p>cmp的使用非常灵活，如要判断两个数相减的结果是不是负数：cmp将结果在flag中记录，通过判断sf(正负)和of(溢出)就可得知逻辑上真正结果的正负。</p>
<h3 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h3><p>除了jcxz指令之外，CPU还提供了其他条件转移指令，大多数条件转移指令通过检测相关的标志位，根据检测的结果修改IP。通常和cmp配合使用。</p>
<p>下面是常用的条件转移指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<h3 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h3><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p>
<ul>
<li>df=0，每次操作后si、di递增</li>
<li>df=1，每次操作后si、di递减</li>
</ul>
<p>看下面一个串传送指令：</p>
<ul>
<li>格式：<code>movsb</code></li>
<li>功能：将ds:si指向的内存单元中的字节送入es:di中。执行movsb指令相当于进行下面几步操作<ul>
<li><ol>
<li>((es)*16+(di))=((ds)*16+(si))</li>
</ol>
</li>
<li><ol start="2">
<li>如果df=0，则(si)=(si)+1;(di)=(di)+1</li>
</ol>
</li>
<li><ol start="2">
<li>如果df=1，则(si)=(si)-1;(di)=(di)-1</li>
</ol>
</li>
</ul>
</li>
<li>相当于：<br>  <code>mov es:[di], byte ptr ds:[si]</code><br>  如果df=0：<code>inc si;inc di</code><br>  如果df=1：<code>dec si;dec di</code>  </li>
<li>传送一个字的指令是<code>movsw</code></li>
</ul>
<p>movsb和movsw进行的是串传送操作中的一个步骤，一般来说movsb和mobsw都是配合rep使用的，个是如下</p>
<ul>
<li><code>rep movsb</code><ul>
<li>类似于:<br><code>s:movsb</code><br><code>loop s</code></li>
</ul>
</li>
<li>rep的作用是根据cx的值，重复后面的串传送指令</li>
</ul>
<p>由于df位决定着串传送指令执行后，si和di是递增还是递减，所以CPU应提供对df进行设置的操作。在8086CPU中：</p>
<ul>
<li>cld指令：将标志位寄存器的df设置为0</li>
<li>std指令：将标志位寄存器的df设置为1</li>
</ul>
<h3 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h3><p>pushf的功能是将标志寄存器的值压入栈中，而popf是从栈中弹出数据，送入标志寄存器中。这也是为什么前面讲标志寄存器结构时，强调什么是第几位的原因。</p>
<p>pushf和popf，为直接访问标志寄存器提供了一种方法。</p>
<h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><p>任何一个通用CPU都具备一种能力：在执行完当前正在执行的指令之后，检测到从CPU外发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种信息称为中断信息。中断的意思是指，CPU不再接着向下执行，而是转去处理这个特殊的信息。</p>
<h3 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h3><p>当CPU内部有什么事情发生时会马上处理中断信息呢？对于8086CPU，有以下情况发生时，将产生中断信息：</p>
<ul>
<li>除法错误</li>
<li>单步执行</li>
<li>执行into指令</li>
<li>执行int指令</li>
</ul>
<p>不同的信息需要不同的处理方式。中断信息中包含识别来源的编码，8086CPU用称为中断类型码来识别信息的来源。中断类型码为一个字节，可以表示256种中断信息来源。在8086CPU中：</p>
<ul>
<li>除法错误:0</li>
<li>单步执行:1</li>
<li>执行into指令:4</li>
<li>执行int指令：该指令的格式为<code>int n</code>，n是立即数，是提供给CPU的中断类型码</li>
</ul>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>CPU收到中断信息后，需要对信息进行处理。如何处理可以由我们编程决定。我们所编写的中断信息处理程序称为中断处理程序。</p>
<p>CPU在收到中断信息后，应该转去(改变CS:IP指向)对应的中断处理程序中。中断类型码就是用来定位中断处理程序的。</p>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢？</p>
<ul>
<li>CPU通过中断向量表找到相应的中断处理程序入口地址。中断向量表就是中断处理程序入口地址的列表。</li>
</ul>
<p>CPU如何找到中断向量表？</p>
<ul>
<li>中断向量表在内存中存放，在8086CPU中，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF的1024个内存单元中存放着中断向量表。</li>
</ul>
<h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。所以在中断过程中，在设置CS:IP之前，还要将原来的CS和IP的值保存起来。与call指令调用子程序同理。</p>
<p>下面是8086CPU收到中断信息后，所引发中断的过程：</p>
<ul>
<li><ol>
<li>获取中断类型码</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈</li>
</ol>
</li>
<li><ol start="3">
<li>设置标志寄存器的第8位TF和第9位IF值为0，因为这也两个标志寄存器也可以是触发中断的因素</li>
</ol>
</li>
<li><ol start="4">
<li>CS内容入栈</li>
</ol>
</li>
<li><ol start="5">
<li>IP内容入栈</li>
</ol>
</li>
<li><ol start="6">
<li>从内存地址为<code>中断类型码*4</code>和<code>中断类型码*4+2</code>的两个字单元中读取中断处理程序的入口地址设置IP和CS</li>
</ol>
</li>
</ul>
<h3 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h3><p>由于CPU随时可能检测到中断信息，所以中断处理程序必须一直储存来内存的某段空间之中，而中断向量必须存储在对应的中断向量表项中。</p>
<p>中断处理程序的编写方法和子程序比较相似，步骤如下：</p>
<ul>
<li><ol>
<li>保存用到的寄存器</li>
</ol>
</li>
<li><ol start="2">
<li>处理中断</li>
</ol>
</li>
<li><ol start="3">
<li>恢复用到的寄存器</li>
</ol>
</li>
<li><ol start="4">
<li>用iret指令返回</li>
</ol>
</li>
</ul>
<p>iret指令用汇编语法描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>


<h3 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h3><p>当除法溢出的时候，产生0号中断信息，从而引发中断过程。此时，CPU将进行如下工作：</p>
<ul>
<li><ol>
<li>获取中断类型码0</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈，TF、IF设置为0</li>
</ol>
</li>
<li><ol start="3">
<li>CS、IP入栈</li>
</ol>
</li>
<li><ol start="4">
<li>(IP)=(0*4)，(CS)=(0*4+2)</li>
</ol>
</li>
</ul>
<p>那么现在的问题是，中断处理程序(我们设为do0)应该放在哪里？</p>
<ul>
<li>我们需要找到一块别的程序不会用到的内存区，将do0送入其中</li>
<li>前面说过，8086支持256个中断，但实际中并不会用到那么多。一般情况下，从0000:0200至0000:02FF的256个字节所对应的中断向量表项是空的，操作系统和其他程序都不会占用，所以我们可以使用这段空间</li>
</ul>
<p>程序框架如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  do0安装程序</span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  do0:  一些操作如:显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>可以看到，上面的程序分为两部分：</p>
<ul>
<li>安装do0，设置中断向量的程序<ul>
<li><ol>
<li>将do0的代码复制到内存0:200处</li>
</ol>
</li>
<li><ol start="2">
<li>设置中断向量表，将do0的入口地址保存到0号表项中</li>
</ol>
</li>
<li><ol start="3">
<li>返回</li>
</ol>
</li>
</ul>
</li>
<li>do0</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以使用movsb指令，将do0的代码送入0:200处。程序如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0       ;设置ds:si指向源地址</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h             ;设置es:di指向目的地址</span><br><span class="line"></span><br><span class="line">        mov cx,offset do0end-offset do0                     ;设置cs为传输长度，可利用编译器计算do0长度</span><br><span class="line"></span><br><span class="line">        cld                     ;设置传输方向为正向</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  do0:  一些操作如:显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h3 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h3><p>do0程序的主要任务是显示字符串，如下</p>
<p>需要注意的是：</p>
<ul>
<li>因为do0程序随时可能被执行，而它要用到的字符串”overflow!”，所以该字符串也应该放在一段不会被覆盖的空间中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0       ;设置ds:si指向源地址</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h             ;设置es:di指向目的地址</span><br><span class="line"></span><br><span class="line">        mov cx,offset do0end-offset do0                     ;设置cs为传输长度，可利用编译器计算do0长度</span><br><span class="line"></span><br><span class="line">        cld                     ;设置传输方向为正向</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  do0:  jmp short do0start</span><br><span class="line">        db &quot;overflow!&quot;</span><br><span class="line"></span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">         mov ds,ax</span><br><span class="line">         mov si,202h            ;设置ds:si指向字符串，因为do0主程序第一跳指令是跳转，占用两个字节，所以字符串的地址是202h</span><br><span class="line"></span><br><span class="line">         mov ax,0b800h</span><br><span class="line">         mov es,ax</span><br><span class="line">         mov di,12*160+36*2     ;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">         mov cx,9               ;设置字符串长度</span><br><span class="line">    s:   al,[si]</span><br><span class="line">         mov es:[di],al</span><br><span class="line">         inc si</span><br><span class="line">         add di,2</span><br><span class="line">         loop s</span><br><span class="line"></span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h3 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h3><p>0号表项的地址为0:0，其中0:0字单元存放偏移地址，0:2字单元存放段地址。程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0\*4],200h</span><br><span class="line">mov word ptr es:[0\*4+2],0</span><br></pre></td></tr></table></figure>


<h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>基本上，CPU在执行一条指令之后，如果检查到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的类型码为1，它引发的中断过程如下：</p>
<ul>
<li><ol>
<li>取得中断类型码</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈，TF、IF设置为0</li>
</ol>
</li>
<li><ol start="3">
<li>CS、IP入栈</li>
</ol>
</li>
<li><ol start="4">
<li>(IP)=(1*4), (CS)=(1*4+2)</li>
</ol>
</li>
</ul>
<p>CPU为什么要提供这样的功能呢？</p>
<ul>
<li>我们在debug的时候CPU执行一条指令后就显示各个寄存器的状态，然后等待输入</li>
</ul>
<p>当TF=1时，CPU在执行完一条指令后将引发单步中断，转去执行中断处理程序。 <strong>注意，中断处理程序也是由一条条指令组成的</strong> ，如果在执行中断处理程序之前，TF=1,则CPU执行完终端处理程序的第一条指令后，有产生单步中断，就这样死循环下去。</p>
<p>所以在进入中断处理程序之前，设置TF=0.从而避免CPU在执行中断处理程序的时候发生单步中断。</p>
<h3 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h3><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可在某些情况，即便是发生了中断，也不会响应。用一个例子说明：</p>
<p>在执行完向ss寄存器传送数据的指令后，即便发生中断，CPU也不会响应。因为ss:sp联合指向栈顶，对它们的设置应该连续完成。如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp没变，ss:sp不能指向正确的栈顶，引起错误。</p>
<h2 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h2><p>中断信息可以来自CPU的内部和外部，当CPU内部需要处理的事情发生时，将产生需要马上处理的中断信息，引发中断过程。</p>
<p>接下来将介绍另一种重要的内中断，由int指令引发的中断。</p>
<h3 id="int指令-1"><a href="#int指令-1" class="headerlink" title="int指令"></a>int指令</h3><p>int指令的格式为：<code>int n</code>，n为中断类型码，它的功能是引发中断过程。</p>
<p>CPU执行<code>int n</code>指令，相当于引发一个n号中断的中断过程，执行过程如下：</p>
<ul>
<li><ol>
<li>取中断类型码n</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈，IF=0，TF=0</li>
</ol>
</li>
<li><ol start="3">
<li>CS、IP入栈</li>
</ol>
</li>
<li><ol start="4">
<li>(IP)=(n*4)，(CS)=(n*4+2)<ul>
<li>跳转去n号中断处理程序</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>编写提供应用程序调用的中断例程，与中断处理类似：</p>
<ul>
<li>编写功能程序</li>
<li>安装程序到内存中</li>
<li>设置中断向量，将程序的入口地址保存到对应的表项中</li>
</ul>
<h3 id="对int、iret和栈的深入理解"><a href="#对int、iret和栈的深入理解" class="headerlink" title="对int、iret和栈的深入理解"></a>对int、iret和栈的深入理解</h3><p>问题：编写名为7ch的中断例程来完成loop指令的功能</p>
<p>分析：loop s的执行需要两个信息，循环的次数和到s的位移</p>
<p>例：屏幕中间显示80个”!”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start   :mov ax,0b800h</span><br><span class="line">         mov es,ax</span><br><span class="line">         mov di,160*12</span><br><span class="line"></span><br><span class="line">         mov bx,offset s-offset se      ;设置从标号se到标号s的转移位移</span><br><span class="line">         mov cx,80</span><br><span class="line">    s   :mov byte ptr es:[di],&#39;!&#39;</span><br><span class="line">         add di,2</span><br><span class="line">         int 7ch                        ;如果(cx)!&#x3D;0，转移到s处</span><br><span class="line">   se   :nop</span><br><span class="line"></span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>7ch中断例程如下:</p>
<ul>
<li><code>int 7ch</code>引发中断后，在中断过程中将当前的标志寄存器、CS和IP入栈</li>
<li>通过修改栈中的CS和IP就能让程序返回标号s所在的位置<ul>
<li>用标号se的偏移地址加上bx中存放的转移位移就可以得到标号s的偏移地址</li>
<li>如果7ch和主程序在同一段中，则栈中的段寄存器CS就不用修改</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  7ch   :push bp                        </span><br><span class="line">         mov bp,sp</span><br><span class="line">         dec cx</span><br><span class="line">         jcxz lpret                     ;如果cx等于0则不修改偏移地址，直接返回</span><br><span class="line">         add [bp+2],bx                  ;[bp+2]处是IP的内容，栈顶处是bp的内容，下面是se的偏移地址</span><br><span class="line">lpret   :pop bp</span><br><span class="line">         iret</span><br></pre></td></tr></table></figure>


<h3 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h3><p>在系统板的ROM中存放着一套程序，称为BIOS(基本输入输出系统)，主要包含以下几个部分：</p>
<ul>
<li>硬件系统的检测和初始化程序</li>
<li>外部中断和内部中断的中断例程</li>
<li>用于对硬件设备进行I/O操作的中断例程</li>
<li>其他和硬件系统相关的中断例程</li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>各种储存器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们当作内存来对待，把它们总地看做一个由若干储存单元组成的逻辑储存器。</p>
<p>PC机的芯片中，都有一组可以由CPU读写的寄存器，这些寄存器在物理上可能处于不同的芯片中，但是它们都在以下两点上相同：</p>
<ul>
<li>都和CPU的总线相连</li>
<li>CPU对它们进行读写的时候都通过控制总线向它们所在的芯片发出端口读写命令</li>
</ul>
<p>从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立一个统一的端口地址空间。每个端口在地址空间中都有一个地址</p>
<p>CPU可以直接读写以下3个地方的数据：</p>
<ul>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口</li>
</ul>
<p>以下讨论端口的读写</p>
<h3 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h3><p>在访问端口时，CPU通过端口地址来定位端口。因为端口所在的芯片和CPU通过总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围是0～65535</p>
<p>对端口的读写不能用mov、push、pop等内存读写指令。端口的读写指令只有两条：in和out</p>
<ul>
<li>in表示从端口读取数据</li>
<li>out表示往端口写入数据</li>
</ul>
<h4 id="访问端口"><a href="#访问端口" class="headerlink" title="访问端口"></a>访问端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h       ;从60h号端口读入一个字节</span><br></pre></td></tr></table></figure>

<p>执行时与总线相关的操作如下：</p>
<ul>
<li>CPU通过地址线将地址信息60h发出</li>
<li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</li>
<li>端口所在的芯片将60h端口中的数据通过数据线送入CPU</li>
</ul>
<p><strong>注意</strong> ，在in和out指令中，只能使用ax或al来存放从端口读入的数据或要发送到端口的数据。访问8位端口时用al，访问16位端口时用ax</p>
<p>对0～255以内的端口进行读写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h   </span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure>

<p>对256～65535的端口进行读写时，端口号放在dx中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h</span><br><span class="line">in al,dx   </span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure>


<h3 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h3><p>PC机中，有一个CMOS RAM芯片，一般简称为CMOS。有如下特征：</p>
<ul>
<li>包含一个实时钟和一个128个储存单元的RAM储存器</li>
<li>该芯片靠电池供电。所以关机后内部实时钟仍可正常工作，RAM中信息不会丢失</li>
<li>128个字节的RAM中，内部实时钟占用0～0dh单元来保存时间信息，其余大部分单元保存系统配置信息</li>
<li>该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM</li>
<li>70h为地址端口，存放要访问的CMOS RAM单元地址;71h为数据端口，存放从选定的CMOS RAM单元中读取的数据或要写入其中的数据，对CMOS操作时读写分为两步：如读CMOS RAM的2号单元<ul>
<li><ol>
<li>将2送入段偶70h</li>
</ol>
</li>
<li><ol start="2">
<li>从端口71h读出2号单元的内容</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h3><p>shl和shr是逻辑位移指令，shl是逻辑左移，shr是逻辑右移</p>
<p>以shl为例，它的功能为：</p>
<ul>
<li>将一个寄存器或内存单元中的数据向左位移</li>
<li>将最后移出的一位写入CF中</li>
<li>最低位用0补充</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1            ;将al数据左移一位</span><br><span class="line">;结果al&#x3D;10010000b， CF&#x3D;0</span><br></pre></td></tr></table></figure>

<p>如果位移数大于1时，必须将位移数放在cl中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">mov cl,2</span><br><span class="line">shl al,cl            ;将al数据左移2位</span><br><span class="line">;结果al&#x3D;00100000b， CF&#x3D;1</span><br></pre></td></tr></table></figure>

<p>逻辑左移相当于执行<code>X=X*2</code></p>
<p>shr是逻辑右移，和shl的操作相反</p>
<h3 id="CMOS-RAM中存储的时间信息"><a href="#CMOS-RAM中存储的时间信息" class="headerlink" title="CMOS RAM中存储的时间信息"></a>CMOS RAM中存储的时间信息</h3><p>在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。这6个信息的长度为1个字节。这些数据以BCD码的方式存放。</p>
<table>
<thead>
<tr>
<th>存放单元</th>
<th>0</th>
<th>2</th>
<th>4</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>秒</td>
<td>分</td>
<td>时</td>
<td>日</td>
<td>月</td>
<td>年</td>
</tr>
</tbody></table>
<p>CMOS RAM储存时间信息的单元中，储存了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。如00010100b表示14。</p>
<p><strong>实战</strong> :</p>
<p>编程：在屏幕中显示当前的月份</p>
<p>分析：这个程序主要做一下两个部分工作：</p>
<ul>
<li>从CMOS RAM的8号单元中读出当前月的BCD码<ul>
<li><ol>
<li>向地址端口70h写入要访问的单元的地址<br><code>mov al,8; out 70h,al</code></li>
</ol>
</li>
<li><ol start="2">
<li>从数据端口71h中取得指定单元中的数据<br><code>in al,71h</code></li>
</ol>
</li>
</ul>
</li>
<li>将用BCD码表示的月份用十进制的形式显示<ul>
<li>因为BCD码值=十进制码值，则BCD码值+30h=十进制对应的ASCII码</li>
<li>从CMOS RAM的8号内存单元读出的一个字节中，包含了用两个BCD码表示的两位十进制数，高4位为十为，低4位为个位<ul>
<li>取出这两个BCD码<br><code>mov ah,al</code><br><code>cl,4</code>  移位数<br><code>shr ah,cl</code>         ah中为月份的十位<br><code>and al,00001111b</code>  al中为月份的个位数</li>
<li>显示(ah)+30h和(al)+30h对应的ASCII码字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>完整程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  mov al,8</span><br><span class="line">        out 70h,al</span><br><span class="line">        in al,71h</span><br><span class="line"></span><br><span class="line">        mov ah,al</span><br><span class="line">        mov cl,4</span><br><span class="line">        shr ah,cl</span><br><span class="line">        and al,00001111b</span><br><span class="line"></span><br><span class="line">        add ah,30h</span><br><span class="line">        add al,30h</span><br><span class="line"></span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov byte ptr es:[160*12+40*2],ah        ;显示月份的十位数码</span><br><span class="line">        mov byte ptr es:[160*12+40*2+2],al      ;接着显示月份的个位数码</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h2 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h2><p>要及时处理外设的输入，显然需要解决两个问题：</p>
<ul>
<li>外设的输入随时可能发生，CPU如何得知？</li>
<li>CPU从何处得到外设的输入？</li>
</ul>
<h3 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a>接口芯片和端口</h3><p>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中;CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。CPU还可以向外设输出控制命令，而这些命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设设施控制。</p>
<h3 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h3><p>外设的输入随时可能发生，CPU如何得知？</p>
<ul>
<li>当CPU外部需要处理的事情发生时，相关的芯片将向CPU发出相应的中断信息，引发中断过程。</li>
</ul>
<p>在PC系统中，外中断源一共有以下两类：</p>
<ul>
<li>可屏蔽中断<ul>
<li>可屏蔽中断是CPU可以不响应的外中断</li>
<li>CPU是否响应可屏蔽中断看标志寄存器IF位的设置，IF=1则响应</li>
<li><code>sti</code>设置IF=1</li>
<li><code>cti</code>设置IF=0</li>
</ul>
</li>
<li>不可屏蔽中断<ul>
<li>不可屏蔽中断的中断类型码固定为2</li>
</ul>
</li>
</ul>
<h3 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h3><ul>
<li><ol>
<li>键盘输入<ul>
<li>键盘上每个键相当于一个开关，键盘中有一个芯片对键盘上每个键的开关状态进行扫描</li>
<li>按下一个键，开关接通，芯片产生一个能说明按下键的位置的扫描码。扫描码送入主板上相关接口芯片的寄存器中，该寄存器的端口地址为60h</li>
<li>松开按键时也会产生扫描码，也被送入60h端口</li>
<li>一般称按下产生的扫描码为通码，松开产生的扫描码为断码，通码的第7位为0，断码的第7位为1，即：<ul>
<li><strong>断码=通码+80h</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>引发9号中断<ul>
<li>键盘输入到达60h端口时，相关的芯片就会向CPU发出中断类型为9的可屏蔽中断信息</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>执行int 9中断例程<ul>
<li>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="编写int-9中断例程"><a href="#编写int-9中断例程" class="headerlink" title="编写int 9中断例程"></a>编写int 9中断例程</h3><p>键盘输入的处理过程：</p>
<ul>
<li><ol>
<li>键盘产生扫描码</li>
</ol>
</li>
<li><ol start="2">
<li>扫描码送入60h端口</li>
</ol>
</li>
<li><ol start="3">
<li>引发9号中断</li>
</ol>
</li>
<li><ol start="4">
<li>CPU执行int 9中断例程处理键盘输入<ul>
<li>从端口60h读入输入：<code>in al,60h</code></li>
<li>调用BIOS的int 9中断例程</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>BIOS提供的int 9中断例程已经对一些硬件细节进行了处理，我们只要在自己编写的中断例程中调用BIOS的int 9中断例程就可以自定义操作了。</p>
<p>编程：在屏幕中间依次显示a～z，按下Esc后改变显示的颜色</p>
<ul>
<li>首先为了能够看清，应该在显示一个字母后延时一段时间</li>
<li>将我们自己写的9号中断写入向量表，同时保存BIOS的int 9中断例程，以便之后调用<ul>
<li>这里将原来的int 9中断例程的偏移地址和段地址保存在ds:[0]和ds:[2]单元中</li>
</ul>
</li>
<li>模拟int来实现对我们写的新中断例程进行调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line"></span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        push es:[9*4]</span><br><span class="line">        pop ds:[0]</span><br><span class="line">        push es:[9*4+2]</span><br><span class="line">        pop ds:[2]          ;将原来的int 9中断例程的入口地址保存在ds:0和ds:2单元中</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov ah,&#39;a&#39;</span><br><span class="line">s:      mov es:[160*12+40*2] ;显示</span><br><span class="line">        call delay</span><br><span class="line">        inc ah</span><br><span class="line">        cmp ah,&#39;z&#39;</span><br><span class="line">        jna s</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        push ds:[0]</span><br><span class="line">        pop es:[9*4]</span><br><span class="line">        push ds:[2]</span><br><span class="line">        pop es:[9*4+2]      ;将中断向量表中的int 9中断例程的入口地址恢复为原来的地址</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">delay:  push ax</span><br><span class="line">        push dx</span><br><span class="line">        mov dx,1000h</span><br><span class="line">        mov ax,0</span><br><span class="line">s1:     sub ax,1</span><br><span class="line">        sbb dx,0</span><br><span class="line">        cmp ax,0</span><br><span class="line">        jne s1</span><br><span class="line">        cmp dx,0</span><br><span class="line">        jne s1</span><br><span class="line">        pop dx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br><span class="line">; -------新int 9中断例程--------</span><br><span class="line">int9:   push ax</span><br><span class="line">        push bx</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">        in al,60h</span><br><span class="line"></span><br><span class="line">        pushf</span><br><span class="line">        pushf</span><br><span class="line">        pop bx</span><br><span class="line">        and bh,111111100b</span><br><span class="line">        push bx</span><br><span class="line">        popf</span><br><span class="line">        call dword ptr ds:[0]   ;对int指令进行模拟，调用原来的int 9中断例程</span><br><span class="line"></span><br><span class="line">        cmp al,1</span><br><span class="line">        jne int9ret</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        inc byte ptr es:[160*12+40*2+1] ;段地址控制的文本显示的信息，改变颜色</span><br><span class="line"></span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line">code ens</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h2 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h2><h3 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h3><p>之前的程序中，标号仅仅表示了内存单元的地址。但是我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示此单元是一个字节单元，还是双字单元。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    a db 1, 2, 3, 4, 5, 6, 7, 8         ;a、b后面没有&quot;:&quot;，它们是同时描述内存地址和单元长度的标号</span><br><span class="line">    b dw 0                              ;标号a描述了地址code:0，以后的单元都是字节单元;标号b表述了地址code:8，以后的字单元</span><br><span class="line"></span><br><span class="line">start:  mov si,0</span><br><span class="line">        mov cx,8</span><br><span class="line">s:      mov al,a[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add b,ax</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>因此这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。对于程序中的<code>b dw 0</code></p>
<ul>
<li>指令：<code>mov ax,b</code>相当于：<code>mov ax,cs:[8]</code></li>
<li>指令：<code>mov b,2</code>相当于：<code>mov word ptr cs:[8],2</code></li>
<li>指令：<code>inc b</code>相当于：<code>inc word ptr cs:[8]</code></li>
</ul>
<p>使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。我们称这种标号为数据标号。</p>
<h3 id="在其他段中使用数据标号"><a href="#在其他段中使用数据标号" class="headerlink" title="在其他段中使用数据标号"></a>在其他段中使用数据标号</h3><p>下面程序将data段中a标号处8个数据累加，结果储存在b中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">    a db 1, 2, 3, 4, 5, 6, 7, 8         </span><br><span class="line">    b dw 0                              </span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,8</span><br><span class="line">s:      mov al,a[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add b,ax</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：后面加有”:”的地址标号只能在代码段中使用，不能在其他代码段中使用。</li>
<li>如果想在代码段中直接使用数据标号访问数据，则需要用伪命令assume将标号所在的段和一个段寄存器联系起来<ul>
<li>只是编译器的工作需要，类系c语言中要有函数原型，assume并没有将段寄存器和某个段相联系</li>
<li>我们在程序中还要使用指令对寄存器进行设置</li>
</ul>
</li>
</ul>
<p>对于这个程序，编译器对相关指令的编译如下：</p>
<ul>
<li>指令：<code>mov al,a[si]</code>，编译为<code>mov al,ds:[si+0]</code></li>
<li>指令：<code>mov b,ax</code>，编译为<code>mov ds:[8],ax</code></li>
<li>在执行这些指令前，ds必须为data的段地址<code>mov ax,data;mov ds,ax</code></li>
</ul>
<h3 id="直接定址表-1"><a href="#直接定址表-1" class="headerlink" title="直接定址表"></a>直接定址表</h3><p>我们希望对数据建立某种映射关系，如果我们直接使用条件判断语句明显是可行的。但程序将要执行多条比较、转移指令。程序混乱。</p>
<p>因此我们可以建立一张表。假设我们要一次储存字符”0”<del>“F”，我们可以通过0</del>15直接查找对应字符。使用如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table db &#39;0123456789ABCDE&#39;</span><br><span class="line"></span><br><span class="line">mov ah,table[bx]</span><br><span class="line">等等</span><br></pre></td></tr></table></figure>

<p>以数值N为table表中的偏移，可以找到对应的字符</p>
<p>利用表，两个数据集合之间建立了一种映射关系，使我们可以用查表的方法根据给出的数据的到其在另一个集合中的对应数据。这样做的目的一般有以下3个：</p>
<ul>
<li>为了算法的清晰和简洁</li>
<li>为了加快运算速度<ul>
<li>如我们可以直接保存常见的三角函数，而不必计算</li>
</ul>
</li>
<li>为了使程序易于扩充</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>seg操作符，功能为取得某一标号的段地址</li>
<li>lea操作符，是mov的变种，功能为取有效地址(Load effect address)，即取偏移地址<ul>
<li>格式: lea 目的,源</li>
<li>leaw，两个字节</li>
<li>leal，4个字节</li>
<li>leaq，8个字节</li>
</ul>
</li>
<li>leave操作符，功能为将寄存器ebp(保留栈底指针)的内容复制到esp(保留栈顶指针)中，然后从栈中恢复ebp寄存器的旧值</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/universe/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/04/universe/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6/" class="post-title-link" itemprop="url">密码学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-04T00:00:00+08:00">2020-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-06 21:19:47" itemprop="dateModified" datetime="2020-05-06T21:19:47+08:00">2020-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="密码学和数据安全导论"><a href="#密码学和数据安全导论" class="headerlink" title="密码学和数据安全导论"></a>密码学和数据安全导论</h2><p>可靠的密码体制必须遵守Auguste Kerekhoffs在1883年提出的一个假说，即Kerekhoffs原理:</p>
<blockquote>
<p>即使密钥外的整个系统的一切都是公开的，这个密码体制也必须是安全的。尤其是即使攻击者知道系统的加密算法和解密算法，此系统也必须是安全的。</p>
</blockquote>
<p>需要强调的是，设计上一个隐藏细节的系统看似是更安全的。但是历史经验告诉我们这样的系统其实是很脆弱的，系统的细节可以通过逆向工程破解。这就是说为什么即使攻击者知道加密算法，加密方案仍必须保持安全的原因。</p>
<h3 id="模运算与多种古典密码"><a href="#模运算与多种古典密码" class="headerlink" title="模运算与多种古典密码"></a>模运算与多种古典密码</h3><h4 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h4><p>几乎所有的加密算法都是基于有限个元素的运算。模运算就是在有限个数集中执行运算的简单方法：</p>
<p>定义：模运算</p>
<blockquote>
<p>假设$a, r, m \in Z$(其中Z是所有整数的集合)，并且m&gt;0。如果m除a-r，可记作：<br>$$a \equiv r \bmod m$$<br>其中m称为模数，r称为余数</p>
</blockquote>
<blockquote>
<p>其中$a \equiv b (\bmod m)$表示a与b对于m同余</p>
</blockquote>
<h5 id="等价类中所有成员的等价行为"><a href="#等价类中所有成员的等价行为" class="headerlink" title="等价类中所有成员的等价行为"></a>等价类中所有成员的等价行为</h5><p>对于一个给定模数m，选择等价类中任何一个元素用于计算的结果都是一样的。因此我们可以选择等价类中最易于计算的一个元素进行模运算</p>
<p>计算$3^8$模7的的结果：</p>
<ul>
<li>$3^8 = 6561 \equiv 2 \bmod 7$</li>
<li>下面使用等价类进行计算<br>$$3^8 = 3^4 \cdot 3^4 = 81 \cdot 81$$</li>
<li>然后将中间结果的81替换为同一等价类中的其他元素。在模数7的等价类中，最小的正元素是4(因为$81 = 11 \cdot 7 + 4$)，因此：<br>$$3^8 = 3^4 \cdot 3^4 \equiv 4 \cdot 4 \equiv 16 \bmod 7 \equiv 2 \bmod 7$$</li>
</ul>
<p>通用的规则是：应该尽量使用模化简，使计算的数值尽可能小，这样做总是极具计算优势</p>
<h4 id="整数环"><a href="#整数环" class="headerlink" title="整数环"></a>整数环</h4><p>定义：环</p>
<blockquote>
<p>整数环$Z_m$由以下两部分组成：</p>
<ul>
<li><ol>
<li>集合$Z_m = (0, 1, 2, …, m-1)$</li>
</ol>
</li>
<li><ol start="2">
<li>两种操作”+”和”×”，使得所有的$a, b \in Z_m$有<ul>
<li>1)$a + b \equiv c \bmod m, (c \in Z_m)$</li>
<li>2)$a \times b \equiv d \bmod m, (d \in Z_m)$</li>
</ul>
</li>
</ol>
</li>
</ul>
</blockquote>
<p>环具有以下特征：</p>
<ul>
<li>如果环内任何两个数相加或相乘得到的结果始终在环内，那么这个环是封闭的</li>
<li>加法和乘法是可结合的，例如对所有的$a, b, c \in Z_m$，都有$a + (b+c) = (a+b) + c$和$a \cdot (b \cdot c) = (a \cdot b) \cdot c$</li>
<li>加法中存在中性元素0，使得对每个$a \in Z_m$都有$a + 0 \equiv a \bmod m$</li>
<li>环中的任何元素a都存在一个负元素-a，使得$a + (-a) \equiv 0 \bmod m$，即加法逆元始终存在</li>
<li>乘法中存在中性元素1，使得对每个$a \in Z_m$都有$a \times 1 \equiv a \bmod m$</li>
<li>不是所有元素都存在乘法逆元，假设$a \in Z$，乘法逆元$a^{-1}$可以定义为：<br>$$a \times a^{-1} = 1 \mod m$$<br>如果某个元素的乘法逆元存在，则可以除以这个元素，因为$b/a \equiv b \cdot a^{-1} \bmod m$</li>
<li>寻找逆元比较困难，可以通过一种简单的方法判断一个元素a的逆元是否存在：<ul>
<li>当且仅当$gcd(a, m) = 1$，一个元素$a \in Z$存在乘法逆元$a^{01}$，其中gcd表示最大公约数(Greatest Common divisor)，$gcd(a, m) = 1$就表示a和m(模数)互质</li>
</ul>
</li>
</ul>
<h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><p>仿射密码是一种改善的移位密码，仿射密码的思路是将明文密码乘以密钥的一部分，然后再加上密钥的剩余部分</p>
<p>定义：仿射加密</p>
<blockquote>
<p>假设$x, y ,a, b \in Z_26$(26个字母)</p>
<p>加密：$e_k(x) = y \equiv a \cdot x + b \bmod 26$</p>
<p>解密：$d_k(y) = x \equiv a^{-1} \cdot (y-b) \bmod 26$</p>
<p>密钥为：$k = (a, b)$，且满足限制条件gcd(a, 26)=1</p>
</blockquote>
<p>gcd(a, 26)=1 这个限制是源于这样一个事实：加密时需要求密钥参数a的逆元。</p>
<p>通过尝试所有$a^{-1}$的可能值，直到$a \cdot a^{-1} \equiv 1 \bmod 26$即可得到逆元</p>
<p>因此仿射加密的确比移位加密复杂，但也是可暴力破解的<br>$$密钥空间 = (a的可能值) \times (b的可能值)$$</p>
<h2 id="序列密码"><a href="#序列密码" class="headerlink" title="序列密码"></a>序列密码</h2><p>对称密码学分成分组密码和序列密码两部分</p>
<ul>
<li>序列密码<ul>
<li>单独加密每个位</li>
</ul>
</li>
<li>分组密码<ul>
<li>每次使用相同的密钥加密整个明文位分组</li>
</ul>
</li>
</ul>
<h3 id="序列密码加密与解密"><a href="#序列密码加密与解密" class="headerlink" title="序列密码加密与解密"></a>序列密码加密与解密</h3><p>定义：序列密码</p>
<blockquote>
<p>明文、密文和密钥序列都是由单独的位组成，即$x_i, y_i, s_i \in {0, 1}$</p>
<p>加密：$y_i \equiv x_i + s_i \bmod 2$</p>
<p>解密：$x_i \equiv y_i + s_i \bmod 2$</p>
</blockquote>
<p>加密解密推导：加密和解密用的是相同的函数</p>
<p>$$\begin{aligned}<br>d(y_i) &amp;\equiv y_i + s_i \bmod 2 \<br>&amp;\equiv x_i + s_i + s_i \bmod 2 \<br>&amp;\equiv x_i + 2s_i \bmod 2 \<br>&amp;\equiv x_i + 0 \bmod 2 \<br>&amp;\equiv x_i \bmod 2 \<br>\end{aligned}$$</p>
<p>下面给出模2加法的真值表</p>
<table>
<thead>
<tr>
<th>$x_i$</th>
<th>$s_i$</th>
<th>$y_i \equiv x_i + s_i \bmod 2$</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>事实上模2加法与异或XOR是等价的，密文为0或1的概率是完全相等的</p>
<p>密钥序列$s_1, s_2, …,s_i$是序列密码安全的核心问题，在攻击者看来$s_i$必须的随机的</p>
<h3 id="随机数与牢不可破的分组密码"><a href="#随机数与牢不可破的分组密码" class="headerlink" title="随机数与牢不可破的分组密码"></a>随机数与牢不可破的分组密码</h3><h4 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h4><ul>
<li>真随机数生成器(TRNG)<ul>
<li>TRNG的突出特征是它是输出是不可复制的<ul>
<li>如拋100次硬币，世界上另一个人抛出和我相同的结果概率很低</li>
</ul>
</li>
<li>TRNG都是基于物理过程，主要例子包括抛硬币等</li>
</ul>
</li>
<li>(通用的)伪随机数生成器(PRNG)<ul>
<li>PRNG从一个初始种子值开始通过各种计算得到序列</li>
<li>PRNG并不是真正意义上的随机，因为它们是可以算出来的</li>
<li>对PRNG的一个一般要求是：必须有良好的统计属性<ul>
<li>即它的输出与真随机数序列相同</li>
</ul>
</li>
</ul>
</li>
<li>加密安全的伪随机数生成器(CSPRNG)<ul>
<li>是一种不可预测的PRNG，即计算后续位在计算上是不可行的</li>
</ul>
</li>
</ul>
<h4 id="一次一密"><a href="#一次一密" class="headerlink" title="一次一密"></a>一次一密</h4><p>一个完美的密钥应该具有的特征：无条件安全。定义如下</p>
<blockquote>
<p>如果一个密码体制在无限计算资源的情况下也不能被破译，则说明它是无条件安全的或信息论上安全的</p>
</blockquote>
<p>一下是个简单的无条件安全的密码，这个密码是<strong>一次一密(OTP)</strong>，定义如下</p>
<blockquote>
<p>一个序列密码成为一次一密，必须满足一下条件：</p>
<ul>
<li><ol>
<li>通过真随机数生成器得到密钥序列$s_1, s_2, …$</li>
</ol>
</li>
<li><ol start="2">
<li>只有合法的通信方才知道密钥序列</li>
</ol>
</li>
<li><ol start="3">
<li>每个密钥序列位$s_i$仅使用一次<br>一次一密是无条件安全的</li>
</ol>
</li>
</ul>
</blockquote>
<p>证明OTP是无条件安全的方法如下</p>
<p>$$\begin{aligned}<br>y_0 &amp;\equiv x_0 + s_0 \bmod 2 \<br>y_1 &amp;\equiv x_1 + s_1 \bmod 2 \<br>…<br>\end{aligned}$$</p>
<p>每个单独的关系都是有两个未知数的线性等式模2,它们无法求解</p>
<p>OTP缺点如下，导致它在实际中很少使用：</p>
<ul>
<li>需要真随机数生成器</li>
<li>每个密钥序列使用一次，需要多次交换密钥序列</li>
</ul>
<h4 id="关于实际序列密码"><a href="#关于实际序列密码" class="headerlink" title="关于实际序列密码"></a>关于实际序列密码</h4><p>我们处理实际序列密码的方式就是使用伪随机数生成器(PRNG)代替真随机数生成器。实际上，所有已知的实际加密算法都不是无条件安全的。但是我们可以做到 <strong>计算安全</strong> </p>
<p>定义：计算安全</p>
<blockquote>
<p>如果为破解一个密码体制，最好的一直算法需要至少t个操作，则说明次密码体制是计算安全的</p>
</blockquote>
<p>这个定义看似合理但是存在若干问题。首先人们不知道对应的最好算法是哪一个，因此我们不知道是否存在更强大的攻击。</p>
<h5 id="利用PRNG构建密码流"><a href="#利用PRNG构建密码流" class="headerlink" title="利用PRNG构建密码流"></a>利用PRNG构建密码流</h5><p>虽然PRNG可以用来生成密钥流，但对于序列密码而言都不足够，考虑下面的例子：</p>
<p>假设一个基于线性同余生成器的PRNG：</p>
<p>$$\begin{aligned}<br>S_0 &amp;\equiv  seed \<br>S_{i+1} &amp;\equiv AS_i + B \bmod m, i = 0, 1, … \<br>\end{aligned}$$</p>
<p>设其中选择的m为100位长，$S_i, A, B \in {0, 1, …, m-1}$，我们通过仔细选择这些参数是的此PRNG具有良好的统计属性。密钥包含值(A, B)，可可能包含种子$S_0$，并且每个值的长度都是100，总共密钥长度就为200位。发送方使用一下方式加密：</p>
<p>$$y_i \equiv x_i + s_i \bmod 2$$</p>
<p>其中$s_i$为PRNG输出符号$S_j$的二进制表示的位</p>
<p>攻击者可以轻易发起攻击，如果攻击者知道明文的前300位(通过头文件、常用语等猜出部分明文)。那他可以利用下式计算密钥序列的前300位：</p>
<p>$$s_i \equiv y_i + x_i \bmod m, i = 1, 2, …, 300$$</p>
<p>于是就得到了:$S_1 = {s_1, …, s_{100}}, S_2 = {s_1, …, s_{200}}, S_3 = {s_3, …, s_{300}}$。攻击者现在可以得到两个等式：</p>
<p>$$\begin{aligned}<br>S_2 \equiv AS_1 + B \bmod m \<br>S_3 \equiv AS_2 + B \bmod m<br>\end{aligned}$$</p>
<p>对于一个基于$Z_m$的线性等式系统，拥有两个未知数A，B，我们可以得到：</p>
<p>$$\begin{aligned}<br>A &amp;\equiv (S_2 - S_3)/(S_1 - S_2) \bmod m \<br>B &amp;\equiv S_2 - S_1(S_2 - S_3)/(S_1 - S_2) \bmod m<br>\end{aligned}$$</p>
<p>在$gcd((S_1 - S_2), m) \neq 1$情况下可以得到多个解，如果已知明文的第四片段信息就可以唯一测出密钥。</p>
<p>这种类型的攻击正是发明CSPRNG表示方法的原因</p>
<h5 id="利用CSPRNG构建密钥序列"><a href="#利用CSPRNG构建密钥序列" class="headerlink" title="利用CSPRNG构建密钥序列"></a>利用CSPRNG构建密钥序列</h5><p>CSPRNG可以确保密钥序列是不可预测的，但是相当一部分在密码学之外的伪随机数生成器不是密码学安全的，因此我们需要使用专门的伪随机数生成器来生成密码序列</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/01/universe/vimscript_backup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/universe/vimscript_backup/" class="post-title-link" itemprop="url">vimscript学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-01 00:00:00 / Modified: 11:37:51" itemprop="dateCreated datePublished" datetime="2020-05-01T00:00:00+08:00">2020-05-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Remenber to use <code>:h &lt;arg&gt;</code> for help</p>
<h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><ul>
<li><code>let</code> to init or assignment a variable(call it var below)</li>
<li><code>unlet</code> to delete a var</li>
<li><code>unlet</code> to delete a var and ignore warnning, if var did not exist</li>
</ul>
<p>You can add a prefix before :var to define its scope, like this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g:var  # as global</span><br><span class="line">a:var  # as a function arg</span><br><span class="line">l:var  # as a function var</span><br><span class="line">b:var  # as buffer var</span><br><span class="line">w:var  # as window var</span><br><span class="line">t:var  # as tab var</span><br><span class="line">s:var  # as script var, which useful in this script only</span><br><span class="line">v:var  # as vim build-in var</span><br></pre></td></tr></table></figure>

<h2 id="Data-type"><a href="#Data-type" class="headerlink" title="Data type"></a>Data type</h2><ul>
<li>Number</li>
<li>Float</li>
<li>String</li>
<li>Funcref<ul>
<li>reference of a function</li>
<li><code>let func = function(&quot;strlen&quot;)</code></li>
</ul>
</li>
<li>List</li>
<li>Dictionary</li>
</ul>
<h2 id="String-comparison"><a href="#String-comparison" class="headerlink" title="String comparison"></a>String comparison</h2><ul>
<li><code>&lt;string&gt; == &lt;string&gt;</code> equal</li>
<li><code>&lt;string&gt; != &lt;string&gt;</code> not equal</li>
<li><code>&lt;string&gt; =~ &lt;pattern&gt;</code> matching pattern</li>
<li><code>&lt;string&gt; !~ &lt;pattern&gt;</code> not matching pattern</li>
<li><code>&lt;operator&gt;#</code> matching with case</li>
<li><code>&lt;operator&gt;?</code> matching with ignorecase</li>
</ul>
<p><code>&lt;string&gt;.&lt;string&gt;</code> to connect string</p>
<h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><p><code>If, For, While, Try/Catch</code></p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>Use <code>function</code> keywork to define a function, use <code>function!</code> to overwire a function. Be attention, function need to begin with capital letter.</p>
<ul>
<li><code>delfunction &lt;function&gt;</code> to delete a function</li>
<li><code>call &lt;function&gt;</code> to call a function </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/universe/the_nature_of_code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/14/universe/the_nature_of_code/" class="post-title-link" itemprop="url">用processing模拟自然系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-14T00:00:00+08:00">2020-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-15 12:02:25" itemprop="dateModified" datetime="2020-04-15T12:02:25+08:00">2020-04-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="随机游走"><a href="#随机游走" class="headerlink" title="随机游走"></a>随机游走</h2><ul>
<li>processing中的random()函数生成的随机数是均匀分布的</li>
<li>可以利用random函数生成非均匀分布的随机数<ul>
<li>创建一个非均匀的数组，用random来随机的取索引</li>
</ul>
</li>
<li>也可用random来取概率，但是注意数据类型(float和int有区别)</li>
<li>随机数的正态分布<ul>
<li><code>(float)generator.nextGaussian()</code>返回一个高斯随机数，nextGaussian返回值的类型是double</li>
</ul>
</li>
</ul>
<h3 id="Perlin噪声-一种更平滑的算法"><a href="#Perlin噪声-一种更平滑的算法" class="headerlink" title="Perlin噪声(一种更平滑的算法)"></a>Perlin噪声(一种更平滑的算法)</h3><p>Perlin生成的随机数更平滑，但仍有一定的随机性。</p>
<p>Processing内置了<code>noise()</code>函数，可以有1~3个参数。<br>分别表示一维、二维、三维随机数。</p>
<p>noise函数返回的结果总是在0~1之间，我们可以通过map函数来改变结果的范围，<br>可以吧一维的Perlin噪声当作随着时间推移而发生变化的线性序列。<br>通过往noise传入一个”指定的时间”来获取这个时间点上的噪声。</p>
<p>同理，二维噪声像个崎岖不平的面</p>
<h3 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h3><p><code>map(a, b, c, d)</code>, 原范围(a, b), 希望映射到的范围(c, d)</p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
