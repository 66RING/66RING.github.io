<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Mens et Manus">
<meta property="og:type" content="website">
<meta property="og:title" content="Ring&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Ring&#39;s Blog">
<meta property="og:description" content="Mens et Manus">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Travis TuRing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Ring's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ring's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/10/universe/att_vs_Intel_assembly_language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/universe/att_vs_Intel_assembly_language/" class="post-title-link" itemprop="url">AT&T与Intel汇编语言的比较</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-10T00:00:00+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-15 10:27:35" itemprop="dateModified" datetime="2020-07-15T10:27:35+08:00">2020-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GCC采用的是AT&amp;T的汇编格式，也叫GAS(Gnu Assembler)格式;微软采用Intel的汇编格式</p>
<h2 id="寄存器命名"><a href="#寄存器命名" class="headerlink" title="寄存器命名"></a>寄存器命名</h2><ul>
<li>ATT的汇编格式中，寄存器名前要加上”%”前缀</li>
<li>Inter格式中不用</li>
</ul>
<h2 id="操作数的顺序"><a href="#操作数的顺序" class="headerlink" title="操作数的顺序"></a>操作数的顺序</h2><ul>
<li>ATT目标操作数在源操作数的右边</li>
<li>Intel目标操作数在源操作数的左边</li>
<li>正好相反</li>
</ul>
<table>
<thead>
<tr>
<th>AT&amp;T</th>
<th>Intel</th>
</tr>
</thead>
<tbody><tr>
<td>movl %eax, %abx</td>
<td>mov ebx,eax</td>
</tr>
</tbody></table>
<h2 id="常数-立即数的格式"><a href="#常数-立即数的格式" class="headerlink" title="常数/立即数的格式"></a>常数/立即数的格式</h2><ul>
<li>ATT的汇编格式中，立即数要加上”$”前缀</li>
<li>Inter格式中不用</li>
</ul>
<h2 id="操作符长度标识"><a href="#操作符长度标识" class="headerlink" title="操作符长度标识"></a>操作符长度标识</h2><ul>
<li>ATT汇编格式中操作符的后缀”b”, “w”, “l”分别表示操作数为字节(byte, 8位)、字(word, 16位)、长字(long, 32位)</li>
<li>Intel中操作数长度会根据寄存器长度而定，也可用”byte ptr”、”word ptr”等前缀来表示</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><table>
<thead>
<tr>
<th>AT&amp;T</th>
<th>Intel</th>
</tr>
</thead>
<tbody><tr>
<td>imm32(basepointer,indexpointer,indexscale)</td>
<td>[base+indexpointer*indexscale+imm32]</td>
</tr>
</tbody></table>
<p>两种寻址效果都是：<code>imm32 + basepointer + indexpointer*indexscale</code></p>
<h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><ul>
<li><p>ATT汇编格式中，绝对跳转和调用指令(jump/call)的操作数前要加上”*“作为前缀</p>
<ul>
<li>远程跳转指令和远程子程序调用指令的操作码在ATT中为”ljump”和”lcall”</li>
<li>对应的返回指令为<code>lret</code></li>
</ul>
</li>
<li><p>Intel中不用</p>
<ul>
<li>远程跳转指令和远程子程序调用指令的操作码在Intel中为”jmp far”和”call far”</li>
<li>对应的返回指令为<code>ret</code></li>
</ul>
</li>
<li><p>ATT的汇编格式中，跳转指令有点特殊</p>
<ul>
<li>直接跳转，即跳转目标作为指令的一部分编码，如<code>ljump $a</code></li>
<li>间接跳转，即目标从寄存器或储存器位置中读出的。写法在”*“后面跟一个操作数指示符<ul>
<li><code>ljump *%eax</code>用寄存器%eax中的值作为目标</li>
<li><code>ljump *(%eax)</code>用寄存器%eax中的值作为读入地址，从存储器中读出跳转目标</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/Major/circuit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/Major/circuit/" class="post-title-link" itemprop="url">电路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-07T00:00:00+08:00">2020-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="半导体的工作原理"><a href="#半导体的工作原理" class="headerlink" title="半导体的工作原理"></a>半导体的工作原理</h2><p>半导体的材料一般是电子不多不少(不易获得也不易失去)的，如:硅(4最外层4电子)</p>
<p>电子多，说明核带正电多，对电子吸引力强; 电子少，说明核带正电少，对电子吸引力弱。</p>
<h3 id="晶体二极管"><a href="#晶体二极管" class="headerlink" title="晶体二极管"></a>晶体二极管</h3><p>纯硅电子不易得也不易失，我们称之为 <strong>本征半导体</strong> 。如果我们在硅中加入一点磷(最外层5电子)，则将不是在最外出4电子的基础上多了一个电子。这时这个电子将相对”自由”。这个整体带的电子比稳定的4电子多，我们就叫它N型半导体(Negetive)。</p>
<p>如果我们在本征半导体参入堋(最外层3个电子)，整体将变得渴望1个电子，我们将这个空的地方(为到达4电子)称为空穴。这些空穴有渴望电子的能力。相对4电子结构，空穴是Positive的，因此称为P型半导体。</p>
<p>采用特殊的技术，把P型半导体和N型半导体(P、N整体都是中性，别被PN误导)拼接在一起。那么由于P型半导体的空穴浓度高，N型半导体的空穴浓度低，空穴就会从P扩散到N;同理N型半导体的电子扩散到P型半导体，就像液体中的扩散一样。但扩散不会一直发生，当N中的空穴变多，变得带正电，P中的电子变多，变得带负电，形成电场。</p>
<p>随着电场的形成，电场将试图将P的电子拉到N，随着P的电子减少，电场减弱，扩散又发生，最后扩散和电场达到动态平衡。</p>
<ul>
<li>如果我们向N区通正电，新增的电场与内部的电场方向一致，电场将会变强。虽然仍会处于动态平衡，但是电场抑制了粒子移动，从而阻断电流。</li>
<li>如果我们向P区通整点，N区通负电，将压缩内电场，电子的束缚将变小从而导通电流</li>
<li>于是晶体二极管就诞生了</li>
</ul>
<h3 id="晶体三极管"><a href="#晶体三极管" class="headerlink" title="晶体三极管"></a>晶体三极管</h3><p>晶体三极管结构如下：</p>
<table>
<thead>
<tr>
<th>外</th>
<th>N</th>
<th>P</th>
<th>N</th>
<th>内</th>
</tr>
</thead>
<tbody><tr>
<td>通电电极</td>
<td>+</td>
<td>+</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>位置</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<p>每个PN接触面会形成PN节，一般0.7V的电压会导通PN节。</p>
<p>如果1号位和2号位电压大于0.7V，就通电了。需要注意的是，设计时，1号位故意参杂很多5电子元素，使得电子浓度很高;而2号位的半导体很薄，很难一次消耗掉这些涌入的电子;当2号涌入了很多电子又无法消耗，那么就打破了2号和3号的动态平衡。而且3号设计得很大电子浓度低，2号扩散过来的电子很快会被3号收集。又因为3号通的正电，电子得到了一个快速的泄洪通道，迅速通过电源正极。</p>
<p>这样一来，我们可以认为2号和3号通电了。又因为2号电子来自1号，所以1号也和3号通电了。</p>
<p>2号极小的信号改变就会导致1号电子涌入的巨大变化，从而引起1号与3号之间电流的巨大变化。</p>
<ul>
<li>1号连接负极，称为发射极</li>
<li>2号相当于阀门，操作这原始信号，称为基极</li>
<li>3号收集电子，称为集电极</li>
</ul>
<h3 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管"></a>场效应管</h3><p>将两个N型半导体浸如一个大的P型半导体中，两个N型半导体分别接入正极和负极，P型半导体接入正极，但与正极间隔这一个电容。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>N</th>
<th>P</th>
<th>N</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>通电电极</td>
<td>P</td>
<td>-</td>
<td>+电容</td>
<td>+</td>
<td>P</td>
</tr>
<tr>
<td>位置</td>
<td>P</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>P</td>
</tr>
<tr>
<td></td>
<td>P</td>
<td>P</td>
<td>P</td>
<td>P</td>
<td>P</td>
</tr>
</tbody></table>
<ul>
<li>1号由电源不断提供电子</li>
<li>2号不断吸引电子，但不会快速消耗电子</li>
<li>3号快速消耗电子</li>
</ul>
<p>由于2号电子处聚集了大量电子，3号消耗了很多电子，于是P型半导体由于电子聚集的位置与3号N型半导体由于电子消耗，半导体的类型发生了改变。即2号与3号之间，2号成了N型，3号成了P型，电子将扩散到3号并被快速消耗。又由于1号源源不断提供电子，不断涌向2号。于是1号和3号在2号的控制下形成了通电回路。</p>
<ul>
<li>1号提供电子，称为源极</li>
<li>2号像栅栏一样控制电路导通，称为栅极<ul>
<li>栅极的正负控制这电路的通阻，如果用01表示同断，那么计算机科学就开始了</li>
</ul>
</li>
<li>3号称为漏极</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/universe/Emacs_in_action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/29/universe/Emacs_in_action/" class="post-title-link" itemprop="url">emacs快速入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-29T00:00:00+08:00">2020-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Emacs细节"><a href="#Emacs细节" class="headerlink" title="Emacs细节"></a>Emacs细节</h2><ul>
<li>major mode和minor mode<ul>
<li>打开一个文件时会有默认的mode激活，这个默认的mode就是major mode</li>
<li>minor mode在配置文件中，状态栏不会显示，<code>c-h m</code>显示打开的minor mode</li>
</ul>
</li>
<li>org mode标签TODO/DONE<ul>
<li><code>c-t/c-s</code></li>
</ul>
</li>
</ul>
<h2 id="Emacs基本操作"><a href="#Emacs基本操作" class="headerlink" title="Emacs基本操作"></a>Emacs基本操作</h2><ul>
<li><p>M for meta, Alt or Command(MAC)</p>
</li>
<li><p>S for shift</p>
</li>
<li><p>C for control</p>
</li>
<li><p>s for super</p>
</li>
<li><p>Move</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>c-f</td>
<td>forward</td>
</tr>
<tr>
<td>c-b</td>
<td>backward</td>
</tr>
<tr>
<td>c-p</td>
<td>previous</td>
</tr>
<tr>
<td>c-n</td>
<td>next</td>
</tr>
<tr>
<td>c-a</td>
<td>ahead</td>
</tr>
<tr>
<td>c-e</td>
<td>end</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
<li><p>Action</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>c-w</td>
<td>cut</td>
</tr>
<tr>
<td>m-w</td>
<td>copy</td>
</tr>
<tr>
<td>c-y</td>
<td>yank(paste)</td>
</tr>
<tr>
<td>m-&lt;</td>
<td>begin of file</td>
</tr>
<tr>
<td>m-&gt;</td>
<td>end of file</td>
</tr>
<tr>
<td>c-k</td>
<td>del to end of line(kill)</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
<li><p>Edit</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>C-g</td>
<td>中断所有操作</td>
</tr>
<tr>
<td>C-x C-f</td>
<td>打开文件</td>
</tr>
<tr>
<td>C-x C-s</td>
<td>save</td>
</tr>
<tr>
<td>C-h key/var/func</td>
<td>help for key/var/func</td>
</tr>
<tr>
<td>C-x C-e</td>
<td>执行表达式，根据括号范围决定运行的指令</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
<li><p>Search</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>c-s</td>
<td>search below</td>
</tr>
<tr>
<td>c-r</td>
<td>search above</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="Elisp"><a href="#Elisp" class="headerlink" title="Elisp"></a>Elisp</h2><p>括号括起来是表达式，表达式第一个参数是函数，后面是参数。如</p>
<ul>
<li><code>(+ 2 2)</code>，+的函数，结果是2+2</li>
</ul>
<p>括号也起到了代码块的作用</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(setq var [value])</td>
<td>定义变量（赋值）</td>
</tr>
<tr>
<td>(message var)</td>
<td>格式化输出，同C</td>
</tr>
<tr>
<td>(defun func)</td>
<td>定义函数</td>
</tr>
<tr>
<td>(interactive)</td>
<td>声明函数是交互式的函数，<M-x>可以找到这个函数</td>
</tr>
<tr>
<td>(global-set-ket (kbd “<key>“) ‘func)</td>
<td>定义快捷键</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/universe/hacker_in_action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/universe/hacker_in_action/" class="post-title-link" itemprop="url">黑客攻防学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-21T00:00:00+08:00">2020-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前置知识：汇编语言</p>
<h1 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h1><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>缓冲区是一片有限的、连续的内存区域。在C语言中最常见的缓冲区是数组。</p>
<p>因为在C和C++语言中没有考虑检查缓冲区的内在边界，所以使栈溢出成为可能。当输入的数据足够大时，将会溢出缓冲区的范围，从而改写从而改写其他缓存区域。</p>
<h3 id="函数与栈"><a href="#函数与栈" class="headerlink" title="函数与栈"></a>函数与栈</h3><p>调用函数的整个过程如下</p>
<ul>
<li><ol>
<li>把函数的参数压入栈</li>
</ol>
</li>
<li><ol start="2">
<li>把函数的返回地址压入栈<ul>
<li>主程序调用子程序，子程序结束后继续上次的位置执行主程序</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>调用函数</li>
</ol>
</li>
</ul>
<p>为了使函数可以引用栈上的数据，必须改变栈底指针EBP的值，把EBP的当前值压入栈，把当前的栈顶ESP复制到EBP，函数接受后再恢复。这样我们就可以方便地引用栈地址了。</p>
<p>接着编译器计算函数的局部变量所需的地址空间和栈上的保留空间，然后从ESP减去变量的大小，为程序保留必要的空间，最后把函数的局部变量压入栈(这我们举例：数组)。结构如下：</p>
<table>
<thead>
<tr>
<th>低内存地址，栈顶</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
</tr>
<tr>
<td>EBP</td>
</tr>
<tr>
<td>RET</td>
</tr>
<tr>
<td>参数</td>
</tr>
<tr>
<td>高内存地址，栈底</td>
</tr>
</tbody></table>
<h3 id="栈上的缓冲区溢出"><a href="#栈上的缓冲区溢出" class="headerlink" title="栈上的缓冲区溢出"></a>栈上的缓冲区溢出</h3><p>由上述结构可见，如果数组很大，将会溢出，然后改写其他缓存区域。</p>
<ul>
<li>控制EIP<ul>
<li>CPU执行什么指令由CS:IP的指向决定</li>
<li>我们只要精心设计溢出的数据，这些地址将写入缓冲器并改写保留在缓冲区的EBP和RET。当系统从栈中取出RET的值并放入EIP时，这个地址指向的指令将被执行。</li>
</ul>
</li>
</ul>
<h3 id="利用漏洞获得root权限"><a href="#利用漏洞获得root权限" class="headerlink" title="利用漏洞获得root权限"></a>利用漏洞获得root权限</h3><p>我们可以攻击以root权限运行的进程，通过溢出强制它执行shell，这个shell将继承root权限。然而缓冲区只认得机器指令(opcode)。为了把opcode插入缓存区，必须吧派生的shell的C代码编译成汇编指令，然后从可读的汇编指令中提取opcode。这些被称为shellcode或opcode的代码可以注入缓冲区，并可执行。</p>
<h4 id="地址问题"><a href="#地址问题" class="headerlink" title="地址问题"></a>地址问题</h4><p>当试图执行用户提交的shellcode时，所面临的问题是找出shellcode的起始地址。(想办法使EIP指向这个地址)</p>
<p>先介绍一种使用最广的方法：猜。每个程序的栈都以同样的地址开始。(现在大多数操作系统故意变化栈地址，从而使这类的攻击变得困难)知道这个地址就可以猜测shellcode的起始地址和RET的地址。</p>
<ul>
<li>首先要知道ESP的地址，那么根据这个地址来猜测当前地址和shellcode之间的偏移距离。从而的到shellcode的起始地址</li>
<li>通过尝试输入过长数据造成溢出，从造成故障的长度来猜测RET地址</li>
<li>最后把RET地址改为shellcode的起始地址以达到执行shellcode的目的</li>
</ul>
<p><strong>例1</strong> ：简单试炼，破解以下程序，假设我们不知道被攻击程序的内部结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// victim.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="built_in">array</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果每个程序的栈都是以同样的地址开始，则固定的程序RET地址不会改变，我们可以通过溢出找出RET地址<ul>
<li><code>$ ./victim.c $(printf &quot;%0524&quot; 0)</code>利用bash快速尝试输入多个0(长数据)</li>
</ul>
</li>
<li>假设我们的shellcode有40B，上一步在524个数据时溢出，那么我们可以将上一步的长数据改成<code>shellcode+(524-len(shellcode))个0+shellcode起始地址</code><ul>
<li>这里还没获得shellcode起始地址，我们先用别的地址测试填充0的个数是否正确</li>
</ul>
</li>
</ul>
<p>building…</p>
<h4 id="NOP法"><a href="#NOP法" class="headerlink" title="NOP法"></a>NOP法</h4><p>一个个猜太过麻烦，可以选用NOP法来增加潜在的偏移量的数量。思路就是创建一大段不运行的指令区，放在shellcode前面，当执行完NOP之后，就会执行shellcode。这样就不用精确地猜到偏移量了。</p>
<h3 id="战胜不可执行栈"><a href="#战胜不可执行栈" class="headerlink" title="战胜不可执行栈"></a>战胜不可执行栈</h3><p>前面所讲的漏洞利用程序能工作，是因为可以在栈上执行指令。许多操作系统不允许在栈上执行代码。当遇到不可执行栈的时候，可以用”返回libc”方法。</p>
<p>栈溢出原理上其实是利用了EIP指针，那么如果我们可以完全EIP指针，那么就可以把任意想执行的代码放入EIP。返回libc是把控制权交给特定的动态库函数。动态库函数不在栈上，所以我们就可以绕开不可执行栈的限制。</p>
<p>为了攻击成功，需要仔细挑选动态库函数。理论上，它必须符合以下两个条件：</p>
<ul>
<li>它必须的常见的动态库函数，在绝大多数程序中出现，才便于利用</li>
<li>函数库里的函数应该给予我们很大的灵活性，以便我们能派生shell或做其他事</li>
</ul>
<p>libc就是满足条件的一个库函数。我们只要把执行流程指向想用的库函数的地址，它将被执行。</p>
<p>以下以派生shell讨论。最好用的libc函数是system()。system()接受一个参数，然后用/bin/sh/执行这个参数。根据经验主程序执行一个函数(设为func)时，参数入栈的顺序和它在代码里的顺序相反，根据这点，我们需要进行以下工作：</p>
<ul>
<li>确定system()地址<ul>
<li>主程序执行一个函数func时，call func，会把返回地址RET压入栈</li>
</ul>
</li>
<li>确定/bin/sh地址(参数地址)<ul>
<li>第一个参数位于RET之后</li>
</ul>
</li>
<li>找出exit()地址，以便干净地退出被攻击的程序</li>
</ul>
<p>用memfetch工具可以找到/bin/sh的地址，memfetch的功能是把指定进程的内存数据全部转存到一个二进制文件中，我们可以在这个文件里找/bin/sh的地址</p>
<p>破解过程如下：</p>
<ul>
<li><ol>
<li>用垃圾数据填满缓冲区和返回地址之间的空间</li>
</ol>
</li>
<li><ol start="2">
<li>用system()的地址改写返回地址</li>
</ol>
</li>
<li><ol start="3">
<li>在system()后加上exit()的地址</li>
</ol>
</li>
<li><ol start="4">
<li>再加上/bin/sh的地址</li>
</ol>
</li>
</ul>
<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>shellcode是一组可注入(机械码)的程序，可以在被攻击的程序里运行。因为shellcode要直接操作寄存器和程序的函数，所以通常用汇编语言编写并翻译为十六进制操作码。之所以叫shellcode是因为通常用这种操作来派生root权限的shell。</p>
<h3 id="理解系统调用"><a href="#理解系统调用" class="headerlink" title="理解系统调用"></a>理解系统调用</h3><p>我们想让目标程序不同于设计者预期的方式运行，而操纵程序的方法之一是强制它产生系统调用(中断)。可以通过系统调用访问特定的操作系统的函数，如接受输入、处理输出、退出进程、执行二进制文件等。</p>
<p>通过系统调用可以直接访问系统内核，即可以访问读写文件之类的低级函数。系统调用也是受保护的内核模式与用户模式之间的接口。受保护的内核模式会阻止用户的应用程序干涉或危及操作系统。当用户模式下的程序企图访问内核的内存空间时，系统将产生异常。但是，某些程序在正常运行时，需要请求一些系统级的服务，这时系统调用就作为正常用户模式和内核模式之间的接口，在保证安全的情况下尽量相应这些请求。</p>
<p>在Linux里有两种方法来执行系统调用：</p>
<ul>
<li>间接方法：C库函数(libc)</li>
<li>直接方法：汇编指令(把适当的参数加载到寄存器，然后调用中断)执行系统调用</li>
</ul>
<p>在Linux里，程序通过<code>int 0x80</code>软中断来执行系统调用。当程序在用户模式下执行<code>int 0x80</code>时，CPU切换到内核模式并执行相应的系统调用。系统调用的过程如下：</p>
<ul>
<li><ol>
<li>把系统调用编号载入EAX，通过载入编号来调用对应系统函数</li>
</ol>
</li>
<li><ol start="2">
<li>把系统调用的参数压入其它寄存器</li>
</ol>
</li>
<li><ol start="3">
<li>执行<code>int 0x80</code>指令</li>
</ol>
</li>
<li><ol start="4">
<li>CPU切换到内核模式</li>
</ol>
</li>
<li><ol start="5">
<li>执行系统函数</li>
</ol>
</li>
</ul>
<p>思考下列程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -static -o exit exit.c</span></span><br></pre></td></tr></table></figure>

<p>反汇编生成的二进制文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gdb exit</span><br><span class="line">(gdb) disas _exit</span><br><span class="line">address &lt;line&gt;: mov 0x4(%esp,1),%ebx</span><br><span class="line">address &lt;line&gt;: mov $Oxfc,%eax          ;对应的系统调用编号被放入%EAX中</span><br><span class="line">address &lt;line&gt;: int $0x80               ;通过int 0x80指令得知发生了系统调用</span><br><span class="line">address &lt;line&gt;: mov $0x1,%eax           ;对应的系统调用编号被放入%EAX中</span><br><span class="line">address &lt;line&gt;: int $0x80</span><br><span class="line">address &lt;line&gt;: hlt</span><br><span class="line">address &lt;line&gt;: nop</span><br></pre></td></tr></table></figure>

<p>exit()对应的系统调用编号是1，exit_group()对应的系统调用编号是252。在反汇编生成的代码里还有一条指令，它把系统调用的参数加载到EBX。这个参数是0，是在系统调用之前入栈的<code>mov 0x4(%esp,1),%ebx</code></p>
<p><code>int 0x80</code>指令把CPU切换到内核模式，并且执行系统调用</p>
<h3 id="为exit-系统调用写shellcode"><a href="#为exit-系统调用写shellcode" class="headerlink" title="为exit()系统调用写shellcode"></a>为exit()系统调用写shellcode</h3><blockquote>
<p>较小的shellcode可以注入更多的缓冲区，可以用来攻击更多的程序，所以要使shellcode尽量保持简单、紧凑。当攻击问题程序的时候，不仅要把shellcode复制到缓冲区，如果碰到n字节长的缓冲区，不仅要把整个shellcode复制到它里面，还要加上调用shellcode的指令，因此shellcode的长度必须小于n。基于这个原因，shellcode应尽量小。</p>
</blockquote>
<p>因为实际环境中，shellcode没有其他指令为它设置参数，所以我们要精心设计。在上面exit()例子里，通过把0放入EBX可以达到设置的目的。所以我们的shellcode应该完成以下任务：</p>
<ul>
<li><ol>
<li>把0存到EBX<ul>
<li>参数</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>把1存到EAX<ul>
<li>系统调用编号</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>执行<code>int 0x80</code>指令来产生系统调用</li>
</ol>
</li>
</ul>
<p>先用汇编指令实现这3步，的到ELF格式的二进制文件，然后从这个二进制文件中提取操作码。</p>
<ul>
<li>生成目标文件</li>
<li>链接目标文件</li>
<li>从生成的文件提取操作码</li>
</ul>
<h3 id="可注入的shellcode"><a href="#可注入的shellcode" class="headerlink" title="可注入的shellcode"></a>可注入的shellcode</h3><p>攻击时，最有可能用来保存shellcode的内存区域是为了保存用户输入而分配的缓冲区，甚至可以更进一步将，这个缓冲区就是一个数组。所以如果shellcode中有空值(0x00)的存在，当把shellcode复制到缓冲区(字符数组)的时候会出现异常，因为数组里空值是用来终止字符串的。所以我们要想办法把空值去掉，或把有空值的操作码转换成非空值的操作码。下面介绍一种方法：</p>
<ul>
<li>直接用其他具有相同功能的指令代替这些产生空值的指令</li>
</ul>
<p>如果直译，shellcode使用如下汇编指令和对应的操作码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,0       ;\xbb\x00\x00\x00\x00</span><br><span class="line">mov eax,1       ;\xb8\x00\x00\x00\x00</span><br><span class="line">int 0x80        ;\xcd\x80</span><br></pre></td></tr></table></figure>

<p>头两条是产生空值的罪魁祸首，我们可以用如下操作解决：</p>
<ul>
<li>第一条指令，我们可以用<code>xor</code>指令在不涉及空值的情况下给ebx赋值<ul>
<li><code>xor ebx ebx</code>，效果：ebx = ebx XOR ebx = 0000</li>
</ul>
</li>
<li>第二条指令汇编指令看似没有0的参与，为什么会出现空值呢？<ul>
<li>因为：这条指令使用了4B寄存器(EAX)，而我们复制了1B(1)到寄存器，默认情况下系统会自动用控制填充剩下部分</li>
<li>4B的EAX可以划分为2个2B(AX)和4个1B(AL、AH)，所以我们直接使用1B的AL就可以避免</li>
<li><code>mov al,1</code></li>
</ul>
</li>
</ul>
<h3 id="派生shell"><a href="#派生shell" class="headerlink" title="派生shell"></a>派生shell</h3><p>首先写派生shell的C程序。派生shell最方便、最快捷的方法是创建新进程。在Linux里有两种方法创建新进程：</p>
<ul>
<li><ol>
<li>通过现有进程创建它，并用它代替现有活动进程</li>
</ol>
</li>
<li><ol start="2">
<li>利用程序生成自己的副本，并在它的位置运行这个进程</li>
</ol>
</li>
</ul>
<p>下面是一个简单C程序的execve调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *cmd[<span class="number">2</span>];</span><br><span class="line">    cmd[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    cmd[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(cmd[<span class="number">0</span>], cmd, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在把它转换成原始十六进制指令，就像exit()一样。想观察execve的文档，提供的信息很有价值：</p>
<ul>
<li><code>int execve(const char* filename, char* const argv[], char* const envp[])</code></li>
<li>execve()执行filename(指针)指向的程序</li>
<li>argv是字符串数组，用来传递参数，envp是字符串数组，用来传递环境变量。argv和envp都以空指针结束</li>
</ul>
<p>执行execve()系统调用4个寄存器：1个用来保存系统调用值;3个用来保存系统调用参数。</p>
<p>在shellcode里不可以使用硬编码地址。我们希望shellcode容易移植，因此我们使用相对地址。下面介绍一种相对地址的实现方法</p>
<p>在shellcode里使用相对地址需要一些技巧。我们可以把shellcode在内存中的开始地址或shellcode的重要元素复制到寄存器，然后根据寄存器里的地址设计每条指令：</p>
<ul>
<li>shellcode以一条跳转指令开始，跳过shellcode，跳到调用指令</li>
<li>执行调用指令时，紧跟在调用指令之后的地址将被压入栈<ul>
<li>这里把想作为相对地址的基地址直接放在了调用指令之后</li>
<li>需要时可以从栈中找到地址</li>
</ul>
</li>
<li>当调用指令后，我们的的基地址将自动保存在栈上，而我们不必提前知道这个地址</li>
<li>之后，调用指令调用shellcode，执行<code>pop esi</code>把栈上的基地址送入ESI。至此就可以根据ESI的偏移量来引用shellcode里面的代码</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    jmp short GoToCall</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop esi     ;把&#39;&#x2F;bin&#x2F;sh&#39;送入esi，使用了相对地址</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">GoToCall:</span><br><span class="line">    call shellcode</span><br><span class="line">    db &#39;&#x2F;bin&#x2F;sh&#39;</span><br></pre></td></tr></table></figure>

<p>下面用真正的汇编指令替代伪代码。在编写过程中，还需要在字符串尾部保留一些占位符(这里是9B)，如下：</p>
<ul>
<li><code>/bin/shJAAAAKKKK</code></li>
</ul>
<p>这些占位符有什么用呢？我们将把系统调用所需的3个参数中的2个(将被载入ECX、EDX)保存在这些占位符里。因为字符串的第一个字节的地址保存在ESI里，所以对于替换和把这些值复制到寄存器来说，很容易就能确定它们所在内存中的位置。另外，可以通过”复制到占位符”方法，用空值有效终止这些字符串。步骤如下：</p>
<ul>
<li><ol>
<li>用xor EAX EAX的结果(空值)填充EAX</li>
</ol>
</li>
<li><ol start="2">
<li>把AL复制到紧挨着/bin/sh的字符位置(J)来终止/bin/sh字符串。<ul>
<li>因为EAX是空值，所以AL也是空值</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>得到保存在ESI里的字符串开头地址，把它复制到EBX</li>
</ol>
</li>
<li><ol start="4">
<li>把EBX里的值(字符串开头的地址)复制到AAAA占位符<ul>
<li>这是execve系统调用要求的、被执行文件的参数指针</li>
</ul>
</li>
</ol>
</li>
<li><ol start="5">
<li>用正确的偏移量吧保存在EAX中的空值复制到KKKK占位符</li>
</ol>
</li>
<li><ol start="6">
<li>把字符串的地址载入EBX</li>
</ol>
</li>
<li><ol start="7">
<li>把保存在AAAA占位符里的地址(一个指向字符串的指针)载入ECX</li>
</ol>
</li>
<li><ol start="8">
<li>把保存在KKKK占位符里的地址(一个指向空值的指针)载入EDX</li>
</ol>
</li>
<li><ol start="9">
<li>执行<code>int 0x80</code></li>
</ol>
</li>
</ul>
<p>得到汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    jmp short GoToCall</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop esi</span><br><span class="line"></span><br><span class="line">    xor eax, eax                ; 1</span><br><span class="line">    </span><br><span class="line">    mov byte [esi+7], al        ; 2</span><br><span class="line"></span><br><span class="line">    lea ebx, [esi]              ; 3</span><br><span class="line">    mov long [esi+8], ebx       ; 4</span><br><span class="line">    mov long [esi+12], eax      ; 5</span><br><span class="line">    mov byte al, 0x0b</span><br><span class="line">    mov ebx, esi</span><br><span class="line">    lea ecx, [esi + 8]</span><br><span class="line">    lea edx, [esi + 12]</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">GoToCall:</span><br><span class="line">    call shellcode</span><br><span class="line">    db &#39;&#x2F;bin&#x2F;shJAAAAKKKK&#39;</span><br></pre></td></tr></table></figure>

<p>编译并反汇编的到操作码</p>
<h2 id="格式化串漏洞"><a href="#格式化串漏洞" class="headerlink" title="格式化串漏洞"></a>格式化串漏洞</h2><p>何为格式化串：</p>
<ul>
<li><code>printf(&quot;%d %x&quot;, a, b);</code></li>
<li>printf是一个参数保存在栈上的函数，即a、b从栈中取出</li>
</ul>
<p>出现格式化串漏洞最常见的原因是，在C语言里没有处理带有可变参数的函数。</p>
<h3 id="什么是格式化串"><a href="#什么是格式化串" class="headerlink" title="什么是格式化串"></a>什么是格式化串</h3><p>当 <strong>printf系列函数</strong> 的格式化串里包含用户提交的数据时(如用户输入)，就可能出现格式化串漏洞。</p>
<p>攻击者可以提交很多格式符(而不给出对应的变量)，这样的话，栈上就没有和格式符相对应的参数，从而导致信息泄漏和执行任意代码。</p>
<p>如果我们不给格式符提供变量，将会出现奇怪的事情。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmt.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用如下形式执行<ul>
<li><code>./fmt &quot;%x %x %x %x&quot;</code></li>
</ul>
</li>
<li>就相当于用如下形式调用printf<ul>
<li><code>printf(&quot;%x %x %x %x&quot;);</code></li>
</ul>
</li>
<li>这个语句会透露出一些重要的信息：我们提供了格式符，但没提供对应的参数。printf也没有报错，而是输出一下内容：<ul>
<li><code>4015c98c 4001526c bffff944 bffff8e8</code></li>
</ul>
</li>
<li>攻击者可以利用它来获取栈上的数据</li>
</ul>
<p>有许多格式符，下面介绍一个：</p>
<ul>
<li>n，这个参数被视为指向整数指针(或整数变量)，在这个参数之前输出的字符的数量被保存到这个参数指针的地址里<ul>
<li><code>./fmt &quot;AAAAAAAAAA%n%n%n%n%n%n%n%n&quot;</code></li>
<li>%n格式符把它的参数作为内存地址，把前面输出的字符的数量写到这个地址</li>
<li>这意味着我们有机会改写某个内存地址的数据，从而控制程序的执行</li>
</ul>
</li>
</ul>
<p>利用%n格式符把控制的数据写入选择的地址。如果满足一下条件，就可以利用格式化串漏洞执行任意代码：</p>
<ul>
<li>我们能够控制参数，并可以把输出的字符的数量写入内存的任意区域</li>
<li>宽度格式符允许我们用任意长度填充输出。如：<code>&quot;%23d&quot;</code>。因此可以用选择的值改写单个字节</li>
<li>通常来说，我们可以猜测函数指针的地址，因此我们可以促成系统把提交的字符串当作代码执行</li>
</ul>
<h3 id="Building"><a href="#Building" class="headerlink" title="Building"></a>Building</h3><h3 id="格式化串技术概述"><a href="#格式化串技术概述" class="headerlink" title="格式化串技术概述"></a>格式化串技术概述</h3><ul>
<li><p>如果格式化串在栈上，当增加字符串的格式符时，可以为格式符提供参数</p>
<ul>
<li>一旦可以指定参数：</li>
<li>可以用%s从目标进程读取内存数据</li>
<li>可以用%n把输出的字符的数量写入任意地址</li>
<li>可以用宽度修饰符修改输出的字符的数量</li>
<li>可以用%hn修饰符每次写入16位数值</li>
</ul>
</li>
<li><p>直接参数访问允许多次重用同一格式化串里的栈参数，也允许直接用这些我们感兴趣的参数。直接参数访问使用$修饰符，如：</p>
<ul>
<li><code>%272$x</code>，将显示栈上第272个参数</li>
</ul>
</li>
<li><p>利用格式化串漏洞、写内存的技术，可以：</p>
<ul>
<li>改写保存的返回地址</li>
<li>改写其他特殊程序的函数指针</li>
<li>改写指向异常处理程序的指针</li>
<li>改写GOT(全局偏移表)条目</li>
<li>等等</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Web篇"><a href="#Web篇" class="headerlink" title="Web篇"></a>Web篇</h1><h2 id="解析应用程序"><a href="#解析应用程序" class="headerlink" title="解析应用程序"></a>解析应用程序</h2><ul>
<li>确定后端使用的技术<ul>
<li><ol>
<li>提取版本HTTP消息头中的版本信息，但后端程序员也可以伪造</li>
</ol>
</li>
<li><ol start="2">
<li>文件扩展名<ul>
<li>许多Web服务器将特殊的文件扩展名映射到特定的服务器组件中，不同组建处理错误的方式不同</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>目录名<ul>
<li>一些子目录名常常表示应用程序使用了相关技术</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>会话令牌<ul>
<li>许多Web服务器和Web应用程序平台默认生成的会话令牌名称会揭示其使用的技术</li>
</ul>
</li>
</ol>
</li>
<li>等等</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/18/Major/algorithm/algorithm_tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/18/Major/algorithm/algorithm_tips/" class="post-title-link" itemprop="url">算法技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-18 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-18T00:00:00+08:00">2020-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-22 15:18:17" itemprop="dateModified" datetime="2020-10-22T15:18:17+08:00">2020-10-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>从结束条件开始分析</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>遇到需要记录字符的情况，可以使用<code>int a[26]</code>代替map</li>
</ul>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针的选择会出现在很多情况，如：快速排序算法m值的选择、列出排列组合的所有情况。</p>
<ul>
<li>一般先对数组排序，然后从边界开始就能简单的定一议二</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="判断二分图"><a href="#判断二分图" class="headerlink" title="判断二分图"></a>判断二分图</h3><p>染色，然后使用bfs或dfs遍历所有节点，不应该存在相邻节点颜色一样。</p>
<h2 id="复杂条件"><a href="#复杂条件" class="headerlink" title="复杂条件"></a>复杂条件</h2><h3 id="问题允许存在变量"><a href="#问题允许存在变量" class="headerlink" title="问题允许存在变量"></a>问题允许存在变量</h3><p>如判断一个字符串是否回文，而且允许删除一个字符。那么对于这个问题的变量就是如果要删除，是删除左边还是右边。但是主要的判断依旧是相同的<code>str[i++]==str[j--]</code>。</p>
<p>所以可以分离主要的判断程序，在主程序中使用<code>||</code>运算符来解决变量引起的讨论。如：<code>return func(删左边)||func(删右边)</code></p>
<h2 id="删除链表上第n个结点"><a href="#删除链表上第n个结点" class="headerlink" title="删除链表上第n个结点"></a>删除链表上第n个结点</h2><ul>
<li>快慢指针，当快指针的next是空的时候，慢指针刚好指到倒数第n个节点</li>
</ul>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>通常，涉及连续子数组问题的时候，我们使用前缀和来解决。</p>
<p>我们令$P[i] = A[0] + A[1] + … + A[i]$。那么每个连续子数组的和sum(i,j)就可以写成$P[j] - P[i-1]（其中 0 &lt; i &lt; j;0 &lt; i &lt; j）$的形式。</p>
<h3 id="任意范围连续元素的和"><a href="#任意范围连续元素的和" class="headerlink" title="任意范围连续元素的和"></a>任意范围连续元素的和</h3><p>两个前缀和相减就能得到任意范围连续元素的和，如前5个元素的前缀和间前3个元素的前缀和就得到4~5的和。</p>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>使用哨兵能简化我们的讨论，去掉不必要的分类讨论。如在链表中使用虚拟的头和尾，省去了分类讨论。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li>遍历一个 <strong>完整</strong> 的循环会节省很多讨论，何为完整，类似与判断波的一个完整周期</li>
</ul>
<h2 id="单向栈"><a href="#单向栈" class="headerlink" title="单向栈"></a>单向栈</h2><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><ul>
<li>计算一个数a的n次方<ul>
<li>当n是偶数，我们先计算a的n/2次方，然后平方</li>
<li>当n是奇数，我们先计算a的n-1次方，然后乘n</li>
</ul>
</li>
</ul>
<h2 id="运算模拟"><a href="#运算模拟" class="headerlink" title="运算模拟"></a>运算模拟</h2><p>使用链表模拟加减乘除时可以使用预处理以下将要运算的节点，都存在则正常进行，否则用一个无关数替代(乘法用1，加法用0等)，省去额外的判断。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/universe/c/cpp_level_up/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/universe/c/cpp_level_up/" class="post-title-link" itemprop="url">c++进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-15T00:00:00+08:00">2020-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-12 16:36:08" itemprop="dateModified" datetime="2020-12-12T16:36:08+08:00">2020-12-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-补完计划"><a href="#C-补完计划" class="headerlink" title="C++补完计划"></a>C++补完计划</h2><h3 id="关键字decltype-c-11"><a href="#关键字decltype-c-11" class="headerlink" title="关键字decltype(c++11)"></a>关键字decltype(c++11)</h3><p>关键字decltype(x)用于自动检测x的类型，并作为关键字。使用方法如下    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;	</span><br><span class="line"><span class="keyword">decltype</span>(x) y;   <span class="comment">// 声明y，其中y的类型取决于x	</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) xpy;   	</span><br><span class="line"><span class="comment">// 格式如下	</span></span><br><span class="line"><span class="keyword">decltype</span>(expression) var;  <span class="comment">// expression可以是函数调用	</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 另一种函数声明语法(c++<span class="number">11</span>后置返回类型)	</span><br><span class="line"></span><br><span class="line">考虑下面的情形：	</span><br><span class="line"></span><br><span class="line">``` c++	</span><br><span class="line"><span class="keyword">template</span>&lt;classs T1, <span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;	</span></span><br><span class="line"><span class="class">?<span class="title">type</span>? <span class="title">gf</span>(<span class="title">T1</span> <span class="title">x</span>, <span class="title">T2</span> <span class="title">y</span>)&#123;</span>	</span><br><span class="line">    ...	</span><br><span class="line">    <span class="keyword">return</span> x+y;	</span><br><span class="line">&#125;	</span><br><span class="line">那函数的返回类型是什么呢？	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">显然只用<span class="keyword">decltype</span>是解决不了问题了。使用新增的语法可编写成这样：	</span><br><span class="line"></span><br><span class="line">``` c++	</span><br><span class="line"><span class="keyword">template</span>&lt;classs T1, <span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;	</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">gf</span>(<span class="title">T1</span> <span class="title">x</span>, <span class="title">T2</span> <span class="title">y</span>) -&gt; <span class="title">decltype</span>(<span class="title">x</span>+<span class="title">y</span>)	</span></span><br><span class="line"><span class="class">&#123;</span>	</span><br><span class="line">    ...	</span><br><span class="line">    <span class="keyword">return</span> x+y;	</span><br><span class="line">&#125;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 说明符和限定符	</span><br><span class="line"></span><br><span class="line">- <span class="keyword">auto</span>	</span><br><span class="line">- <span class="keyword">register</span>	</span><br><span class="line">- <span class="keyword">static</span>	</span><br><span class="line">- <span class="keyword">extern</span>	</span><br><span class="line">    - 指出是对外部变量(相对当前代码块的外部)的引用	</span><br><span class="line">- thread\_local(C++<span class="number">11</span>)	</span><br><span class="line">- <span class="keyword">mutable</span>	</span><br><span class="line">    - 即使结构变量为<span class="keyword">const</span>，<span class="keyword">mutable</span>的成员也是可以被修改的	</span><br><span class="line">- <span class="keyword">volatile</span>	</span><br><span class="line">    - 表明，即使程序代码没有对内存单元进行修改，其值也可能发生改变	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 使用<span class="keyword">new</span>运算符初始化	</span><br><span class="line"></span><br><span class="line">如果要为内置的标量类型分配存储空间并初始化，可以在类型名后面加上初始化值，并将其用括号括起：	</span><br><span class="line"></span><br><span class="line">``` c++	</span><br><span class="line"><span class="keyword">double</span>* pd = <span class="keyword">new</span> <span class="keyword">double</span> (<span class="number">99.99</span>)  <span class="comment">// *pd=99.99	</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">要初始化常规结构或数组，需要使用打括号	</span><br><span class="line"></span><br><span class="line">``` c++	</span><br><span class="line">struct where&#123;<span class="keyword">double</span> x; <span class="keyword">double</span> y; <span class="keyword">double</span> z;&#125;	</span><br><span class="line">where* one = <span class="keyword">new</span> where&#123;<span class="number">2.3</span>, <span class="number">3.2</span>, <span class="number">6.4</span>&#125;	</span><br><span class="line"><span class="keyword">int</span>* ar = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">#### 初始化结构体	</span><br><span class="line"></span><br><span class="line">``` 	</span><br><span class="line">struct ListNode &#123;	</span><br><span class="line">    <span class="keyword">int</span> val;	</span><br><span class="line">    ListNode *next;	</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;	</span><br><span class="line">&#125;;	</span><br><span class="line">ListNode* ls=<span class="keyword">new</span> ListNode(<span class="number">0</span>);	</span><br><span class="line"><span class="comment">// ls-&gt;val=0;ls-&gt;next=NULL;	</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 定位<span class="keyword">new</span>运算符	</span><br><span class="line"></span><br><span class="line">通常，<span class="keyword">new</span>负责在堆中找到一个足以满足要求的内存块。<span class="keyword">new</span>也可以指定要使用的位置：	</span><br><span class="line"></span><br><span class="line">``` c++	</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">20</span>];	</span><br><span class="line"><span class="keyword">int</span> p1 = <span class="keyword">new</span> (<span class="built_in">buffer</span>) <span class="keyword">int</span>; <span class="comment">//在buffer中找空间	</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 名称空间	</span><br><span class="line"></span><br><span class="line">当项目很大的时候可能会发出重名的现象，这时可以使用名称空间进行区分。	</span><br><span class="line"></span><br><span class="line">C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间：	</span><br><span class="line"></span><br><span class="line">``` c++	</span><br><span class="line"><span class="keyword">namespace</span> Jack&#123;	</span><br><span class="line">    <span class="keyword">double</span> pail;	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fetch</span><span class="params">()</span></span>;	</span><br><span class="line">&#125;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>声明将特定的名称添加到它所属的声明区域中：	</span><br><span class="line"></span><br><span class="line">``` c++	</span><br><span class="line">chat fetch;	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">Jack::fetch</span><span class="params">()</span></span>;	</span><br><span class="line">    <span class="keyword">double</span> fetch;    <span class="comment">// 失败，因为已经声明了fetch	</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; fetch;    <span class="comment">// Jack的fetch	</span></span><br><span class="line">    cing &gt;&gt; ::fetch; <span class="comment">// 全局的fetch	</span></span><br><span class="line">&#125;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>声明使一个名称可用，而<span class="keyword">using</span>编译指令使所有的名称都可用。<span class="keyword">using</span>编译指令使用`<span class="keyword">using</span> <span class="keyword">namespace</span>`关键字。	</span><br><span class="line"></span><br><span class="line">`	</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jack;	</span><br><span class="line">`	</span><br><span class="line"></span><br><span class="line">可以将名称空间声明进行嵌套	</span><br><span class="line"></span><br><span class="line">``` c++	</span><br><span class="line"><span class="keyword">namespace</span> Bob&#123;	</span><br><span class="line">    <span class="keyword">namespace</span> Bill&#123;	</span><br><span class="line">        <span class="keyword">int</span> age;	</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="built_in">string</span> name;	</span><br><span class="line">&#125;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">也可以在名称空间中使用<span class="keyword">using</span>编译指令和<span class="keyword">using</span>声明：	</span><br><span class="line"></span><br><span class="line">``` 	</span><br><span class="line"><span class="keyword">namespace</span> myth&#123;	</span><br><span class="line">    <span class="keyword">using</span> Jack::fetch;	</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Bob;	</span><br><span class="line">&#125;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 对象和类	</span><br><span class="line"></span><br><span class="line">### 构造函数和析构函数	</span><br><span class="line"></span><br><span class="line">类需要构造函数来创建类对象，不能像下面的那样初始化对象，因为数据部分的访问状态是私有的，这意味着程序不能直接访问数据乘员。	</span><br><span class="line"></span><br><span class="line">``` c	</span><br><span class="line">Person one = &#123;<span class="string">"Bob"</span>, <span class="number">23</span>&#125;;  <span class="comment">//编译错误	</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">- 使用构造函数的两种方法：	</span><br><span class="line">    - `Person one = Person(<span class="string">"Bob"</span>, <span class="number">23</span>);`	</span><br><span class="line">    - `<span class="function">Person <span class="title">one</span><span class="params">(<span class="string">"Bob"</span>, <span class="number">23</span>)</span></span>;`	</span><br><span class="line">- 将构造函数与<span class="keyword">new</span>一起使用	</span><br><span class="line">    - `Person *one = <span class="keyword">new</span> Person(<span class="string">"Bob"</span>, <span class="number">23</span>);`	</span><br><span class="line"></span><br><span class="line">- 析构函数	</span><br><span class="line">    - `~Person()&#123;&#125;`	</span><br><span class="line">    - 构造函数创建对象后，程序负责跟踪该对象，直到过期。过期时自动调用析构函数	</span><br><span class="line">    - 一般用于删除分配了的资源	</span><br><span class="line">- 默认构造函数	</span><br><span class="line">    - `Person()&#123;&#125;`	</span><br><span class="line">- 列表初始化	</span><br><span class="line">    - C++<span class="number">11</span>中，可将列表初始化语法用于类中(构造函数)	</span><br><span class="line">    - `Person one = &#123;<span class="string">"Bob"</span>, <span class="number">23</span>&#125;;`	</span><br><span class="line">    - `Person one&#123;<span class="string">"Bob"</span>, <span class="number">23</span>&#125;;`	</span><br><span class="line">    - `Person one&#123;&#125;;` 调用默认构造函数	</span><br><span class="line">        - 不同于`Person one()`; 这是一个返回Person的函数	</span><br><span class="line">- <span class="keyword">const</span>成员函数	</span><br><span class="line">    - `<span class="function"><span class="keyword">const</span> Person <span class="title">one</span><span class="params">(<span class="string">"Bob"</span>, <span class="number">23</span>)</span></span>;`  	</span><br><span class="line">    `one.show()`，这样是不行的因为不能保证show方法不会修改对象	</span><br><span class="line">    - 除非show方法为：`<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;`，这就是声明<span class="keyword">const</span>成员函数的方法	</span><br><span class="line">    - 因此只要类方法不修改调用对象，就应该将其声明为<span class="keyword">const</span>	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 类和对象	</span><br><span class="line"></span><br><span class="line">### 使用类	</span><br><span class="line"></span><br><span class="line">#### 重载运算符	</span><br><span class="line"></span><br><span class="line">- 格式：`operator op(argument-list)`	</span><br><span class="line">    - 如`<span class="keyword">operator</span> +()、<span class="keyword">operator</span> *()`	</span><br><span class="line">    - 不能是一个虚构的符号	</span><br><span class="line"></span><br><span class="line">假设有个一个Bob类，并为它定义了一个`<span class="keyword">operator</span> +()`成员函数，以重载+运算符。A、B和C都是Bob的对象。便可以编写如下等式：	</span><br><span class="line">- `C = A + B`	</span><br><span class="line">- 编译器发现操作数是Bob对象，因此使用相应的运算符函数代替上述运算符	</span><br><span class="line">    - `C = A.<span class="keyword">operator</span>+(B)`	</span><br><span class="line">    - 这说明了运算符的原理	</span><br><span class="line"></span><br><span class="line">重载限制：	</span><br><span class="line">- 重载的运算符必须至少有一个操作数是用户自定义的类型，防止用户为标准类型重载运算符	</span><br><span class="line">- 使用运算符不能违反运算符原来的语句规则	</span><br><span class="line">- 不能修改运算符的优先级	</span><br><span class="line">- 不能创造新的运算符	</span><br><span class="line"></span><br><span class="line">在区分++运算符的前缀版本和后缀版本，C++将<span class="keyword">operator</span>++作为前缀版本，将<span class="keyword">operator</span>++(<span class="keyword">int</span>)作为后缀版本;其中的参数永远不会被用到，所以不指定名称	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 友元	</span><br><span class="line"></span><br><span class="line">C++提供形式的访问权限，：友元。友元有<span class="number">3</span>中：	</span><br><span class="line">- 友元函数	</span><br><span class="line">- 友元类	</span><br><span class="line">- 友元成员函数	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 友元成员函数	</span><br><span class="line"></span><br><span class="line">友元成员函数可以访问类内的私有成员，通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。	</span><br><span class="line"></span><br><span class="line">考虑下面的情形：设A、B都是Bob类的对象，并且Bob类重载了\*运算符。则`A = B * <span class="number">2.5</span>`可行，但`A = <span class="number">2.5</span> * B`就会出现问题。原因在于，类内对运算符重载，隐式调用对象`A = B.<span class="keyword">operator</span>*(<span class="number">2.5</span>)`，而换位置后`<span class="number">2.5</span>`对象并没有重载运算符。那难道要重载`<span class="keyword">double</span>`类的运算符吗？那将会造成很大混乱。	</span><br><span class="line"></span><br><span class="line">还有种重载运算符的方法：使用非成员函数。如`Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time&amp; t)`运算符左边对应第一个参数，右边对应第二个参数。	</span><br><span class="line"></span><br><span class="line">那如果Time类中有私有数据呢，非成员函数怎么访问？这时就需要友元了。	</span><br><span class="line"></span><br><span class="line">- 创建友元	</span><br><span class="line">    - 将原型放在类声明中，并加上`<span class="keyword">friend</span>`关键字	</span><br><span class="line">        - 该原型意味着下面两点	</span><br><span class="line">        - 函数是在类中声明的，但不是类成员函数，因此不能用成员运算符来调用	</span><br><span class="line">        - 不是成员函数，但数据的访问权限相同	</span><br><span class="line">- 编写函数定义	</span><br><span class="line">    - 因为不是成员函数，所以不能用`Class::`限定符，就像声明普通函数一样即可	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 静态成员	</span><br><span class="line"></span><br><span class="line">静态类成员有一个特点：无论创建多少对象，程序都只创建一个静态类变量副本。即类的所有对象共享同一个静态成员。	</span><br><span class="line"></span><br><span class="line">不能在类声明中初始化静态成员变量，因为声明描述如何分配内存，但不执行分配。需要在声明之外使用单独的语句进行初始化， **因为静态类是单独储存的，而不是对象的组成部分** 。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 特殊成员函数	</span><br><span class="line"></span><br><span class="line">- C++自动提供下面这些成员函数(如果没有定义)	</span><br><span class="line">    - 默认构造函数	</span><br><span class="line">    - 默认析构函数	</span><br><span class="line">    - 复制构造函数	</span><br><span class="line">        - 它接受一个指向类对象的常量引用作为参数`Class_name(<span class="keyword">const</span> Class_name&amp;);`	</span><br><span class="line">        - 何时调用	</span><br><span class="line">            - 用类对象生成另一个对象`<span class="function">Time <span class="title">a</span><span class="params">(b)</span></span>;`	</span><br><span class="line">            - `Time a = b;`	</span><br><span class="line">        - 复制是按值复制的，也就是说a、b是同一个东西，因为传入的是引用。这样释放空间时可能会遇到问题。	</span><br><span class="line">    - 赋值运算函数	</span><br><span class="line">    - 地址运算函数	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 类继承	</span><br><span class="line"></span><br><span class="line">从一个类派生出另一个类时，原始类成为基类，继承类称为派生类。	</span><br><span class="line"></span><br><span class="line">- 派生一个类：`<span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span> <span class="keyword">public</span> Base`，将Son类声明为从Base类派生而来	</span><br><span class="line">    - 冒号指出Son的基类是Base	</span><br><span class="line">    - pulic指出Base是一个公有基类，称为公有派生。	</span><br><span class="line">        - 基类的公有成员将成为派生类的公有成员，基类的私有部分也成为派生类的一部分，但只能通过基类的公有和保护方法访问	</span><br><span class="line">        - 派生类不能直接访问基类私有成员，必须通过基类的方法进行访问	</span><br><span class="line">    - <span class="keyword">private</span>指出Base是一个私有基类	</span><br><span class="line">        - 基类的成员在派生类中中都(公有、保护私有成员)为私有	</span><br><span class="line">    - 保护继承	</span><br><span class="line">        - 基类的公有、保护私有成员在派生类中中都为保护成员	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 创建派生对象时，程序先创建基类对象。使用下列语法指定创建基类的构造函数。	</span><br><span class="line">    - `Son::Son(<span class="keyword">int</span> age, <span class="built_in">string</span> name, <span class="keyword">int</span> Sex): Base(<span class="keyword">int</span> age)&#123;&#125;` 	</span><br><span class="line">    - 其中`:Base(<span class="keyword">int</span> age)`是成员初始化列表。参数从派生类构造函数传入基类构造函数	</span><br><span class="line">    - 也可对派生类的成员使用成员初始化列表语法：	</span><br><span class="line">        - `Son::Son(<span class="keyword">int</span> age, <span class="built_in">string</span> name, <span class="keyword">int</span> Sex): Base(<span class="keyword">int</span> age), age(age)&#123;&#125;` 	</span><br><span class="line">        - 相当于`Son::Son(<span class="keyword">int</span> age, <span class="built_in">string</span> name, <span class="keyword">int</span> Sex): Base(<span class="keyword">int</span> age)&#123; <span class="keyword">this</span>.age = age;&#125;`	</span><br><span class="line"></span><br><span class="line">- 派生类和基类之间的特殊关系	</span><br><span class="line">    - 派生类对象可以使用基类的公有方法	</span><br><span class="line">    - 基类指针可以不进行显示类型转换的情况下指向派生类对象	</span><br><span class="line">        - 基类范围更广，派生类可以是基类。但是基类不能是派生类，因为派生类更具体	</span><br><span class="line">    - 基类引用可以不进行显示类型转换的情况下引用派生类对象	</span><br><span class="line">    - 虽然基类指针或引用只能调用基类方法	</span><br><span class="line"></span><br><span class="line">- 多态：方法的行为取决于调用该方法的对象	</span><br><span class="line">    - 两种机制实现多态	</span><br><span class="line">        - 在派生类中重新定义	</span><br><span class="line">        - 使用虚方法	</span><br><span class="line">    - 其他容易理解，这里特别介绍虚方法，它将决定指针或引用调用那种方法	</span><br><span class="line">        - 如果没有使用虚方法关键字<span class="keyword">virtual</span>，程序将根据引用类型或指针类型选择方法	</span><br><span class="line">        - 如果使用虚方法关键字<span class="keyword">virtual</span>，程序将根据引用或指针指向的对象的类型选择方法	</span><br><span class="line">            - 即<span class="string">"虚方法将看到指针或引用的本质"</span>	</span><br><span class="line"></span><br><span class="line">- 将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)	</span><br><span class="line">    - 在编译过程中进行联编被称为静态联编或早联编	</span><br><span class="line">    - 在程序运行时进行联编称为动态联编或晚联编(如多态)	</span><br><span class="line"></span><br><span class="line">- 访问控制：<span class="keyword">protected</span>	</span><br><span class="line">    - <span class="keyword">protected</span>与<span class="keyword">private</span>类似，区别之在基类和派生类之间才会表现出来	</span><br><span class="line">    - 对外界来说<span class="keyword">protected</span>成员的行为与<span class="keyword">private</span>相似;但对于派生类来说<span class="keyword">protected</span>成员的行为与公有成员相似	</span><br><span class="line"></span><br><span class="line">- **抽象基类(abstract base class, ABC)**	</span><br><span class="line">    - 将类的共性抽象出来，放到一个ABC类中，然后再用ABC类派生有这些共性的类	</span><br><span class="line">        - 这么做便可以使用基类指针(配合虚函数)数组同时管理多个类的对象了	</span><br><span class="line">    - C++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾处为=<span class="number">0</span>，原型中的=<span class="number">0</span>是虚函数成为纯虚函数：`<span class="keyword">virtual</span> <span class="keyword">void</span> func(<span class="keyword">int</span> arg) = <span class="number">0</span>;`	</span><br><span class="line">    - 当类声明中包含纯虚函数时，不能创建该类的对象，只能作为基类。成为真正的ABC至少包含一个纯虚函数	</span><br><span class="line">    - C++允许在基类中定义(只是不能创建对象)	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## C++中代码重用	</span><br><span class="line"></span><br><span class="line">- 包含对象成员的类	</span><br><span class="line">    - has-a	</span><br><span class="line">    - 有一些类为表示类中的组建提供了方便，用这些类作为成员以就不需要重复的定义	</span><br><span class="line">        - 如`valarray&lt;T&gt;`类，类似`<span class="built_in">vector</span>&lt;T&gt;`，但valarray提供的算数支持更多，如<span class="built_in">max</span>、sum。如果类的成员需要算数数组就可用valarray，而不用重新定义数组和sum、<span class="built_in">max</span>等类方法，因为valarray对象成员包含了这些方法	</span><br><span class="line"></span><br><span class="line">- 使用<span class="keyword">using</span>重新定义访问权限	</span><br><span class="line">    - 使用保护派生或私有派生时，要让基类的方法在派生类外面可用的一种方法是将函数调用包装在另一个函数调用中，即使用<span class="keyword">using</span>来指出派生类可以使用特定的基类成员	</span><br><span class="line"></span><br><span class="line">- 多重继承`<span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span> <span class="keyword">public</span> Dad, <span class="keyword">private</span> Mom&#123;...&#125;;`	</span><br><span class="line">    - **虚基类**：使得从多个类(它们的基类相同)派生出的对象只继承一个基类对象，而不是重复的两个	</span><br><span class="line">        - `<span class="class"><span class="keyword">class</span> <span class="title">Singer</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Worker&#123;...&#125;;`	</span><br><span class="line">        - `<span class="class"><span class="keyword">class</span> <span class="title">Waiter</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Worker&#123;...&#125;;`	</span><br><span class="line">        - `<span class="class"><span class="keyword">class</span> <span class="title">SingerWaiter</span>:</span> <span class="keyword">public</span> Singer, <span class="keyword">public</span> Waiter&#123;...&#125;;`，SingerWaiter对象将只包含worker对象的副本，而不是引入各自(Singer、Waiter)的Worker对象副本	</span><br><span class="line"></span><br><span class="line">- 类也有模板类、同样的类成员、友元也是，定义方法同模板函数	</span><br><span class="line">    - 有模板类就会有隐式实例化、显式实例化和显式具体化，同模板函数	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 友元、异常和其他	</span><br><span class="line"></span><br><span class="line">### 友元	</span><br><span class="line"></span><br><span class="line">友元一般用于类的扩展接口中，类并非只能拥有友元函数，也可以将类作为友元。	</span><br><span class="line"></span><br><span class="line">#### 友元类	</span><br><span class="line"></span><br><span class="line">如电视机和遥控器，它们两并不是is-a或has-a的关系，但是遥控器能够改变电视机的状态，这表明应将遥控作为电视机的一个友元类。电视机的面板也提供了换台、修改音量等功能。遥控器的功能和电视机内置的功能相同，但是遥控器可以任意的选择频道以及其他许多功能。使遥控成为电视的友元类，这样遥控就能访问电视的私有数据了。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 嵌套类	</span><br><span class="line"></span><br><span class="line">C++中可以将类声明放在另一个类中。在另一个类中声明的类称为嵌套类，它通过提供新的类型类作用域来避免名称混乱。包含类的成员函数可以使用和创建被嵌套类的对象;而仅当声明位于公有部分，才能在包含类的外部使用嵌套类，而且必须使用作用域解析运算符(class::class::func)	</span><br><span class="line"></span><br><span class="line">对类进行嵌套通常是为了帮助实现另一个类，避免名称冲突。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 异常	</span><br><span class="line"></span><br><span class="line">- <span class="keyword">try</span>&#123;&#125;	</span><br><span class="line">    - 花括号表明要注意这些代码引发的异常	</span><br><span class="line">- <span class="keyword">throw</span> Object	</span><br><span class="line">    - 抛出异常，回到<span class="keyword">try</span>的位置，并跳过<span class="keyword">try</span>。通常抛出类类型，类似返回语句<span class="keyword">return</span>	</span><br><span class="line">    - 类似<span class="keyword">return</span>是原理，使用栈解退来跳转到<span class="keyword">try</span>	</span><br><span class="line">- <span class="keyword">catch</span>(Type)&#123;&#125;	</span><br><span class="line">    - <span class="keyword">catch</span>关键字表示异常捕获，括号中指出捕获的类型，并接受异常抛出的对象，花括号指出采取的措施	</span><br><span class="line">- exception类	</span><br><span class="line">    - exception类位于exception头文件中，可以把它用作其他异常的基类	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### RTTI	</span><br><span class="line"></span><br><span class="line">RTTI是运行阶段类型识别(Runtime Type Identification)的简称。	</span><br><span class="line"></span><br><span class="line">- C++有<span class="number">3</span>个支持的RTTI元素	</span><br><span class="line">    - dynamic\_cast：如果可能的话，将使用一个指向基类的指针来生成一个指向派生类的指针;否则返回空指针	</span><br><span class="line">    - <span class="keyword">typeid</span>：返回一个指出对象的类型的值	</span><br><span class="line">    - type\_info：存储了有关特定类型的信息	</span><br><span class="line">- 只能将RTTI用于包含虚函数的类层次结构，原因在与只有对于这种层次结构，才应该将派生类对象的地址赋给基类指针	</span><br><span class="line">    - 因为如果使用虚方法关键字<span class="keyword">virtual</span>，程序将根据引用或指针指向的对象的类型选择方法，就算使用基类指针接收，也会选择引用或指针指向的对象方法	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- dynamic\_cast:	</span><br><span class="line">    - `<span class="keyword">dynamic_cast</span>&lt;Type *&gt;(ps)`，ps指向一个对象	</span><br><span class="line">    - 如果ps的类型可以安全的转换为`Type*`，运算符返回对象的地址;否则返回空指针	</span><br><span class="line">    - 因此可以安全地`Base* pb = <span class="keyword">dynamic_cast</span>&lt;Base *&gt;(ps)`	</span><br><span class="line">- <span class="keyword">typeid</span>和type\_info	</span><br><span class="line">    - `<span class="keyword">typeid</span>`运算符接收类名或者一个对象，返回一个对type\_info的的引用	</span><br><span class="line">    - type\_info是在头文件typeinfo中定义的一个类。type\_info重载了==和!=运算符，以便可以对类进行对比	</span><br><span class="line">        - `<span class="keyword">typeid</span>(Base) == <span class="keyword">typeid</span>(*pg)`如果pg是空指针将发生异常，异常类型是exception类派生来的	</span><br><span class="line">        - type\_info的实现随厂商而异，但包含一个`name()`成员，该函数返回一个随实现而异的字符串，通常是类的名称	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 标准模板库	</span><br><span class="line"></span><br><span class="line">### <span class="built_in">string</span>	</span><br><span class="line"></span><br><span class="line">#### <span class="built_in">string</span>类输入	</span><br><span class="line"></span><br><span class="line">- 对于类，有<span class="number">3</span>中输入方式。`<span class="keyword">char</span> str[<span class="number">100</span>]`	</span><br><span class="line">    - `<span class="built_in">cin</span> &gt;&gt; str`，读一个词	</span><br><span class="line">    - `<span class="built_in">cin</span>.getline(str, <span class="number">100</span>);`，读一行，去掉`\n`，有一个可选参数用来指定使用哪个字符来确定输入边界	</span><br><span class="line">    - `<span class="built_in">cin</span>.<span class="built_in">get</span>(info, <span class="number">100</span>)`，读一行，保留`\n`	</span><br><span class="line">- 对于<span class="built_in">string</span>对象，有两种方式	</span><br><span class="line">    - `<span class="built_in">cin</span> &gt;&gt; str`，读一个词	</span><br><span class="line">    - `getline(<span class="built_in">cin</span>, stuff)`，读一行，去掉`\n`，有一个可选参数用来指定使用哪个字符来确定输入边界	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 智能指针模板类	</span><br><span class="line"></span><br><span class="line">智能指针是行为类似指针的 **类对象** ，这种对象还有其他功能。看下面代码：	</span><br><span class="line"></span><br><span class="line">``` c	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>&#123;	</span><br><span class="line">    <span class="built_in">string</span>* ps = <span class="keyword">new</span> <span class="built_in">string</span>(str);	</span><br><span class="line">    <span class="keyword">if</span>(hasException)&#123;	</span><br><span class="line">        <span class="keyword">throw</span> exception();	</span><br><span class="line">    &#125;	</span><br><span class="line">    ...	</span><br><span class="line">    str = ps;	</span><br><span class="line">    <span class="keyword">return</span>;	</span><br><span class="line">&#125;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">注意到这段代码分配了堆中的内存，但是没有释放，从而导致内存泄漏。	</span><br><span class="line">- 那在结尾加<span class="keyword">delete</span>不就行了？	</span><br><span class="line">    - 这是中可能忘记的解决方案，存在隐患	</span><br><span class="line">- 就算加了<span class="keyword">delete</span>如果出现异常，<span class="keyword">delete</span>将不被执行，也导致内存泄漏	</span><br><span class="line">- 因此如果它是一个对象，那在它过期的时候析构函数删除指向的内存就好了。由此得到了使用智能指针的解决方案	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 智能指针的使用	</span><br><span class="line"></span><br><span class="line">`<span class="built_in">auto_ptr</span>`,`<span class="built_in">unique_ptr</span>`和`<span class="built_in">shared_ptr</span>`都定义了类似指针的对象，可以将<span class="keyword">new</span>获得(直接或间接)的地址赋给这种对象。当智能指针过期时，其析构函数将使用<span class="keyword">delete</span>来释放内存。要创建智能指针对象，必须引入头文件memory。	</span><br><span class="line">- 语法：`<span class="built_in">auto_ptr</span>&lt;Type&gt; pointer(<span class="keyword">new</span> Type)`(其他两种相同)	</span><br><span class="line">- 所有智能指针类都有一个<span class="keyword">explicit</span>构造函数，该构造函数将指针作为参数。因此不需要自动将指针转换为智能指针对象	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 智能指针的注意事项	</span><br><span class="line"></span><br><span class="line">``` c	</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ps (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>));	</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; pd;	</span><br><span class="line">pd = ps;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">如果ps和pd是常规指针，那这两个指针指向同一个<span class="built_in">string</span>对象。这是不能接受的，因为程序将试图将同一个对象删除两次：ps过期时删除，pd过期时删除。要避免这个问题有如下方法：	</span><br><span class="line">- 定义赋值运算符	</span><br><span class="line">    - 使之执行深复制。这样两个指针指向不同的对象	</span><br><span class="line">- 建立所有权(ownership)概念	</span><br><span class="line">    - 对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的指针能够删除该对象	</span><br><span class="line">    - **<span class="keyword">auto</span>\_ptr和unique\_ptr就是使用这种策略** ，但是`<span class="built_in">unique_ptr</span>`的策略更加严格	</span><br><span class="line">    - 当所有权转移，将不能通过原来的指针进行访问	</span><br><span class="line">        - `<span class="built_in">auto_ptr</span>`编译时不会检测所有权是否转移	</span><br><span class="line">        - 使用`<span class="built_in">unique_ptr</span>`，将在编译阶段检测到所有权转移错误，因此`<span class="built_in">unique_ptr</span>`比较安全	</span><br><span class="line">- 创建只能更高的指针，跟踪引用特定对象的智能指针	</span><br><span class="line">    - 如，赋值时计数加<span class="number">1</span>，过期时计数减<span class="number">1.</span>当最后一个指针过期(计数减为<span class="number">0</span>)时才调用<span class="keyword">delete</span>，这是share\_ptr采用的策略	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 标准模板库(Standard Template Library)	</span><br><span class="line"></span><br><span class="line">STL容器是同质的，即存储的值的类型相同。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 模板类<span class="built_in">vector</span>	</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>类提供了与前面将的valarray和Array类似的操作，即可以创造<span class="built_in">vector</span>对象，将一个<span class="built_in">vector</span>对象赋值给另一个<span class="built_in">vector</span>对象，可以随机访问。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 可对<span class="built_in">vector</span>执行的操作	</span><br><span class="line"></span><br><span class="line">所有STL容器都提供了一些基本方法，如：`<span class="built_in">size</span>(), swap(), <span class="built_in">begin</span>()`等。其中`<span class="built_in">begin</span>(), <span class="built_in">end</span>()`返回第一个元素的迭代器和返回超过容量尾的迭代器。	</span><br><span class="line"></span><br><span class="line">迭代器是一个广义的指针。事实上它可以是指针，也可以是一个可对其执行类似指针操作(如解除引用`<span class="keyword">operator</span>*()`和递增`<span class="keyword">operator</span>++()`)的对象。通过将指针广义化为迭代器，让STL能够为各种不同的容器类提供统一的接口。每个容器类都定义了一个合适的迭代器，该迭代器的类型是一个名为`iterator`的<span class="keyword">typedef</span>，其作用域是整个类。如	</span><br><span class="line"></span><br><span class="line">``` c	</span><br><span class="line"><span class="comment">//声明一个迭代器变量	</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pd;	</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores;	</span><br><span class="line">pd = scores.<span class="built_in">begin</span>(); 	</span><br><span class="line"><span class="comment">//或者auto pd = scores.begin();	</span></span><br><span class="line">*pd = <span class="number">2</span>;	</span><br><span class="line">++pd;	</span><br><span class="line"><span class="comment">//如上，迭代器的行为就像指针	</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">- `erase(iterator1, iterator2)`方法删除矢量中给定区间[iterator1, iterator2)的元素	</span><br><span class="line">    - 它接受两个迭代器参数	</span><br><span class="line">- `insert()`与erase相反	</span><br><span class="line">    - 它接受三个迭代器参数	</span><br><span class="line">    - 第一个参数指定了新元素的插入位置，第二个和第三个迭代器定义了被插入区间，该区间通常来自另一个容器对象	</span><br><span class="line">    - 拥有超尾元素使得在尾部附加元素非常简单	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 对<span class="built_in">vector</span>可执行的其他操作	</span><br><span class="line"></span><br><span class="line">STL从更广泛的角度定义了非成员函数来执行这些操作，即不是为每个容器类定义<span class="built_in">find</span>()成员函数，而是定义了一个适用于所有容器类的非成员函数。这种设计省去了大量重复的工作。	</span><br><span class="line"></span><br><span class="line">下面是<span class="number">3</span>个代表性的STL函数：	</span><br><span class="line">- `for_each()`	</span><br><span class="line">    - 接受<span class="number">3</span>个参数，前两个是定义容器区间的迭代器，最后一个是指向函数的指针，被指向的函数应用于区间内的每个元素。被指向的函数不能修改容器元素的值	</span><br><span class="line">- `random_shuffle()`	</span><br><span class="line">    - 接受两个指定区间的迭代器参数，并随机排序该区间中的元素	</span><br><span class="line">    - 该函数要求容器类支持随机访问	</span><br><span class="line">- `sort()`	</span><br><span class="line">    - 有两个格式：	</span><br><span class="line">        - 第一个版本接受两个定义区间的迭代器参数，并使用储存在容器中的类型元素定义的&lt;运算符，对区间中的元素进行操作，如果元素是用户定义的对象，要使用sort必须定义能够处理该类型的opertator&lt;()函数	</span><br><span class="line">        - 另一种格式的sort接受<span class="number">3</span>个参数，前两个是指定区间的迭代器，最后一个是要使用的函数，而不是用opertator&lt;()。返回值可转换为<span class="keyword">bool</span>，<span class="literal">false</span>表示两个参数的顺序不正确	</span><br><span class="line">    - 该函数要求容器类支持随机访问	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 泛型编程	</span><br><span class="line"></span><br><span class="line">STL是一种泛型编程，泛型编程关注的是算法。如模板能够按泛型定义函数或类，高效地代码复用。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 迭代器	</span><br><span class="line"></span><br><span class="line">模板使得算法独立于储存的数据类型，而迭代器使算法独立于使用的容器类型。如果泛型编程想要使用同一个<span class="built_in">find</span>函数处理数组、链表或其他容器类型那么就需要一个东西来对容器中的值进行通用表示，迭代器正是这样的通用表示。	</span><br><span class="line"></span><br><span class="line">每个容器类(<span class="built_in">vector</span>、<span class="built_in">list</span>等)定义了相应的迭代器类型。	</span><br><span class="line">- 每个容器都有`<span class="built_in">begin</span>()`和`<span class="built_in">end</span>()`方法，分别返回第一个容器和超尾位置的迭代器	</span><br><span class="line">- 每个容器都实现了\*和++等方法，从而可以对迭代器进行操作	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 迭代器的类型	</span><br><span class="line"></span><br><span class="line">- 输入迭代器	</span><br><span class="line">    - 这里的<span class="string">"输入"</span>是从程序的角度来说的，即容器的信息被视为输入	</span><br><span class="line">    - 输入迭代器可以被程序用来读取容器的信息，但不能修改容器的值	</span><br><span class="line">    - 支持++运算符来访问所有元素	</span><br><span class="line">    - 输入迭代器是单向的、可递增的、不能倒退的	</span><br><span class="line">- 输出迭代器	</span><br><span class="line">    - 这里的<span class="string">"输出"</span>指用于信息从程序传输到容器	</span><br><span class="line">    - 输出迭代器是单通行的、只写的	</span><br><span class="line">- 正向迭代器	</span><br><span class="line">    - 只能使用++运算符遍历容器	</span><br><span class="line">    - 总是按一定的顺序	</span><br><span class="line">    - 递增后仍可以对前面的迭代器解除引用，并可的到相同的值	</span><br><span class="line">    - 可读可写也可只读`<span class="keyword">int</span> *p; <span class="keyword">const</span> <span class="keyword">int</span>* p`	</span><br><span class="line">- 双向迭代器	</span><br><span class="line">    - 具有正向迭代器的所有特性，同时支持两种增减运算符	</span><br><span class="line">- 随机访问迭代器	</span><br><span class="line">    - 具有双向迭代器的所以特性，同时支持随机访问	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 输入输出和文件	</span><br><span class="line"></span><br><span class="line">### 流和缓冲区	</span><br><span class="line"></span><br><span class="line">输入流需要两个连接，每端各一个。文件端(文件端可以是文件也可以是设备)连接提供流的来源，程序端连接将流的流出部分转储到程序中。同样，输出的管理包括将输出流连接到程序以及将输出目标与流关联。	</span><br><span class="line"></span><br><span class="line">缓冲区是用作中介的内存块，它是将信息从设备传输到程序或从程序传输给设备的临时储存工具。使用缓冲区可以高效地处理输入和输出。缓冲区帮助匹配两种不同的信息传输速率。C++程序通常在用户按下回车键时刷新入缓冲区，对键盘输入进行缓冲可以让用户将输入传输给程序之前返回并更正。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 流、缓冲区和iostream文件	</span><br><span class="line"></span><br><span class="line">iostream文件中包含一些专门设计来实现、管理流和缓冲区的类。	</span><br><span class="line"></span><br><span class="line">- stream类	</span><br><span class="line">    - 为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法	</span><br><span class="line">- ios\_base类	</span><br><span class="line">    - 表示流的一般特征，如是否可读取、是二进制流还是文本流等	</span><br><span class="line">    - ios类基于ios\_base，其中包括了一个指向streambuf对象的指针成员	</span><br><span class="line">- ostream类	</span><br><span class="line">    - 从ios类派生而来的，提供了输出方法	</span><br><span class="line">- istream类	</span><br><span class="line">    - 从ios类派生而来，提供了输入方法	</span><br><span class="line">- 这些工具必须使用适当的类对象，如ostream对象<span class="built_in">cout</span>。创建这样的对象将打开一个流，自动创建缓冲区，并将其与流关联起来。	</span><br><span class="line"></span><br><span class="line">iostream库管理了很多细节。如在程序中包含iostream文件将自动创建<span class="number">8</span>个流对象(<span class="number">4</span>个用于窄字符流、<span class="number">4</span>个用于宽字符流)	</span><br><span class="line">- <span class="built_in">cin</span>	</span><br><span class="line">    - 标准输入流，默认情况下这个流被关联到标准输入设备	</span><br><span class="line">    - wcin对象与此类似，但处理的是wchar\<span class="keyword">_t</span>类型	</span><br><span class="line">- <span class="built_in">cout</span>	</span><br><span class="line">    - 标准输出流，默认情况下这个流被关联到标准输出设备	</span><br><span class="line">    - wout对象与此类似，但处理的是wchar\<span class="keyword">_t</span>类型	</span><br><span class="line">- <span class="built_in">cerr</span>	</span><br><span class="line">    - 标准错误流，可用于显示错误消息，默认情况下这个流被关联到标准输出设备	</span><br><span class="line">    - 这个流没有缓冲，直接被发送到屏幕	</span><br><span class="line">    - werr对象与此类似，但处理的是wchar\<span class="keyword">_t</span>类型	</span><br><span class="line">- <span class="built_in">clog</span>	</span><br><span class="line">    - 也是标准错误流，可用于显示错误消息，默认情况下这个流被关联到标准输出设备	</span><br><span class="line">    - wlog对象与此类似，但处理的是wchar\<span class="keyword">_t</span>类型	</span><br><span class="line">- 对象代表流意味着什么？	</span><br><span class="line">    - 当iostream文件为程序声明一个<span class="built_in">cout</span>对象时，该对象将包含储存了与输出有关的信息和数据成员，如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数方法以及描述用来处理输出流缓冲区的streambuf对象的地址	</span><br><span class="line">    - `<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span>;`这个语句通过将指向的streambuf对象将字符串<span class="string">"hello"</span>中的字符放到<span class="built_in">cout</span>管理的缓冲区中	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 重定向	</span><br><span class="line">    - 标准输入和输出流通常连接着键盘和屏幕，重定向使得能够改变标准输入和标准输出。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 使用<span class="built_in">cout</span>进行输出	</span><br><span class="line"></span><br><span class="line">C++将输出看做字节流，但在程序中，很多数据被组织成比字节流更大的单位，如，<span class="keyword">int</span>类型可能有<span class="number">16</span>位或<span class="number">32</span>位的二进制值表示。但在将字节流发送给屏幕时，希望每个字节表示一个字符，如<span class="keyword">int</span>类型的<span class="number">12</span>可能是<span class="number">32</span>位表示的，但在屏幕上要求<span class="number">3</span>用一个字节表示，<span class="number">2</span>用一个字节表示。	</span><br><span class="line"></span><br><span class="line">因此ostream类最重要的任务之一是将数值类型转换为文本形式表示的字符流。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 重载的\&lt;\&lt;运算符	</span><br><span class="line">    - C/C++中`&lt;&lt;`运算符默认含义是按位左移，但ostream类重载了`&lt;&lt;`运算符，将其重载为输出。`&lt;&lt;`运算符被重载使之能识别C++中所有的基本类型。	</span><br><span class="line">- 其他ostream方法	</span><br><span class="line">    - `put()`方法原型：`ostream&amp; put(char)`	</span><br><span class="line">        - `<span class="built_in">cout</span>.<span class="built_in">put</span>(<span class="string">'W'</span>);`，<span class="built_in">cout</span>是调用方法的对象，<span class="built_in">put</span>是类成员函数	</span><br><span class="line">        - 返回一个指向调用对象的引用，因此可以用它将拼接输出	</span><br><span class="line">    - `write()`原型：`basic_ostream&lt;charT,traits&gt;&amp; write(const char_type* s, streamsize n);`	</span><br><span class="line">        - <span class="built_in">write</span>方法显示整个字符串	</span><br><span class="line">        - 第一个参数提供了要显示的字符串的地址，第二个参数指出要显示多少个字符	</span><br><span class="line">        - <span class="built_in">write</span>方法不会在遇到空字符时停止打印，而是打印指定数目的字符，即使超出了字符串的边界！	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 刷新缓冲区	</span><br><span class="line"></span><br><span class="line">ostream类对<span class="built_in">cout</span>对象处理的输出进行缓冲，所以输出不会立即发送到目标地址，而是被储存在缓冲区中，直至缓冲区填满。然后刷新(<span class="built_in">flush</span>)缓冲区，把内容发送出去，并清空缓冲区。	</span><br><span class="line"></span><br><span class="line">- 在屏幕输出时，程序不必等到缓冲区填满。如	</span><br><span class="line">    - 将换行号发送到缓冲区后将刷新缓冲区。	</span><br><span class="line">    - 多数C++实现都会在输入即将发生时刷新缓冲区，即使没有换行符	</span><br><span class="line">- 如果实现不能在所希望时刷新输出，可以使用两个控制符中的一个来强制进行刷新	</span><br><span class="line">    - 控制符<span class="built_in">flush</span>刷新缓冲区：`<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">flush</span>;`	</span><br><span class="line">    - 控制符<span class="built_in">endl</span>刷新缓冲区，并插入一个换行符：`<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">endl</span>;`	</span><br><span class="line">    - 实际上控制符也是函数，可以直接调用`<span class="built_in">flush</span>(<span class="built_in">cout</span>);`，ostream重载了`&lt;&lt;`，使得`<span class="built_in">cout</span> &lt;&lt; <span class="built_in">flush</span>;`可行。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 用<span class="built_in">cout</span>进行格式化	</span><br><span class="line"></span><br><span class="line">ostream类是从ios类派生而来的，而ios类从ios\_base类派生而来。ios\_base类存储了描述格式状态的信息。通过使用ios\_base的成员函数，可以控制字段宽度和小数位数。由于ios\_base类是ostream的间接基类，因此可将其方法用于ostream对象，如<span class="built_in">cout</span>。	</span><br><span class="line"></span><br><span class="line">- 调整进制，**设置持续到将格式状态设置为其他选项为止**，控制符不是成员函数，但也可`<span class="built_in">cout</span> &lt;&lt; hex;`调用	</span><br><span class="line">    - `hex()`，设置后程序以十六进制形式打印整数值	</span><br><span class="line">    - `oct()`，设置后程序以八进制形式打印整数值	</span><br><span class="line">- 调整字段宽度	</span><br><span class="line">    - `<span class="built_in">width</span>` **成员函数** 将长度不同的数字放到宽度相同的字段中	</span><br><span class="line">        - `<span class="built_in">width</span>()`方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值	</span><br><span class="line">            - `<span class="built_in">cout</span>.<span class="built_in">width</span>(<span class="number">12</span>);<span class="built_in">cout</span>&lt;&lt;<span class="number">12</span>&lt;&lt;<span class="string">"#"</span>;`只有<span class="number">12</span>被放宽到<span class="number">12</span>个字符，并右对齐，后面的将不受影响	</span><br><span class="line">        - `int width()`，返回宽度当前值	</span><br><span class="line">        - `int width(int i)`，将字段宽度设置为i个，并返回以前的字段宽度值	</span><br><span class="line">        - 如果试图在宽度为<span class="number">2</span>的字段中显示一个<span class="number">7</span>位值，C++将增宽字段，以容纳该数据	</span><br><span class="line">- 填充字符，默认情况下<span class="built_in">cout</span>使用空格填充字段中未被使用的部分	</span><br><span class="line">    - `<span class="built_in">fill</span>()` **成员函数** 来改变填充的字符，如`<span class="built_in">cout</span>.<span class="built_in">fill</span>(<span class="string">'*'</span>)`。新的填充字符将一直有效直到设置新的填充字符	</span><br><span class="line">- 设置浮点数的显示精度有效位数	</span><br><span class="line">    - `precision()` **成员函数** 改变精度。如`<span class="built_in">cout</span>.precision(<span class="number">2</span>);`。精度设置一直有效直到被重新设置	</span><br><span class="line">- 打印末尾的<span class="number">0</span>和小数点	</span><br><span class="line">    - iostream没有提供专门用于这项功能的函数，但ios\_base类提供了一个`serf()`函数，能够控制多种格式化特性。这个类还定义了多个常量，可以用作改函数的参数	</span><br><span class="line">    - <span class="built_in">cout</span>显示末尾小数点`<span class="built_in">cout</span>.setf(ios_base::showpoint);`	</span><br><span class="line">        - 这会显示小数后的<span class="number">0</span>,如精度为<span class="number">6</span>时<span class="number">2</span>会显示为<span class="number">2.00000</span>	</span><br><span class="line"></span><br><span class="line">`setf()`除了可以控制小数点的显示还有几个格式选项。ios\_base类有一个受保护的数据成员，其中的各位(这里称之为标记)分别控制着格式化的各个方面。打开一个标记称为设置标记(或位)，并意味着相应的位被设置为<span class="number">1.</span>	</span><br><span class="line"></span><br><span class="line">hex、dec、oct等控制符实际上就是通过控制技术系统的<span class="number">3</span>个标记位实现的。`setf()`函数提供了另一种调整标记位的途径。`setf()`函数有两个原型	</span><br><span class="line">- `<span class="function">fmtflags <span class="title">setf</span><span class="params">(fmtflags)</span></span>;`，其中哦fmtflags是bitmask类型的别名(<span class="keyword">typedef</span>)，用于储存格式标记。	</span><br><span class="line">    - 这个版本的setf用来设置单个控制位的格式信息，参数fmtflags是一个值，指出要设置哪一位。返回值是类型为fmtflags的数字，指出标记以前的设置	</span><br><span class="line">    - ios\_base类定义了代表位值的常量：	</span><br><span class="line">        - `ios\_base::boolalpha`，输入和输出的<span class="keyword">bool</span>值，可以为<span class="literal">true</span>或<span class="literal">false</span>	</span><br><span class="line">        - `ios\_base::showbase`，对于输出，使用C++基数前缀(<span class="number">0</span>, <span class="number">0</span>x等)	</span><br><span class="line">        - `ios\_base::showpoint`，显示末尾的小数点	</span><br><span class="line">        - `ios\_base::uppercase`，对于十六进制输出，使用大写字母，E表示法	</span><br><span class="line">        - `ios\_base::showpos`，在正数前面加上+。十进制才有效，因为十六进制八进制都被视为无符号	</span><br><span class="line">    - 修改将一直有效直到被覆盖为止	</span><br><span class="line">- `<span class="function">fmtflags <span class="title">setf</span><span class="params">(fmtflags, fmtflags)</span></span>;`	</span><br><span class="line">    - 函数的这种格式用于设置有多位控制的格式选项	</span><br><span class="line">    - 第一个参数包含了所需设置的fmtflags值，第二个参数指出要清理第一个参数中的哪些位	</span><br><span class="line">        - 如，第<span class="number">3</span>位为<span class="number">1</span>表示以<span class="number">10</span>为基数，第<span class="number">4</span>位为<span class="number">1</span>表示以<span class="number">8</span>为基数，第<span class="number">5</span>位为<span class="number">1</span>表示以<span class="number">16</span>为基数，如果要输出原来以<span class="number">10</span>为基数，要设置为以<span class="number">16</span>为基数，则要将第<span class="number">5</span>位设置为<span class="number">1</span>,和将第<span class="number">3</span>位设置为<span class="number">0</span>：这叫做清除位	</span><br><span class="line">    - ios\_base类为此定义了常量	</span><br><span class="line">        - `setf(ios_base::dec, ios_base::basefield)`，使用<span class="number">10</span>为基数	</span><br><span class="line">        - `setf(ios_base::oct, ios_base::basefield)`，使用<span class="number">8</span>为基数	</span><br><span class="line">        - `setf(ios_base::hex, ios_base::basefield)`，使用<span class="number">16</span>为基数	</span><br><span class="line">        - `setf(ios_base::fixed, ios_base::floatfield)`，使用定点计数法	</span><br><span class="line">        - `setf(ios_base::scientific, ios_base::floatfield)`，使用科学计数法	</span><br><span class="line">        - `setf(ios_base::left, ios_base::adjustfield)`，使用左对齐	</span><br><span class="line">        - `setf(ios_base::right, ios_base::adjustfield)`，使用右对齐	</span><br><span class="line">        - `setf(ios_base::internal, ios_base::adjustfield)`，符号或基数前缀左对齐，值右对齐	</span><br><span class="line">        - 第二个参数清理一批相关位，然后第一个参数将其中<span class="number">1</span>位设置为<span class="number">1</span>	</span><br><span class="line">- 调用setf的效果可通过`unsetf()`消除	</span><br><span class="line">    - 原型为：`<span class="function"><span class="keyword">void</span> <span class="title">unsetf</span><span class="params">(fmtflags mask)</span></span>;`，mask中位设置为<span class="number">1</span>,将使对应的位被复位	</span><br><span class="line"></span><br><span class="line">使用setf不是进行格式化、对用户友好的方法，C++提供了过个控制符，如hex、dex等。如：使用下列方式打开左对齐和定点选项`<span class="built_in">cout</span> &lt;&lt; left &lt;&lt; fixed;`	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 使用<span class="built_in">cin</span>进行输入	</span><br><span class="line"></span><br><span class="line">istream类重载了抽取运算符`&gt;&gt;`，使之能识别基本类型。重载的原型为：`istream&amp; <span class="keyword">operator</span>&gt;&gt;(Type&amp;)`参数和返回都是引用。引用参数意味着会修改参数本身;每个抽取运算符都返回调用对象本身，这使得能够将输入拼接。	</span><br><span class="line"></span><br><span class="line">可以将hex、oct和dec控制符与<span class="built_in">cin</span>一起使用，来指定将整数输入解释为十六进制、八进制还是十进制格式。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###<span class="meta"># cin&gt;&gt;如何检查输入	</span></span><br><span class="line"></span><br><span class="line">抽取运算符跳过空白(空格、换行、制表符)，直到遇到非空白字符。抽取运算符将读取指定类型是数据，即从非空白字符开始，到与指定类型不匹配的第一个字符之间的全部内容。不匹配的内容将留在流中，下一个<span class="built_in">cin</span>语句将从这里开始读取。	</span><br><span class="line"></span><br><span class="line">如果istream对象的错误状态被设置，<span class="keyword">if</span>或<span class="keyword">while</span>将判定该对象为<span class="literal">false</span>。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 流状态	</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>或<span class="built_in">cout</span>对象包含一个描述流状态的数据成员。流状态由<span class="number">3</span>个ios\_base元素组成：eofbit、badbit、failbit，每个元素都是一位，可以是<span class="number">1</span>或<span class="number">0</span>。当全部<span class="number">3</span>个状态都设置为<span class="number">0</span>，则一切顺利。	</span><br><span class="line"></span><br><span class="line">- 设置状态	</span><br><span class="line">    - `<span class="built_in">clear</span>(eofbit)`方法将状态设置为它的参数(eofbit)，剩下的两个状态位置被清除	</span><br><span class="line">        - `<span class="built_in">clear</span>()`将清除全部<span class="number">3</span>个状态位	</span><br><span class="line">    - `setstate()`方法只影响其参数中已设置的位，如`setstate(eofbit)`如果已经设置了failbit，则仍将被设置	</span><br><span class="line">- I/O异常	</span><br><span class="line">    - 可以通过`exceptions()`方法来控制异常如何被处理	</span><br><span class="line">        - `exceptions()`方法返回一个位字段，它包含<span class="number">3</span>个位，分别对应于eofbit、failbit、badbit	</span><br><span class="line">        - 修改流状态后`<span class="built_in">clear</span>()`方法将当前的流状态与`exceptions()`返回的值进行比较。如果当前状态中有<span class="string">"期望"</span>的状态，则<span class="built_in">clear</span>引发ios\_base::failure异常，就可以通过`<span class="keyword">catch</span>(ios_base::failure)`捕获	</span><br><span class="line">        - 位运算符OR使得能够指定多位：`<span class="built_in">cin</span>.exceptions(badbit|eofbit);`	</span><br><span class="line">- 流状态的影响	</span><br><span class="line">    - 只有流状态良好这个语句才会返回<span class="literal">true</span>`<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;input)`，但这么做有个 **严重的后果** ：流将对后面的输入或输出关闭，直到位被清除	</span><br><span class="line">    - 如果希望程序在流状态被设置后能够读取后面的输入，就必须将流状态设置为良好(<span class="built_in">clear</span>)和将引发错误的字符清空(`<span class="keyword">while</span>(!<span class="built_in">isspace</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>()))`或`<span class="keyword">while</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>()!=<span class="string">'\n'</span>)`)	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 其他istream类方法	</span><br><span class="line"></span><br><span class="line">- 单字符输入	</span><br><span class="line">    - `<span class="built_in">get</span>()`方法读取下一个输入字符，**即使该字符是空白**，而抽取运算符`&gt;&gt;`不会读取空白	</span><br><span class="line">        - `<span class="built_in">get</span>(<span class="keyword">char</span>&amp; ch)`将输入字符赋给参数，返回调用它的istream对象的引用，即<span class="built_in">cin</span>	</span><br><span class="line">        - `<span class="built_in">get</span>(<span class="keyword">void</span>)`将输入字符转换为整型并返回	</span><br><span class="line">            - 到达文件尾后，`<span class="built_in">cin</span>.<span class="built_in">get</span>(<span class="keyword">void</span>)`将返回EOF，可用这点来做条件控制	</span><br><span class="line"></span><br><span class="line">| 特征                     | `<span class="built_in">cin</span>.<span class="built_in">get</span>(ch)`         | `ch = <span class="built_in">cin</span>.<span class="built_in">get</span>()` |	</span><br><span class="line">|--------------------------|-----------------------|------------------|	</span><br><span class="line">| 传输输入字符的方法       | 赋值给参数ch          | 返回值赋值给ch   |	</span><br><span class="line">| 字符输入时函数的返回值   | 指向istream对象的引用 | 字符编码(<span class="keyword">int</span>值)  |	</span><br><span class="line">| 达到文件尾时函数的返回值 | 转换为<span class="literal">false</span>           | EOF              |	</span><br><span class="line"></span><br><span class="line">如果希望跳过空白，使用抽取运算符`&gt;&gt;`更方便。`<span class="built_in">get</span>(<span class="keyword">void</span>)`的主要优点是它和C语言中的`getchar`函数及其相似，简单替换即可从C转换为C++。	</span><br><span class="line"></span><br><span class="line">- getline()、<span class="built_in">get</span>()	</span><br><span class="line">    - `istream&amp; <span class="built_in">get</span>(<span class="keyword">char</span>*, <span class="keyword">int</span>, <span class="keyword">char</span>);`	</span><br><span class="line">    - `<span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">int</span>)</span></span>;`	</span><br><span class="line">    - `<span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">int</span>, <span class="keyword">char</span>)</span></span>;`	</span><br><span class="line">    - `<span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">int</span>)</span></span>;`	</span><br><span class="line">    - 第一个参数是输入字符串的内存单元地址，第二个参数是最大字符数加<span class="number">1</span>，多一位用来存结尾空字符，第<span class="number">3</span>个参数指定分界符，默认以换行符分界	</span><br><span class="line">    - <span class="built_in">get</span>和getline之间的主要区别是，<span class="built_in">get</span>将分界符留在流中，而getline抽取并丢弃分界符	</span><br><span class="line">- `<span class="function">istream&amp; <span class="title">ignore</span><span class="params">(<span class="keyword">int</span> = <span class="number">1</span>, <span class="keyword">int</span> = EOF)</span></span>;`	</span><br><span class="line">    - 一个参数指定要读取的最大字符数，另一个参数用作分界符	</span><br><span class="line">    - 将读取并丢弃最大指定数量个字符或直到到达第一个分界符	</span><br><span class="line"></span><br><span class="line">- 意外字符串输入	</span><br><span class="line">    - <span class="built_in">get</span>和getline的某些输入形式将影响流状态	</span><br><span class="line">        - 如遇到文件尾将设置eofbit，遇到流被破坏将设置badbit	</span><br><span class="line">        - 空行并不会导致getline设置failbit，因为它抽取换行符	</span><br><span class="line"></span><br><span class="line">#### 其他istream方法	</span><br><span class="line"></span><br><span class="line">其他istream方法包括<span class="built_in">read</span>()、<span class="built_in">peek</span>()、gcount()和putback()	</span><br><span class="line"></span><br><span class="line">- `<span class="built_in">read</span>(<span class="keyword">char</span>*, <span class="keyword">int</span>)`	</span><br><span class="line">    - <span class="built_in">read</span>函数读取指定数目的字节，并将它们存储在指定的位置中	</span><br><span class="line">    - <span class="built_in">read</span>不会在输入后加上空值字符，因此 **不能将输入转换为字符串**	</span><br><span class="line">- `<span class="built_in">peek</span>()`	</span><br><span class="line">    - <span class="built_in">peek</span>函数返回输入中的下一个字符，但不从输入流中抽取出来，即单纯的查看下一个字符	</span><br><span class="line">- `gcount()`	</span><br><span class="line">    - gcount方法返回最后一个非格式化抽取方法读取字符	</span><br><span class="line">        - 所谓格式化是：抽取运算符对输入进行格式化，使之与特定的数据类型匹配	</span><br><span class="line">- `istream&amp; putback(char)`	</span><br><span class="line">    - putback将一个字符插入到输入字符串中，被插入的字符串将是下一条输入语句读取的地一个字符(即插入到首部)	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 文件输入和输出	</span><br><span class="line"></span><br><span class="line">#### 简单文件的I/O	</span><br><span class="line"></span><br><span class="line">要让程序写入文件，必须：	</span><br><span class="line">- <span class="number">1.</span> 创建一个ostream对象来管理输出流	</span><br><span class="line">- <span class="number">2.</span> 将该对象与特定的文件关联起来	</span><br><span class="line">- <span class="number">3.</span> 以使用<span class="built_in">cout</span>的方式使用该对象，唯一的区别是输出将进入文件，而不是屏幕	</span><br><span class="line"></span><br><span class="line">``` c	</span><br><span class="line"><span class="comment">// 1. 包含头文件fstream，该文件包含iostream文件	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;	</span></span></span><br><span class="line"><span class="comment">// 2.声明一个ofstream对象	</span></span><br><span class="line">ofstream fout;	</span><br><span class="line"><span class="comment">// 3. 将这个对象与特定的文件关联起来	</span></span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">"hello.txt"</span>);	</span><br><span class="line"><span class="comment">// 或使用构造函数	</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"hello.txt"</span>)</span></span>;	</span><br><span class="line"><span class="comment">// 4. 以使用cout的方式使用fout	</span></span><br><span class="line">fout &lt;&lt; <span class="string">"hello world"</span>;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">由于ostream是ofstream的基类，因此可以使用所有的ostream方法，包括各种插入运算符定义、格式化方法和控制符。每创建一个对象，程序将为这个对象创建一个缓冲区。	</span><br><span class="line"></span><br><span class="line">用上面这种方式打开文件进行输出时，如果没有这样的文件，将创建一个新的文件;如果有这样的文件，则打开并清空文件，输出将进入这个空文件中。	</span><br><span class="line"></span><br><span class="line">读取文件与写入文件类似：	</span><br><span class="line">- <span class="number">1.</span> 创建一个ifstream对象来管理输入流	</span><br><span class="line">- <span class="number">2.</span> 将该对象与特定的文件关联起来	</span><br><span class="line">- <span class="number">3.</span> 以使用<span class="built_in">cin</span>的方式使用该对象	</span><br><span class="line"></span><br><span class="line">当输入输出流对象过期时，到文件的连接将自动关闭。也可以使用`<span class="built_in">close</span>()`方法来显式地关闭文件的连接。	</span><br><span class="line"></span><br><span class="line">关闭这样的连接不会删除流，而只是断开流到文件的连接。流管理装置仍被保留。如：fin对象与它管理的输入缓冲区仍然存在。因此可以将流重新连接到同一个或另一个文件。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 流状态检查	</span><br><span class="line"></span><br><span class="line">C++文件流从ios\_base类继承了一个流状态成员。该成员存储了指出流状态的信息。当然还继承了报告流状态的方法，如`fin.is_open()`	</span><br><span class="line"></span><br><span class="line">由于ifstream和istream对象一样，被放在需要<span class="keyword">bool</span>类型的地方时，将被转换为<span class="keyword">bool</span>值。如`<span class="keyword">if</span>(fin)`	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 命令行处理	</span><br><span class="line"></span><br><span class="line">C++有一种让在命令环境中运行的程序能够访问命令行参数的机制，方法是使用main函数的参数：`int main(int argc, char* argv[])`，其中argc为参数的个数，包括命令本身，argv是参数数组argv[0]指向命令行的第一个字符串(命令本身)，以此类推。	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 文件模式	</span><br><span class="line"></span><br><span class="line">文件模式描述的是文件将被如何使用：读、写、追加等。将流与文件关联时，都可以提供指定文件模式作为第二个参数，如：	</span><br><span class="line"></span><br><span class="line">``` c	</span><br><span class="line"><span class="function">ifstream <span class="title">fin1</span><span class="params">(<span class="string">"hello"</span>, mod1)</span></span>;	</span><br><span class="line">ifstream fin2;	</span><br><span class="line">fin2.<span class="built_in">open</span>(<span class="string">"hello"</span>, mod2);	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">ios\_base类定义了一个openmode类型，用于表示模式。可以选择iso\_base类中定义的多个常量来指定模式。	</span><br><span class="line"></span><br><span class="line">| 常量                | 含义                           |	</span><br><span class="line">|---------------------|--------------------------------|	</span><br><span class="line">| `ios\_base::in`     | 打开文件，以便读取             |	</span><br><span class="line">| `ios\_base::<span class="built_in">cout</span>`   | 打开文件，以便写入             |	</span><br><span class="line">| `ios\_base::ate`    | 打开文件，并移动到文件尾       |	</span><br><span class="line">| `ios\_base::app`    | 追加到文件尾                   |	</span><br><span class="line">| `ios\_base::trunc`  | 如果文件存在，则截短文件(清空) |	</span><br><span class="line">| `ios\_base::binary` | 二进制文件                     |	</span><br><span class="line"></span><br><span class="line">ifstream的<span class="built_in">open</span>方法和构造函数默认用`ios_base::in`打开文件;ofstream默认用`ios_base::out|ios_base::trunc`打开文件。使用运算符OR将两个位值合并成一个可用于设置两个位的值。	</span><br><span class="line"></span><br><span class="line">`ios_base::trunc`标记意味着打开已有的文件，以接受程序的输入时将被截短，即其以前的内容将被删除。	</span><br><span class="line"></span><br><span class="line">C++语句`<span class="function">ifstream <span class="title">fin</span><span class="params">(filename, c++mode)</span></span>;`就像使用了的C的`fopen()`函数一样：`fopen(filename, cmode)`。其中c++mode是一个openmode值，如ios\_base::in;而cmode是相对应的C模式字样，如<span class="string">"r"</span>。	</span><br><span class="line"></span><br><span class="line">| C++模式                                             | C模式    | 含义                                     |	</span><br><span class="line">|-----------------------------------------------------|----------|------------------------------------------|	</span><br><span class="line">| `ios_base::in`                                      | <span class="string">"r"</span>      | 打开以读取                               |	</span><br><span class="line">| `ios_base::out`                                     | <span class="string">"w"</span>      | 等价于`ios_base::out \| ios_base::trunc` |	</span><br><span class="line">| `ios_base::out \| ios_base::trunc`                  | <span class="string">"w"</span>      |                                          |	</span><br><span class="line">| `ios_base::out \| ios_base::app`                    | <span class="string">"a"</span>      | 打开写入，追加                           |	</span><br><span class="line">| `ios_base::out \| ios_base::out`                    | <span class="string">"r+"</span>     | 打开以读写，在文件允许的位置写入         |	</span><br><span class="line">| `ios_base::out \| ios_base::out \| ios_base::trunc` | <span class="string">"w+"</span>     | 打开以读写，截短                         |	</span><br><span class="line">| `c++mode \| ios_base::binary`                       | <span class="string">"cmodeb"</span> | 以C\+\+mode和二进制模式打开              |	</span><br><span class="line">| `c++mode \| ios_base::ate`                          | <span class="string">"cmode"</span>  |                                          |	</span><br><span class="line"></span><br><span class="line">`ios_base::ate`和`ios_base::app`区别在于：app模式只是将数据添加到文件尾，而ate模式将指针放在文件尾巴	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 二进制文件</span><br><span class="line"></span><br><span class="line">文本格式指的是将所有内容都储存位文本，这需要将浮点数的计算机内部表示转换位字符格式。对于字符来说，二进制表示与文本表示是一样的，都是ASCII码，对于数字二进制表示和文本表示就有很大区别。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## C++新标准</span><br><span class="line"></span><br><span class="line">### Lambda函数</span><br><span class="line"></span><br><span class="line">名称lambda来自lambda calculus，一种定义和应用函数的数学系统。这个系统让你能够使用匿名函数。在C++<span class="number">11</span>中，对于接受函数指针或函数符的函数，可以使用匿名函数定义作为其参数。</span><br><span class="line"></span><br><span class="line">看下面一个lambda函数：</span><br><span class="line"></span><br><span class="line">``` c</span><br><span class="line">[](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x%<span class="number">3</span>==<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>使用[]代替了函数名;没有声明函数返回类型，返回类型相当于使用了decltype推断得到。当lambda表达式完全由一条返回语句组成时，自动类型推断才管用，否则需要使用返回类型后置语法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">double</span> x)-&gt;<span class="keyword">double</span>&#123;<span class="keyword">int</span> y=x; <span class="keyword">return</span> x-y;&#125;</span><br></pre></td></tr></table></figure>

<p>lambda函数的好处：定义位于使用的地方附近，不需要翻阅多页寻找函数定义。</p>
<p>lambda函数可以访问作用域内任何动态变量，要捕获要使用的动态变量，可将其名称放在中括号内。如果只指定了变量名如[z]则按值访问变量，如果使用[&amp;z]则按引用访问变量。[&amp;]让你以引用方式访问所有变量，[=]以值方式。[&amp;, z]以值访问z，以引用访问其他变量。</p>
<h3 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h3><p>C++提供了多个包装器。这些对象用于给其他编程提供更一致或更合适的接口。</p>
<p>模板是比较低效的，如<code>ef(q)</code>ef可以是函数名、函数指针、函数对象或有名称的lambda表达式。这些都是可调用的类型，对于模板，可能重复实例化同一个函数，因此导致了模板的低效。</p>
<p>包装器function让你能够防止这样的事情发生。模板function是在头文件functional中声明的，它从调用特征的角度定义了一个对象，可用于包装调用特征相同的函数指针、函数对象或lambda表达式。如下面的声明创建一个function对象，她接受一个char参数和int参数，并返回double值：<code>std::function&lt;double(char, int)&gt; fdci;</code>。可以将接受一个char参数和一个int参数，返回double值的函数指针、函数对象、lambda表达式赋给它。这样对应特征相同的函数指针、函数对象、lambda表达式在使用模板时唯一实例化一次。</p>
<h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><p>创建可变参数模板需要理解以下几点：</p>
<ul>
<li>模板参数包</li>
<li>函数参数包</li>
<li>展开参数包</li>
<li>递归</li>
</ul>
<h4 id="模板参数包"><a href="#模板参数包" class="headerlink" title="模板参数包"></a>模板参数包</h4><p>C++11提供了一个用省略号表示的元运算符，让你能够声明表示模板参数包的标识符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">show</span>(<span class="title">Args</span>... <span class="title">args</span>)&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Args是一个模板参数包，而args是一个函数参数包。可将这些参数包的名称指定位任何符合C++标识符规则的名称。</p>
<h4 id="展开参数包"><a href="#展开参数包" class="headerlink" title="展开参数包"></a>展开参数包</h4><p>索引功能在这里不适用。相反可以将省略号放在函数参数包名的右边，将函数参数包展开。如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">show</span>(<span class="title">Args</span>... <span class="title">args</span>)&#123;</span></span><br><span class="line">    show(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于把所有参数又传给了show，如此下去合时是头？需要使用递归</p>
<h4 id="在可变参数模板函数中使用递归"><a href="#在可变参数模板函数中使用递归" class="headerlink" title="在可变参数模板函数中使用递归"></a>在可变参数模板函数中使用递归</h4><p>这里的技巧在于将函数模板头改成如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">show</span>(<span class="title">T</span> <span class="title">value</span>, <span class="title">Args</span>... <span class="title">args</span>)&#123;</span></span><br><span class="line">    show(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样每次T都会取走第一个参数，而arg取走其余参数，每次递归就会少一个参数，直到递归结束。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Type, Type&gt; Hash;	</span><br><span class="line"><span class="comment">//索引、添加、修改	</span></span><br><span class="line">Hash[key];	</span><br><span class="line">Hash[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">//添加	</span></span><br><span class="line">Hash[<span class="number">2</span>] = <span class="number">3</span>; <span class="comment">//修改	</span></span><br><span class="line"><span class="comment">//计数	</span></span><br><span class="line">Hash.count(key);	</span><br><span class="line"><span class="comment">//删除	</span></span><br><span class="line">Hash.erase(key);	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">## Queue</span><br><span class="line"></span><br><span class="line">### 优先队列</span><br><span class="line"></span><br><span class="line">`priority_queue`模板有三个参数，第一个参数是储存对象的类型，第二个参数是存储元素的底层容器，第三个参数是一个决定元素顺序的断言。其中第二参数默认`<span class="built_in">vector</span>`，第三参数默认`&lt;` **大的元素排在前面** 。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="keyword">typename</span> Compare=<span class="built_in">std</span>::less&lt;T&gt;&gt; class priority_queue</span><br></pre></td></tr></table></figure>

<p>创建一个优先队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;,greater&lt;<span class="built_in">string</span>&gt;&gt; words1</span><br></pre></td></tr></table></figure>

<p>创建一个储存字符串的优先队列，其底层存储结构是<code>vector</code>，根据<code>&gt;</code>判断顺序。</p>
<p>由于默认顺序是按照<code>&lt;</code>比较，所以也可在结构体中重载<code>&lt;</code>运算符，在实现自定义顺序的目的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="keyword">int</span> vi;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;( <span class="keyword">const</span> node &amp;x )<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br></pre></td></tr></table></figure>


<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
</tr>
<tr>
<td>|</td>
<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
</tr>
<tr>
<td>^</td>
<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
</tr>
<tr>
<td>~</td>
<td>二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
</tr>
</tbody></table>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;=</td>
<td>左移且赋值运算符</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移且赋值运算符</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与且赋值运算符</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或且赋值运算符</td>
</tr>
<tr>
<td>|=</td>
<td>按位或且赋值运算符</td>
</tr>
</tbody></table>
<h3 id="伪函数Functor"><a href="#伪函数Functor" class="headerlink" title="伪函数Functor"></a>伪函数Functor</h3><p>伪函数不是一个函数，而是一个类或结构体。伪函数 <strong>必须充值<code>()</code>运算符</strong> ,通过重载<code>()</code>运算符来执行函数。</p>
<p>之所以需要伪函数是因为，在传递函数指针在函数内部调用函数，如果我们需要在函数使用一个全局变量，而不能通过在最外层设置全局变量(可能污染命名空间)，那么伪函数是类的属性就起到重要作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Func&#123;</span><br><span class="line">public:</span><br><span class="line">    Func(string str) : ss(str)&#123;&#125;</span><br><span class="line">    void operator() (string str)&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; ss &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string str;  &#x2F;&#x2F; 一旦类构造好，那它就是类的全局属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void realFunc(string str, Func myfunc)&#123;</span><br><span class="line">    myfunc(str);  &#x2F;&#x2F; 正式调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    realFunc(&quot;hello&quot;, Func(&quot;ring&quot;)); &#x2F;&#x2F; 传入时构造好</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/Major/assembly_language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/09/Major/assembly_language/" class="post-title-link" itemprop="url">汇编语言(Intel)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-09T00:00:00+08:00">2020-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-25 22:51:23" itemprop="dateModified" datetime="2020-10-25T22:51:23+08:00">2020-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>地址总线<ul>
<li>CPU通过地址总线来指定存储单元，N根导线可以传送N位二进制数，可选址$2^N$个内存单元，可表示最大的数为$2^N - 1$。</li>
</ul>
</li>
<li>数据总线<ul>
<li>CPU与内存或其他器件之间的数据传输是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传输速度。如8根数据总线一次可以传送8位(一个字节)二进制数据。</li>
</ul>
</li>
<li>控制总线<ul>
<li>CPU对外部器件的控制是通过控制总线来进行的。有多少跟控制总线就意味着CPU提供了对外部器件的多少种控制。</li>
</ul>
</li>
<li>主板<ul>
<li>主板上有核心器件和一些主要部件，这些部件通过总线(地址总线、数据总线、控制总线)相连</li>
</ul>
</li>
<li>接口卡<ul>
<li>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作</li>
</ul>
</li>
<li>各类储存器芯片<ul>
<li>从读写属性上分为两类：随机储存器(RAM)和只读储存器(ROM)<ul>
<li>随机储存器可读可写，关机后储存的内容丢失</li>
<li>只读储存器只读不能写入，关机后内容不会丢失</li>
</ul>
</li>
</ul>
</li>
<li>地址空间<ul>
<li>内存地址空间的大小受CPU地址总线宽度的限制，如CPU地址总线宽度是20,可以传送$2^{20}$个不同的地址信息。可定位$2^20$个内存单元，该CPU的内存地址空间大小为1MB</li>
</ul>
</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是CPU中程序员可以用指令读写的部件。不同的CPU寄存器的个数、结构是不同的。8086CPU有14个寄存器，每个寄存器有一个名字。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>8086CPU的所有寄存器都是16位的，可以储存两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性数据，被称为 <strong>通用寄存器</strong> 。这4个寄存器可以分为两个独立使用的8位寄存器来使用:</p>
<ul>
<li>AX可分为AH和AL<ul>
<li>AX的低8位构成了AL寄存器，高8位构成了AH寄存器，后面的同理</li>
</ul>
</li>
<li>BX可分为BH和BL</li>
<li>CX可分为CH和CL</li>
<li>DX可分为DH和DL</li>
</ul>
<h3 id="几条汇编命令"><a href="#几条汇编命令" class="headerlink" title="几条汇编命令"></a>几条汇编命令</h3><table>
<thead>
<tr>
<th>汇编命令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,18</td>
<td>将18送入寄存器AX</td>
<td>AX=18</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将寄存器bx的数据送入寄存器AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax,18</td>
<td>将寄存器AX的数值加上18</td>
<td>AX=AX+18</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>将寄存器AX的数值加上寄存器BX的数值</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。</p>
<h3 id="16位结构的CPU"><a href="#16位结构的CPU" class="headerlink" title="16位结构的CPU"></a>16位结构的CPU</h3><p>特征：</p>
<ul>
<li>运算器最多可处理16位的数据</li>
<li>寄存器的最大宽度为16</li>
<li>寄存器和运算器之间的通路为16位</li>
</ul>
<h3 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h3><p>8086CPU有20位地址总线，可以传送20位地址。8086CPU又是16位结构，在内部一次性处理、传输、暂时储存的地址为16位。</p>
<p>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址</p>
<p>8086CPU读写内存的过程如下：</p>
<ul>
<li><ol>
<li>CPU中相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</li>
</ol>
</li>
<li><ol start="2">
<li>段地址和偏移地址通过内部总线接入一个称为地址加法器的部件</li>
</ol>
</li>
<li><ol start="3">
<li>地址加法器将两个16位地址合成一个20位的物理地址</li>
</ol>
</li>
<li><ol start="4">
<li>地址加法器通过内部总线20位物理地址送入输入输出控制电路</li>
</ol>
</li>
<li><ol start="5">
<li>输入输出控制电路将20位物理地址送上地址总线</li>
</ol>
</li>
<li><ol start="6">
<li>20位物理地址被地址总线传送到储存器</li>
</ol>
</li>
</ul>
<p>地址加法器采用 <strong>物理地址=段地址×16+偏移地址</strong> 的方法合成物理地址。如1230+00C8=12300+00C8=123C8(十六进制表示)</p>
<h3 id="“物理地址-段地址×16-偏移地址”的本质含义"><a href="#“物理地址-段地址×16-偏移地址”的本质含义" class="headerlink" title="“物理地址=段地址×16+偏移地址”的本质含义"></a>“物理地址=段地址×16+偏移地址”的本质含义</h3><p>本质含义是：CPU在访问内存时，用一个基础地址(段地址×16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。(有点类似计网中的网段)</p>
<h3 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h3><p>其实内存没有分段，段的划分来自于CPU，如我们可以认为地址10000H<del>100FFH的内存单元组成一个段，基础地址为10000H，段地址为1000H;我们也可以认为10000H</del>10007FH、10080H～100FFH的内存单元为两段，基础地址为10000H和10080H，段地址为1000H和1008H。</p>
<p>在编程时根据需要，将若干地址连续的内存单元看作一个段。</p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS、DS、SS、ES。</p>
<h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3><p>CS和IP是8086CPU中最关键的两个寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器。</p>
<p>在8086PC机中，设CS中内容为M，IP中内容为N，8086CPU将从内存M×16+N单元开始，读取一条命令并执行。过程如下</p>
<ul>
<li><ol>
<li>8086CPU当前状态：CS中内容为2000H，IP中内容为0000H</li>
</ol>
</li>
<li><ol start="2">
<li>内存20000H～20009H单元中存放着的机器码对应的汇编指令如下：<ul>
<li>地址：20000H～20002H，内容：B8 23 01，长度：3Byte，对应汇编指令：mov ax，0123H</li>
<li>等等</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>CS和IP寄存器的内容传入地址加法器合成物理地址20000H</li>
</ol>
</li>
<li><ol start="4">
<li>输入输出控制电路将物理地址20000H送上地址总线</li>
</ol>
</li>
<li><ol start="5">
<li>从内存20000H单元开始存放的机器指令B8 23 01通过数据总线送入CPU</li>
</ol>
</li>
<li><ol start="6">
<li>输入输出控制电路将机器指令B8 23 01送入指令缓冲器</li>
</ol>
</li>
<li><ol start="7">
<li>IP中的值根据指令长度自动增加</li>
</ol>
</li>
<li>跳转到第1步，重复这个过程</li>
</ul>
<p>CPU工作的时候把有的信息看作指令，有的信息看作数据，那CPU根据什么将内容中的信息看着指令？</p>
<ul>
<li>CPU将CS:IP指向的内存单元中的内容看作指令，因为，在任何时候，CPU将CS、IP中的内容看作指令的段地址和偏移地址，来在内存中读取指令码</li>
</ul>
<h3 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="修改CS、IP的指令"></a>修改CS、IP的指令</h3><p>在CPU中程序员能用指令读写的部件只有寄存器，程序员可以通过寄存器实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，通过改变CS、IP中的内容来控制CPU执行目前指令。</p>
<p>8086CPU大部分寄存器的值都可以通过mov指令来改变，mov指令被称为传送指令。但mov指令不能用于设置CS、IP的值，因为8086没有提供这样的功能。要改变CS、IP的内容需要的指令被称为跳转指令。一下简单介绍jmp指令。</p>
<p>若想修改CS、IP的内容，可用<code>jmp 段地址:偏移地址</code>的指令完成，如<code>jmp 2AE3:3</code>执行后<code>CS=2AE3H, IP=0003H</code>。</p>
<p>若想仅修改IP的内容，可用形如<code>jmp 某一合法寄存器</code>的指令来完成，如<code>jmp ax</code>执行后<code>IP=ax</code>。含义上好似<code>mov IP,ax</code></p>
<h2 id="寄存器-内存访问"><a href="#寄存器-内存访问" class="headerlink" title="寄存器(内存访问)"></a>寄存器(内存访问)</h2><h3 id="内存中字的储存"><a href="#内存中字的储存" class="headerlink" title="内存中字的储存"></a>内存中字的储存</h3><p><strong>字单元的概念</strong> :字单元，即存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p>
<p>以后我们称起始地址为N的字单元简称为N地址字单元。</p>
<p>例子：<br>|   |     |<br>|—|—–|<br>| 0 | 20H |<br>| 1 | 4EH |<br>| 2 | 12H |<br>| 3 | 00H |</p>
<p>0地址单元中存放的字节型数据是：20H</p>
<p>0地址字单元中存放的字型数据是：4E20H</p>
<h3 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h3><p>CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。</p>
<p><code>mov al, [0]</code>，这个指令将内存单元中的内容送入寄存器al。”[address]”表示一个内存单元，其中<code>[0]</code>中的0表示内存单元的偏移地址。执行命令时8086CPU自动读取DS中的数据为内存单元的段地址。</p>
<p>如何把一个数据送入DS寄存器呢？我们以前用过类似<code>mov ax,a</code>这样的指令来完成，但是8086CPU不支持将数据直接放入段寄存器的操作，所有需要先将数据放入一个一般寄存器，然后把一般寄存器的内容送入DS寄存器，<code>mov ds,ax</code>。</p>
<h3 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h3><p>我们用mov指令在寄存器和内存之间进行字节型数据的传送。因为8086CPU是16位结构的，也就是说一次传送一个字。只要在mov指令中给出16位寄存器就可以进行16位的数据传送了，mov指令中给出8位寄存器就进行8位数据传输。</p>
<p>例子：<br>|   |     |<br>|—|—–|<br>| 0 | 20H |<br>| 1 | 4EH |<br>| 2 | 12H |<br>| 3 | 00H |</p>
<p><code>mov ax,[1]</code>的结果是<code>ax=124EH</code></p>
<h3 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h3><p>8086CPU提供相关的指令来以栈的方式访问内存空间，这意味着基于8086编程时，可以将一段内存当作栈来使用。</p>
<p>8086CPU提供<code>push</code>和<code>pop</code>的入栈和出栈指令。<code>push ax</code>表示将寄存器ax中的数据送入栈中，<code>pop ax</code>表示从栈顶取出数据送入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。</p>
<ul>
<li>CPU如何知道哪段地址空间被当作栈来使用？push和pop时如何知道哪个单元是栈顶单元？<ul>
<li>8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。<strong>任意时刻SS:SP指向栈顶元素</strong> 。</li>
</ul>
</li>
</ul>
<p><code>push ax</code>执行时，由一下两个两步完成</p>
<ul>
<li><ol>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶单元为新的栈顶</li>
</ol>
</li>
<li><ol start="2">
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>
</ol>
</li>
</ul>
<p>因为CPU执行顺序是从地址低到高，而栈的后进先出的结构，所以push时从后方的地址开始<br>|                |    |<br>|—————-|—-|<br>| 10000H         |    |<br>| 10001H         |    |<br>| …            |    |<br>| SS:SP-&gt;1000EH | 23 |<br>| 1000FH         | 01 |</p>
<p><code>pop ax</code>的执行过程和<code>push ax</code>刚好相反：</p>
<ul>
<li><ol>
<li>将SS:SP指向的内存单元处的数据送入ax中</li>
</ol>
</li>
<li><ol start="2">
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新栈顶</li>
</ol>
</li>
</ul>
<p>栈为空时，偏移地址的计算方法：最底部的字单元的偏移地址+2，如：<br>|                        |  |<br>|————————|–|<br>| 10000H                 |  |<br>| 10001H                 |  |<br>| …                    |  |<br>| (最底部的字单元)1000EH |  |<br>| 1000FH                 |  |<br>| SP=0010H               |  |</p>
<h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><p>将一段内存当作栈段仅仅是我们编程时的一种安排</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>字在内存中存储时，要用两个地址连续的内存单元来存放</li>
<li>用mov指令访问内存单元，可以在mov指令中给出内存单元的偏移地址，此时段地址默认在DS寄存器中</li>
<li>[address]表示一个偏移地址为address的内存单元</li>
<li>在内存和寄存器之间传送数据类型时，高地址单元和高8位寄存器、低地址单元个低8位寄存器相对应</li>
<li>mov、add、sub是具有两个操作对象的指令，jmp是具有一个操作对象的指令</li>
<li>CPU不提供栈顶越界的保护，我们要自己注意</li>
</ul>
<h2 id="一个程序"><a href="#一个程序" class="headerlink" title="一个程序"></a>一个程序</h2><h3 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程"></a>一个源程序从写出到执行的过程</h3><ul>
<li>编写汇编源程序<ul>
<li>产生一个储存源程序的文本文件</li>
</ul>
</li>
<li>对源程序进行编译链接<ul>
<li>使用编译程序对源程序进行编译生成目标文件，再用链接工具对目标文件进行链接，生成可在操作系统中直接运行的可执行文件</li>
</ul>
</li>
<li>执行</li>
</ul>
<h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><h4 id="伪命令"><a href="#伪命令" class="headerlink" title="伪命令"></a>伪命令</h4><p>在汇编语言源程序中，包含两种命令，一种是汇编指令，一种是伪指令。</p>
<ul>
<li>汇编指令是有对应机械码的指令，可以被编译为机械指令，最终被CPU执行</li>
<li>伪指令没有对应的机械码，最终不被CPU执行<ul>
<li>伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作</li>
</ul>
</li>
</ul>
<h5 id="segment和ends"><a href="#segment和ends" class="headerlink" title="segment和ends"></a>segment和ends</h5><p>segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时必须要用的一对为指令。segment和ends的功能是定义一个段，一个段必须有一个名称来标识，格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">    ...</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure>

<p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到不同的段中。</p>
<h5 id="end"><a href="#end" class="headerlink" title="end"></a>end</h5><p>end是一个汇编程序的结束标记，如果碰到了伪指令end，就结束对 <strong>源程序</strong> 的编译。所以我们在写程序的时候，如果程序写完了，要在结尾出加上伪指令end。否则编译器无法知道何时结束。</p>
<p>注意，不要搞混end和ends，ends是和segment成对使用的，标记一个段的结束。而end是标记整个程序的结束。</p>
<h5 id="assume"><a href="#assume" class="headerlink" title="assume"></a>assume</h5><p>这个为指令含义为”假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</p>
<p>如下就是将一个把一个叫做code的段和cs段寄存器联系起来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    ...</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>

<h4 id="源程序中的”程序”"><a href="#源程序中的”程序”" class="headerlink" title="源程序中的”程序”"></a>源程序中的”程序”</h4><p>程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机械码，储存在可执行文件中</p>
<h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为：程序返回。</p>
<p>在程序末尾使用两条指令可以实现程序返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>


<h2 id="BX-和loop命令"><a href="#BX-和loop命令" class="headerlink" title="[BX]和loop命令"></a>[BX]和loop命令</h2><ul>
<li>用[address]表示一个内存单元时，单元的长度(类型)可以由具体指令中的其他操作对象(比如说寄存器)指出，如<code>mov al,[0]</code>这个内存单元就是一字节</li>
<li>[bx]同样也表示一个内存单元，它的偏移地址在bx中</li>
<li>loop进行循环</li>
<li>约定符号idata表示常量</li>
<li>我们将使用符号”()”来表示一个寄存器或一个内存单元中的内容</li>
</ul>
<h3 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h3><p>看看如下命令的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>

<p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA中的数据送入ax，即:(ax)=((ds)*16+(bx))</p>
<p>值得注意的是，bx是寄存器，可以使用一些指令，如：<code>inc bx</code>。就可以方便的完成某些任务，如：把每个内存单元的内容变为1。</p>
<h3 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h3><p>loop指令的格式是：loop标号，CPU执行loop指令的时候，要进行两部操作：1. (cx)=(cx)-1; 2. 判断cx中的值，不为零则跳转至标号处执行程序，否则向下执行。</p>
<p>可以看到cx中的值影响着loop指令的结果，通常我们在cx中存放循环次数</p>
<p>例：计算2^12。(N*2=N+N)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,11</span><br><span class="line">s:  add ax,ax</span><br><span class="line">    loop s</span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行loop时(cx)先减1,然后若(cx)不为0，则跳转到s处。从上面的例子可以总结出用cx和loop配合实现循环的3个要点：</p>
<ul>
<li><ol>
<li>在cx中存放循环次数</li>
</ol>
</li>
<li><ol start="2">
<li>loop指令中的标号所标识地址要在前面</li>
</ol>
</li>
<li><ol start="3">
<li>要循环的程序段，要写在标号和loop指令中间</li>
</ol>
</li>
</ul>
<p>用cx和loop指令配合的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">    循环执行的程序段</span><br><span class="line">    loop s</span><br></pre></td></tr></table></figure>


<h3 id="loop和-bx-的联合应用"><a href="#loop和-bx-的联合应用" class="headerlink" title="loop和[bx]的联合应用"></a>loop和[bx]的联合应用</h3><p>若我们想要计算ffff:0~ffff:b单元中的元素的和，结果储存在dx中，分析：</p>
<ul>
<li><ol>
<li>dx是16位的寄存器，内存单元不能直接加到dx中，因为如果直接加会自动区一个字的大小，不满足题意</li>
</ol>
</li>
<li><ol start="2">
<li>不能用dl来做累加操作，因为dl大小不足以容纳所有内存单元的和导致进位丢失</li>
</ol>
</li>
</ul>
<p>所以我们需要引入一个16位寄存器ax作为中介，先把内存单元的内容送如al，在用ax和dx相加，通过bx和loop就可以完成。</p>
<h3 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h3><p>段地址默认在ds中，我们可以在访问的内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。如：<code>mov ax,ds:[bx]</code></p>
<h3 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h3><p>任意向一段内存空间写入内容是很危险的，因为这段内存空间可能存放着系统数据或代码。</p>
<h2 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h2><p>程序取得所需空间的方法有两种，一种是加载程序的时候为程序分配，另一种是程序在执行的过程中向系统申请。我们将介绍第一种。</p>
<p>我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。</p>
<h3 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h3><p>考虑这样一个问题，编程计算一下8个数据的和，结果存在ax寄存器中：2134h、5342h、6563h、…。如何将这些数据储存在一组地址连续的内存单元中？又在哪找到这段内存空间？</p>
<p>我们可以在程序中，定义我们希望处理的数据，这些数据会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也会被加载如内存中。这些数据自然而然地获得了储存空间。</p>
<p>具体看下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line"></span><br><span class="line">    mov ax,2345h</span><br><span class="line">    some code...</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>程序开头”dw”的含义是定义字型数据(define word)。那这些个数据在哪里呢？由于它们在代码段中，程序在运行的时候CS中存放代码段的地址，所以可以从CS中的到他们的段地址。那它们的偏移地址是多少？因为用dw定义的数据处于代码最开始，所以偏远地址为0～E。</p>
<p>但是编译、连接成可执行文件后，在系统直接运行可能出现问题，因为在程序的入口处不是我们希望执行的指令(而是一些数据)。因此，我们可以在源程序中指明程序的入口所在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line"></span><br><span class="line">    start:  mov ax,2345h   ; &lt;---- 在程序的第一条指令的前面加上标号start</span><br><span class="line"></span><br><span class="line">            some code...</span><br><span class="line">code ends</span><br><span class="line">end start       ; &lt;----</span><br></pre></td></tr></table></figure>

<p>在程序的第一条指令的前面加上标号start，这个标号在伪命令end的后面出现，用于通知编译器程序的入口在什么地方。</p>
<p>回顾可执行文件中的程序执行过程如下：</p>
<ul>
<li><ol>
<li>有其他的程序(shell等)将可执行文件中的程序加载入内存</li>
</ol>
</li>
<li><ol start="2">
<li>设置CS:IP指向程序的第一条要执行的指令(程序入口)，从而使程序得以运行</li>
</ol>
</li>
<li><ol start="3">
<li>程序结束后，返回到加载者</li>
</ol>
</li>
</ul>
<p>现在问题是，根据什么设置CPU的CS:IP指向程序的第一条要执行的指令？这一点，是由可执行文件中的描述信息指明的。可执行文件由描述信息和程序组成：程序来自源程序中的汇编指令和定义的数据;描述信息则主要是通过编译、连接程序对源程序中相关的伪指令进行处理所得到的信息。</p>
<h3 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h3><p>我们首先要有一段可当作栈的空间，可在程序中通过定义数据来获取一段空间，然后将这段空间当作栈空间来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">                            ;用dw定义8个字型数据，加载程序后将获得8个字的内存空间，这段空间可当作栈使用</span><br><span class="line"></span><br><span class="line">    start:      mov ax,cs</span><br><span class="line">                mov ss,ax</span><br><span class="line">                mov sp,20h  ;将栈顶ss:sp指向cs:20h</span><br><span class="line">                </span><br><span class="line">                some code...</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这段程序中定义了8个字型数据，它们的值都是0。这8个数据的值是多少对程序来说没有意义，只是用它们来开辟内存。</p>
<h3 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h3><p>我们在编程的时候要主要何处是数据，何处是代码，何处是栈。这样显然就有两个问题：</p>
<ul>
<li>把它们放在一个段中使程序显得混乱</li>
<li>一个段的容量是受限的，如果数据、栈和代码都放在一个段中，空间可能就不够</li>
</ul>
<p>所以用多个段来存放数据、代码和栈。我们用定义代码段一样的方法定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来获取栈空间。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,20h  ;设置栈顶ss:sp指向stack:20</span><br><span class="line">        ...</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li>定义了多个段方法<ul>
<li>对于不同的段，要用不同的段名</li>
</ul>
</li>
<li>对段地址引用<ul>
<li>段名就相当于一个符号，它代表这段地址</li>
</ul>
</li>
</ul>
<h2 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h2><h3 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h3><ul>
<li>and指令：逻辑与指令，按位进行运算<ul>
<li>通过该指令可将操作对象相应位设备0，其他位不变</li>
</ul>
</li>
<li>or指令：逻辑或指令，按位进行运算<ul>
<li>通过该指令可将操作对象相应位设备1，其他位不变</li>
</ul>
</li>
</ul>
<h3 id="以字符形式给出的数据"><a href="#以字符形式给出的数据" class="headerlink" title="以字符形式给出的数据"></a>以字符形式给出的数据</h3><p>可以在汇编程序中，用’…’的方式指明数据是以字符的形式给出的，编译器将它们转化成对应的ASCII码。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    db &#39;unIX&#39;  ;; db是define binary，用一个字节储存，与dw同理</span><br><span class="line">data ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>“db ‘unIX’”就相当于”db 75H, 6EH, 49H, 58H”</p>
<h3 id="大小写转换的问题"><a href="#大小写转换的问题" class="headerlink" title="大小写转换的问题"></a>大小写转换的问题</h3><p>常规的解法是ASCII码加上或减去一个数，但是我们还没说到条件控制，该怎么办呢？寻找新的规律可以看到，就ASCII码的二进制形式来看，除了第5位外，大写字母和小写字母的其他位都一样。因此我们要了新的方法：将第5位变为0或1就能改变成大小写了。</p>
<h3 id="用-bx-idata-的方式进行数组的处理"><a href="#用-bx-idata-的方式进行数组的处理" class="headerlink" title="用[bx+idata]的方式进行数组的处理"></a>用[bx+idata]的方式进行数组的处理</h3><p>我们知道在C语言中，数组实际上就是一段连续的内存空间。假设第一个数长5个字节，第二个数组有5个字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[bx]  ;; 定位第一个数组</span><br><span class="line">mov al,[5+bx]  ;; 定位第二个数组</span><br><span class="line">;;或写成</span><br><span class="line">mov al,5[bx]</span><br></pre></td></tr></table></figure>

<p>和C语言对比：</p>
<ul>
<li>C语言<ul>
<li><code>a[i], b[i]</code></li>
</ul>
</li>
<li>汇编语言<ul>
<li><code>0[bx], 5[bx]</code></li>
</ul>
</li>
</ul>
<h3 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h3><p>si和di是8086CPU中和bx功能近似的寄存器，si和di不能分成两个8位寄存器来使用。</p>
<p>我们可以灵活使用[bx+si+idata]和[bx+di+idata]来表示一个内存单元。</p>
<p>-对于[bx+si]和[bx+di]，有指令<code>mov ax,[bx+si]</code>等，该指令也可以写出如下格式(常用)<br>    - <code>mov ax,[bx][si]</code><br>-对于[bx+si+idata]和[bx+di+idata]，有指令<code>mov ax,[bx+si+200]</code>等，该指令也可以写出如下格式(常用)<br>    - <code>mov ax,200[bx][si]</code><br>    - <code>mov ax,[bx][si].200</code><br>    - <code>mov ax,[bx].200[si]</code></p>
<h2 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h2><ul>
<li><ol>
<li>处理的数据在什么地方?</li>
</ol>
</li>
<li><ol start="2">
<li>要处理的数据有多长?</li>
</ol>
</li>
</ul>
<p>我们定义两个描述性符号：reg和sreg。reg表示寄存器;sreg表示段寄存器。</p>
<h3 id="bx、si、di和bp"><a href="#bx、si、di和bp" class="headerlink" title="bx、si、di和bp"></a>bx、si、di和bp</h3><p>前面三个寄存器已经讲过，现在来进行一下总结：</p>
<ul>
<li><ol>
<li>在8086CPU中，只有这4个寄存器可以用在[…]中来进行内存单元的寻址</li>
</ol>
</li>
<li><ol start="2">
<li>在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di</li>
</ol>
</li>
<li><ol start="3">
<li>只要在[…]中使用寄存器bp，而指令没有显性地给出段地址，段地址默认在ss中</li>
</ol>
</li>
</ul>
<h3 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h3><p>汇编语言中用3个概念来表达数据的位置：</p>
<ul>
<li>立即数(idata)<ul>
<li>对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器中)，在汇编语言中称为：立即数，在汇编指令中直接给出</li>
</ul>
</li>
<li>寄存器<ul>
<li>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名</li>
</ul>
</li>
<li>段寄存器(SA)和偏移地址(EA)<ul>
<li>指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中(如ds)</li>
</ul>
</li>
</ul>
<h3 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h3><p>8086CPU的指令，可以处理两种尺寸的数据：byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。汇编语言用以下方法处理：</p>
<ul>
<li>根据寄存器名指明要处理的数据的尺寸</li>
<li>在没有寄存器名存在的情况下，用操作符<code>X ptr</code>指明内存单元的长度，X在汇编指令中可以为word或byte<ul>
<li>如：<code>mov word ptr ds:[0],1</code></li>
</ul>
</li>
<li>其他方法<ul>
<li>这些指令默认了访问的是字单元还是字节单元，如<code>push [1000H]</code>push指令只进行字操作</li>
</ul>
</li>
</ul>
<h3 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h3><p>div是除法指令，使用div做除法时应注意以下问题：</p>
<ul>
<li>除数：有8位和16位两种，在一个reg或内存单元中</li>
<li>被除数：默认放在AX或DX和AX中<ul>
<li>如果除数是8位，被除数则为16位，默认在AX中存放</li>
<li>如果除数是16位，被除数则为32位，默认在DX和AX中存放，DX存放高16位，AX存放低16位</li>
</ul>
</li>
<li>结果<ul>
<li>如果除数为8位，则AL储存除法操作的商，AH储存除法操作的余数</li>
<li>如果除数为16位，则AX储存除法操作的商，DX储存除法操作的余数</li>
</ul>
</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br></pre></td></tr></table></figure>

<p>例：计算100001/100</p>
<p>被除数100001远大于65535，所以只能用dx和ax两个寄存器联合存放100001(32位)。除数小于255,可以在一个8位寄存器中存放。但是因为被除数是32位的，除数应该为16位，所以用一个16位的寄存器储存100.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>


<h3 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h3><p>dd是用来定义dword(double word，双字)类型数据的</p>
<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p>dup是一个操作符，在汇编语言中和db、dw、dd等一样，也是由编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0,1,2)</span><br></pre></td></tr></table></figure>

<p>定义了9个字节，相当于<code>db 0,1,2,0,1,2,0,1,2</code></p>
<p>dup的使用格式如下：</p>
<ul>
<li>db 重复的次数 dup (重复的字节型数据)</li>
<li>dw 重复的次数 dup (重复的字型数据)</li>
<li>dd 重复的次数 dup (重复的双字型数据)</li>
</ul>
<h2 id="转移指令的原理"><a href="#转移指令的原理" class="headerlink" title="转移指令的原理"></a>转移指令的原理</h2><p><strong>可以修改IP，或同时修改CS和IP的指令统称为转移指令</strong>。</p>
<p>8086CPU的转移指令行为有以下几类：</p>
<ul>
<li>只修改IP时，称为段内转移，如：<code>jmp ax</code> </li>
<li>同时修改CS和IP时，称为段间转移，如：<code>jmp 1000:0</code></li>
</ul>
<h3 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h3><p>offset是由编译器处理的符号，它的功能是取得标号的偏移地址。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start:mov ax,offset start   ;; 相当于mov ax,0</span><br><span class="line">        s:mov ax,offset s       ;; 相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面的程序中，offset操作符取得了标号start和s的偏移地址0和3。</p>
<h3 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h3><p><code>jmp short 标号</code>转到标号处执行指令</p>
<p>这种格式的jmp指令实现的是段内短转移，它对IP修改的范围为-128~127，即最多可以向前跨越128个字节，向后127个字节。指令中的”标号”是代码段中的标号，指明了指令要转移的目的地，跳转指令结束后，CD:IP应该指向标号处的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start:mov mov ax, 0   </span><br><span class="line">          jmp short s</span><br><span class="line">          add ax, 1</span><br><span class="line">        s:inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面的程序就跳过了<code>add ax, 1</code></p>
<p><code>jmp short</code>依据位移进行转移，也就是说CPU执行jmp指令的时候并不需要转移的目的地址，只需要转移的位移，编译器后计算jmp到标号的位移。</p>
<p><code>jmp short 标号</code>的功能为：(IP)=(IP)+8位位移</p>
<ul>
<li>8位位移=标号处的地址-jmp指令后的第一个字节的地址</li>
<li>short指明此处的位移为8位位移</li>
<li>8位位移的范围为-127~128，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
<p>还有一种与<code>jmp short</code>功能类似的指令，<code>jmp near ptr 标号</code>，它实现的是段内转移，功能为：(IP)=(IP)+16</p>
<ul>
<li>17位位移=标号处的地址-jmp指令后的第一个字节的地址</li>
<li>near ptr指明此处的位移为16位位移</li>
<li>16位位移的范围为-32768~32767，用补码表示</li>
<li>16位位移由编译程序在编译时算出</li>
</ul>
<h3 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h3><p><code>jmp far ptr 标号</code>实现的是段间转移，又称远转移，功能如下：</p>
<ul>
<li>(CS)=标号所在的段地址;(IP)=标号所在段中的偏移地址。</li>
<li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP</li>
</ul>
<h3 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h3><p>转移地址在内存中的jmp指令有两种格式：</p>
<ul>
<li><code>jmp word ptr 内存单元地址(段内地址)</code><ul>
<li>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址</li>
</ul>
</li>
<li><code>jmp dword ptr 内存单元地址(段内地址)</code><ul>
<li>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处的转移的目的偏移地址</li>
<li>(CS)=(内存单元地址+2)</li>
<li>(IP)=(内存单元地址)</li>
</ul>
</li>
</ul>
<h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是转移的目的地址。对IP的修改范围都是：-127~128</p>
<p>指令格式：<code>jcxz 标号</code>如果(cx)=0，则转移到标号处执行</p>
<ul>
<li>操作：当(cx)=0时，(IP)=(IP)+8位位移<ul>
<li>8位位移=标号处的地址-jcxz指令后的第一个字节的地址</li>
<li>8位位移的范围为-127~128，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
</li>
<li>当(cx)!=0时，什么也不做，程序向下执行</li>
</ul>
<p>用C语言的话说，<code>jcxz 标号</code>的功能相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((cx)==<span class="number">0</span>)jmp short 标号;</span><br></pre></td></tr></table></figure>


<h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是转移的目的地址。对IP的修改范围都是：-127~128</p>
<p>指令格式：<code>loop 标号</code>(cx)=(cx)-1，如果(cx)!=0，则转移到标号处执行</p>
<ul>
<li>操作：(cx)=(cx)-1;如果(cx)!=0,(IP)=(IP)+8位位移<ul>
<li>8位位移=标号处的地址-jcxz指令后的第一个字节的地址</li>
<li>8位位移的范围为-127~128，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
</li>
<li>当(cx)=0时，什么也不做，程序向下执行</li>
</ul>
<p>用C语言的话说，<code>loop 标号</code>的功能相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line"><span class="keyword">if</span>((cx)!=<span class="number">0</span>)jmp short 标号;</span><br></pre></td></tr></table></figure>


<h3 id="根据位移转移的意义"><a href="#根据位移转移的意义" class="headerlink" title="根据位移转移的意义"></a>根据位移转移的意义</h3><p>这种设计方便了程序段在内存中的浮动配置。这段程序在内存中的不同位置都可以正确执行，只需要位移，而不需要具体的地址。因为当指令不存在具体地址处时，程序执行就会出错。</p>
<h2 id="CALL和RET指令"><a href="#CALL和RET指令" class="headerlink" title="CALL和RET指令"></a>CALL和RET指令</h2><p>call和ret指令都是转移指令，它们修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序(函数)的设计</p>
<h3 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h3><ul>
<li>ret指令用栈中的数据修改IP的内容，从而实现转移。执行ret指令时，进行下面两步操作：<ul>
<li><ol>
<li>(IP)=((ss)*16+(sp))<ul>
<li>出栈</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>(sp)=(sp)+2</li>
</ol>
</li>
<li>相当于<code>pop IP</code></li>
</ul>
</li>
<li>retf指令用栈中的数据修改cs和ip的内容，从而实现转移。执行retf指令时，进行下面4步操作：<ul>
<li><ol>
<li>(IP)=((ss)*16+(sp))</li>
</ol>
</li>
<li><ol start="2">
<li>(sp)=(sp)+2</li>
</ol>
</li>
<li><ol start="3">
<li>(CS)=((ss)*16+(sp))</li>
</ol>
</li>
<li><ol start="4">
<li>(sp)=(sp)+2</li>
</ol>
</li>
<li>相当于<code>pop IP; pop CS</code></li>
</ul>
</li>
</ul>
<h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>CPU执行call指令时，进行两步操作：</p>
<ul>
<li><ol>
<li>将当前的IP或CS和IP压入栈中</li>
</ol>
</li>
<li><ol start="2">
<li>转移</li>
</ol>
</li>
</ul>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令了原理相同</p>
<p>一下介绍call指令的主要应用格式</p>
<h3 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h3><p><code>call 标号</code>，将当前的IP压入栈后，转到标号处执行指令</p>
<p>CPU执行此种格式的call指令时，进行的操作如下：</p>
<ul>
<li><ol>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<ul>
<li>入栈，栈顶指针上移</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>(IP)=(IP)+16位位移<ul>
<li>根据标号</li>
</ul>
</li>
</ol>
</li>
<li>相当于:<code>push IP;jmp near ptr 标号</code></li>
</ul>
<h3 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h3><p><code>call far ptr 标号</code>，实现的是段间转移，CPU执行这种格式的call指令时，操作如下：</p>
<ul>
<li><ol>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(CS)<br>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<ul>
<li>入栈</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>(CS)=标号所在段的段地址<br>(IP)=标号所在段中的偏移地址</li>
</ol>
</li>
<li>相当于<br><code>push CS</code><br><code>push IP</code><br><code>jmp far ptr 标号</code></li>
</ul>
<h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p>格式:<code>call 16位reg</code>。功能：</p>
<ul>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(IP)=(16位reg)</li>
<li>相当于：<br><code>push IP</code><br><code>jmp 16位reg</code></li>
</ul>
<h3 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h3><p>转移地址在内存中的call指令有两种格式：</p>
<ul>
<li><code>call word ptr 内存单元地址</code><ul>
<li>相当于：<br><code>push IP</code><br><code>jmp word ptr 内存单元地址</code></li>
</ul>
</li>
<li><code>call dword ptr 内存单元地址</code><ul>
<li>相当于：<br><code>push CS</code><br><code>push IP</code><br><code>jmp dword ptr 内存单元地址</code></li>
</ul>
</li>
</ul>
<h3 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h3><p>我们可以写一个具有一定功能的程序段，我们称之为子程序，在需要的时候用call指令转去执行。执行完后用ret指令，用栈中的数据设置IP值，从而跳到call的下一条指令继续执行。</p>
<p>这样，我们可以利用call和ret来实现子程序的机制。子程序的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号：</span><br><span class="line">    指令</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>具有子程序的源程序的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    main:</span><br><span class="line">        :</span><br><span class="line">        call sub1   ;;调用子程序1</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    sub1:</span><br><span class="line">        :</span><br><span class="line">        call sub2</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    sub2:</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>

<p>使用call和ret可以实现模块化设计</p>
<h3 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h3><p>mul是乘法指令，使用mul时注意以下两点：</p>
<ul>
<li><ol>
<li>两个相乘的数：两个数要么都是8位，要么都是16位<ul>
<li>如果是8位乘法，一个默认放在AL中，另一个放在8位reg或内存字节单元中</li>
<li>如果是16位乘法，一个默认在AX中，另一个放在16为reg或内存字单元中</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>结果：<ul>
<li>8位乘法结果默认放在AX中</li>
<li>16位乘法结果高位默认放在DX中，低位放在AX中</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">;; 内存单元可以用不同的寻址方式给出：</span><br><span class="line">mul byte ptr ds:[0]</span><br><span class="line">mul word ptr [bx+si+8]</span><br></pre></td></tr></table></figure>


<h3 id="参数和结果传递的问题"><a href="#参数和结果传递的问题" class="headerlink" title="参数和结果传递的问题"></a>参数和结果传递的问题</h3><p>既然知道了如何调用子程序，那应该如何储存子程序需要的参数和产生的返回值呢？</p>
<ul>
<li>显然可以用寄存器来存。</li>
</ul>
<p>那么如果有N个参数和结果，寄存器的个数是有限的，该怎么存放呢？</p>
<ul>
<li>这个时候没将批量的数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给子程序。对于批量的结果也如此的方法。</li>
</ul>
<p><strong>看下面一个例子:</strong> 设计一个子程序，将一个全是字母的字符串转换为大写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#39;conversation&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:  mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0        ;ds:si指向字符串所在空间的首地址</span><br><span class="line">            mov cx,12       ;cx存放字符串的长度</span><br><span class="line">            call capital    ;调用子程序，就像调用函数</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">    capital:and byte ptr [si],11011111b</span><br><span class="line">            inc si</span><br><span class="line">            loop capital</span><br><span class="line">            ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数</strong></p>
<h4 id="用栈来传递参数"><a href="#用栈来传递参数" class="headerlink" title="用栈来传递参数"></a>用栈来传递参数</h4><p>由调用者将要传递给子程序的参数压入栈中，子程序从栈中取得参数。</p>
<ul>
<li>编写一个函数：计算(a-b)^3，a、b为字型数据，参数为a、b</li>
<li>栈顶存放IP、后面依次是a、b(注意参数顺序)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func:   push bp         ;子程序用到寄存器bp，先保存原来的值</span><br><span class="line">        mov bp,sp</span><br><span class="line">        mov ax,[bp+4]   ;将栈中a送入ax</span><br><span class="line">        sub ax,[bp+6]   ;减栈中b的值</span><br><span class="line">        mov bp,ax</span><br><span class="line">        mul bp</span><br><span class="line">        mul bp</span><br><span class="line">        pop bp</span><br><span class="line">        ret 4</span><br></pre></td></tr></table></figure>

<p>指令<code>ret 4</code>的含义用汇编语法描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip      ;即返回ip，并使将栈顶指针该为调用前的值。应为这个例子的参数是两个字，所以是4.</span><br><span class="line">add sp,n</span><br></pre></td></tr></table></figure>

<p>看一下对这个函数是如何调用的，设a=3、b=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mob ax,1</span><br><span class="line">push ax</span><br><span class="line">mov ax,3    ;注意顺序</span><br><span class="line">push ax</span><br><span class="line">call func</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>低地址单元</th>
</tr>
</thead>
<tbody><tr>
<td>BP</td>
</tr>
<tr>
<td>IP</td>
</tr>
<tr>
<td>3  [bp+4]</td>
</tr>
<tr>
<td>1  [bp+6]</td>
</tr>
<tr>
<td>高地址单元</td>
</tr>
</tbody></table>
<h3 id="寄存器冲突的问题"><a href="#寄存器冲突的问题" class="headerlink" title="寄存器冲突的问题"></a>寄存器冲突的问题</h3><p>问题在于：<strong>子程序中的寄存器，很可能在组程序中也要使用，造成寄存器使用上的冲突</strong></p>
<p>我们希望：</p>
<ul>
<li>编写调用子程序的时候不必关心子程序到底使用了那些寄存器</li>
<li>编写子程序的时候不必关心调用者使用了哪些寄存器</li>
<li>不会发生寄存器冲突</li>
</ul>
<p>解决这个问题的间捷方法是，在子程序的开始将子程序中所有用到的内容保存起来，在子程序返回前恢复。可以用栈来保存寄存器中的内容</p>
<p>以后我们编写子程序的标准框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序开始: 子程序使用的寄存器入栈</span><br><span class="line">            子程序内容</span><br><span class="line">            子程序中使用的寄存器出栈</span><br><span class="line">            返回(ret、retf)</span><br></pre></td></tr></table></figure>

<p>看下面一个例子，将一个全是字母，以0结尾的字符串转换为大写的子程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">capital:    push cx  ;使用的寄存器入栈</span><br><span class="line">            push si</span><br><span class="line"></span><br><span class="line">change:     mov cl,[si]</span><br><span class="line">            mov ch,0</span><br><span class="line">            jcxz ok</span><br><span class="line">            and byte ptr [si],11011111b</span><br><span class="line">            inc si</span><br><span class="line">            jmp short change</span><br><span class="line"></span><br><span class="line">        ok: pop si  ;使用的寄存器出栈</span><br><span class="line">            pop cx</span><br><span class="line">            ret</span><br></pre></td></tr></table></figure>


<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>在CPU内部的寄存器中，有一种特殊的寄存器(不同的CPU，个数结构可能不同)具有以下3种作用：</p>
<ul>
<li>用来存储相关指令的某些执行结果</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPu的相关工作方式</li>
</ul>
<p>这种特殊的寄存器在8086CPU中，被称为 <strong>标志寄存器</strong> 。以下称为flag寄存器。</p>
<p>8086CPU的flag寄存器的结构如下：</p>
<table>
<thead>
<tr>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>OF</td>
<td>DF</td>
<td>IF</td>
<td>TF</td>
<td>SF</td>
<td>ZF</td>
<td></td>
<td>AF</td>
<td></td>
<td>PF</td>
<td></td>
<td>CF</td>
</tr>
</tbody></table>
<h3 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h3><p>flag的第6位是ZF，零标志位。它记录相关指令执行后其结果是否为0。如果结果为0,则zf=1;否则zf=0。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br><span class="line"></span><br><span class="line">;zf&#x3D;1</span><br></pre></td></tr></table></figure>

<p>在8086CPU的指令集中，有的指令执行是影响标志位寄存器的，如：add、sub、mul、div、and、or等，它们大多都是运算指令;有的指令是不影响的，如mov、push、pop等，它们大多都是传送指令。</p>
<h3 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h3><p>flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数是偶数，pf=1。否则pf=0。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br><span class="line"></span><br><span class="line">;结果是00001011b，有奇数个1，pf&#x3D;0</span><br></pre></td></tr></table></figure>


<h3 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h3><p>flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果(对于有符号数)是否为负。如果结果为负，sf=1，否则sf=0。</p>
<p>计算机通常使用补码来表示有符号数，对于无符号数SF的值没有意义，虽然相关指令影响了它的值。</p>
<h3 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h3><p>flag的第0位是CF，进位标志。一般情况下，进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p>
<p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，就是它的最高有效位。</p>
<h3 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h3><p>由于进行有符号数运算的时候，可能发生溢出造成结果错误。则CPU需要对指令执行后产生的溢出进行记录。</p>
<p>flag的第11位是OF，溢出标志。一般情况下，OF记录了有符号数运算的结果是否溢出了。如果溢出，OF=1，否则OF=0。</p>
<p>注意CF和OF的区别：CF是对无符号数有意义的标志位，OF是对无符号数有意义的标志位。</p>
<h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><p>adc是带进位加法指令，它利用了CF上记录的进位值。</p>
<ul>
<li>指令格式：<code>adc 操作对象1 操作对象2</code></li>
<li>功能：操作对象1 = 操作对象1 + 操作对象2 + CF</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax  ;1-2借位，CF&#x3D;1</span><br><span class="line">adc ax,1   ;执行后(ax)&#x3D;4&#x3D;(ax)+1+CF</span><br></pre></td></tr></table></figure>

<p>在执行adc指令的时候加上的CF的值的含义，由adc指令前的指令决定的。</p>
<p>CPU提供adc指令是有目的的，就是来进行加法的第二步运算。</p>
<p>例：计算1EF0001000H+2010001EF0H，结果放在ax(最高16位)，bx(次高16位)，cx(低16位)中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">mov cx,1000H</span><br><span class="line">add cx,1EF0H</span><br><span class="line">adc bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure>


<h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>sbb是带借位减法指令，它利用CF位上记录的借位值。应用思路类似adc</p>
<h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果，而是cmp指令执行后对标志寄存器产生影响。</p>
<ul>
<li>cmp指令格式：<code>cmp 操作对象1 操作对象2</code></li>
<li>功能：操作对象1-操作对象2但不保留结果，仅仅根据结算结果来对标志寄存器进行设置</li>
<li>如，<code>cmp ax,ax</code>，结果为0，那么标志寄存器：zf=1,pf=1,sf=0,cf=0,of=0。</li>
</ul>
<p>cmp的使用非常灵活，如要判断两个数相减的结果是不是负数：cmp将结果在flag中记录，通过判断sf(正负)和of(溢出)就可得知逻辑上真正结果的正负。</p>
<h3 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h3><p>除了jcxz指令之外，CPU还提供了其他条件转移指令，大多数条件转移指令通过检测相关的标志位，根据检测的结果修改IP。通常和cmp配合使用。</p>
<p>下面是常用的条件转移指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<h3 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h3><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p>
<ul>
<li>df=0，每次操作后si、di递增</li>
<li>df=1，每次操作后si、di递减</li>
</ul>
<p>看下面一个串传送指令：</p>
<ul>
<li>格式：<code>movsb</code></li>
<li>功能：将ds:si指向的内存单元中的字节送入es:di中。执行movsb指令相当于进行下面几步操作<ul>
<li><ol>
<li>((es)*16+(di))=((ds)*16+(si))</li>
</ol>
</li>
<li><ol start="2">
<li>如果df=0，则(si)=(si)+1;(di)=(di)+1</li>
</ol>
</li>
<li><ol start="2">
<li>如果df=1，则(si)=(si)-1;(di)=(di)-1</li>
</ol>
</li>
</ul>
</li>
<li>相当于：<br>  <code>mov es:[di], byte ptr ds:[si]</code><br>  如果df=0：<code>inc si;inc di</code><br>  如果df=1：<code>dec si;dec di</code>  </li>
<li>传送一个字的指令是<code>movsw</code></li>
</ul>
<p>movsb和movsw进行的是串传送操作中的一个步骤，一般来说movsb和mobsw都是配合rep使用的，个是如下</p>
<ul>
<li><code>rep movsb</code><ul>
<li>类似于:<br><code>s:movsb</code><br><code>loop s</code></li>
</ul>
</li>
<li>rep的作用是根据cx的值，重复后面的串传送指令</li>
</ul>
<p>由于df位决定着串传送指令执行后，si和di是递增还是递减，所以CPU应提供对df进行设置的操作。在8086CPU中：</p>
<ul>
<li>cld指令：将标志位寄存器的df设置为0</li>
<li>std指令：将标志位寄存器的df设置为1</li>
</ul>
<h3 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h3><p>pushf的功能是将标志寄存器的值压入栈中，而popf是从栈中弹出数据，送入标志寄存器中。这也是为什么前面讲标志寄存器结构时，强调什么是第几位的原因。</p>
<p>pushf和popf，为直接访问标志寄存器提供了一种方法。</p>
<h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><p>任何一个通用CPU都具备一种能力：在执行完当前正在执行的指令之后，检测到从CPU外发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种信息称为中断信息。中断的意思是指，CPU不再接着向下执行，而是转去处理这个特殊的信息。</p>
<h3 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h3><p>当CPU内部有什么事情发生时会马上处理中断信息呢？对于8086CPU，有以下情况发生时，将产生中断信息：</p>
<ul>
<li>除法错误</li>
<li>单步执行</li>
<li>执行into指令</li>
<li>执行int指令</li>
</ul>
<p>不同的信息需要不同的处理方式。中断信息中包含识别来源的编码，8086CPU用称为中断类型码来识别信息的来源。中断类型码为一个字节，可以表示256种中断信息来源。在8086CPU中：</p>
<ul>
<li>除法错误:0</li>
<li>单步执行:1</li>
<li>执行into指令:4</li>
<li>执行int指令：该指令的格式为<code>int n</code>，n是立即数，是提供给CPU的中断类型码</li>
</ul>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>CPU收到中断信息后，需要对信息进行处理。如何处理可以由我们编程决定。我们所编写的中断信息处理程序称为中断处理程序。</p>
<p>CPU在收到中断信息后，应该转去(改变CS:IP指向)对应的中断处理程序中。中断类型码就是用来定位中断处理程序的。</p>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢？</p>
<ul>
<li>CPU通过中断向量表找到相应的中断处理程序入口地址。中断向量表就是中断处理程序入口地址的列表。</li>
</ul>
<p>CPU如何找到中断向量表？</p>
<ul>
<li>中断向量表在内存中存放，在8086CPU中，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF的1024个内存单元中存放着中断向量表。</li>
</ul>
<h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。所以在中断过程中，在设置CS:IP之前，还要将原来的CS和IP的值保存起来。与call指令调用子程序同理。</p>
<p>下面是8086CPU收到中断信息后，所引发中断的过程：</p>
<ul>
<li><ol>
<li>获取中断类型码</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈</li>
</ol>
</li>
<li><ol start="3">
<li>设置标志寄存器的第8位TF和第9位IF值为0，因为这也两个标志寄存器也可以是触发中断的因素</li>
</ol>
</li>
<li><ol start="4">
<li>CS内容入栈</li>
</ol>
</li>
<li><ol start="5">
<li>IP内容入栈</li>
</ol>
</li>
<li><ol start="6">
<li>从内存地址为<code>中断类型码*4</code>和<code>中断类型码*4+2</code>的两个字单元中读取中断处理程序的入口地址设置IP和CS</li>
</ol>
</li>
</ul>
<h3 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h3><p>由于CPU随时可能检测到中断信息，所以中断处理程序必须一直储存来内存的某段空间之中，而中断向量必须存储在对应的中断向量表项中。</p>
<p>中断处理程序的编写方法和子程序比较相似，步骤如下：</p>
<ul>
<li><ol>
<li>保存用到的寄存器</li>
</ol>
</li>
<li><ol start="2">
<li>处理中断</li>
</ol>
</li>
<li><ol start="3">
<li>恢复用到的寄存器</li>
</ol>
</li>
<li><ol start="4">
<li>用iret指令返回</li>
</ol>
</li>
</ul>
<p>iret指令用汇编语法描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>


<h3 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h3><p>当除法溢出的时候，产生0号中断信息，从而引发中断过程。此时，CPU将进行如下工作：</p>
<ul>
<li><ol>
<li>获取中断类型码0</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈，TF、IF设置为0</li>
</ol>
</li>
<li><ol start="3">
<li>CS、IP入栈</li>
</ol>
</li>
<li><ol start="4">
<li>(IP)=(0*4)，(CS)=(0*4+2)</li>
</ol>
</li>
</ul>
<p>那么现在的问题是，中断处理程序(我们设为do0)应该放在哪里？</p>
<ul>
<li>我们需要找到一块别的程序不会用到的内存区，将do0送入其中</li>
<li>前面说过，8086支持256个中断，但实际中并不会用到那么多。一般情况下，从0000:0200至0000:02FF的256个字节所对应的中断向量表项是空的，操作系统和其他程序都不会占用，所以我们可以使用这段空间</li>
</ul>
<p>程序框架如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  do0安装程序</span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  do0:  一些操作如:显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>可以看到，上面的程序分为两部分：</p>
<ul>
<li>安装do0，设置中断向量的程序<ul>
<li><ol>
<li>将do0的代码复制到内存0:200处</li>
</ol>
</li>
<li><ol start="2">
<li>设置中断向量表，将do0的入口地址保存到0号表项中</li>
</ol>
</li>
<li><ol start="3">
<li>返回</li>
</ol>
</li>
</ul>
</li>
<li>do0</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以使用movsb指令，将do0的代码送入0:200处。程序如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0       ;设置ds:si指向源地址</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h             ;设置es:di指向目的地址</span><br><span class="line"></span><br><span class="line">        mov cx,offset do0end-offset do0                     ;设置cs为传输长度，可利用编译器计算do0长度</span><br><span class="line"></span><br><span class="line">        cld                     ;设置传输方向为正向</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  do0:  一些操作如:显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h3 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h3><p>do0程序的主要任务是显示字符串，如下</p>
<p>需要注意的是：</p>
<ul>
<li>因为do0程序随时可能被执行，而它要用到的字符串”overflow!”，所以该字符串也应该放在一段不会被覆盖的空间中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0       ;设置ds:si指向源地址</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h             ;设置es:di指向目的地址</span><br><span class="line"></span><br><span class="line">        mov cx,offset do0end-offset do0                     ;设置cs为传输长度，可利用编译器计算do0长度</span><br><span class="line"></span><br><span class="line">        cld                     ;设置传输方向为正向</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  do0:  jmp short do0start</span><br><span class="line">        db &quot;overflow!&quot;</span><br><span class="line"></span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">         mov ds,ax</span><br><span class="line">         mov si,202h            ;设置ds:si指向字符串，因为do0主程序第一跳指令是跳转，占用两个字节，所以字符串的地址是202h</span><br><span class="line"></span><br><span class="line">         mov ax,0b800h</span><br><span class="line">         mov es,ax</span><br><span class="line">         mov di,12*160+36*2     ;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">         mov cx,9               ;设置字符串长度</span><br><span class="line">    s:   al,[si]</span><br><span class="line">         mov es:[di],al</span><br><span class="line">         inc si</span><br><span class="line">         add di,2</span><br><span class="line">         loop s</span><br><span class="line"></span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h3 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h3><p>0号表项的地址为0:0，其中0:0字单元存放偏移地址，0:2字单元存放段地址。程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0\*4],200h</span><br><span class="line">mov word ptr es:[0\*4+2],0</span><br></pre></td></tr></table></figure>


<h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>基本上，CPU在执行一条指令之后，如果检查到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的类型码为1，它引发的中断过程如下：</p>
<ul>
<li><ol>
<li>取得中断类型码</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈，TF、IF设置为0</li>
</ol>
</li>
<li><ol start="3">
<li>CS、IP入栈</li>
</ol>
</li>
<li><ol start="4">
<li>(IP)=(1*4), (CS)=(1*4+2)</li>
</ol>
</li>
</ul>
<p>CPU为什么要提供这样的功能呢？</p>
<ul>
<li>我们在debug的时候CPU执行一条指令后就显示各个寄存器的状态，然后等待输入</li>
</ul>
<p>当TF=1时，CPU在执行完一条指令后将引发单步中断，转去执行中断处理程序。 <strong>注意，中断处理程序也是由一条条指令组成的</strong> ，如果在执行中断处理程序之前，TF=1,则CPU执行完终端处理程序的第一条指令后，有产生单步中断，就这样死循环下去。</p>
<p>所以在进入中断处理程序之前，设置TF=0.从而避免CPU在执行中断处理程序的时候发生单步中断。</p>
<h3 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h3><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可在某些情况，即便是发生了中断，也不会响应。用一个例子说明：</p>
<p>在执行完向ss寄存器传送数据的指令后，即便发生中断，CPU也不会响应。因为ss:sp联合指向栈顶，对它们的设置应该连续完成。如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp没变，ss:sp不能指向正确的栈顶，引起错误。</p>
<h2 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h2><p>中断信息可以来自CPU的内部和外部，当CPU内部需要处理的事情发生时，将产生需要马上处理的中断信息，引发中断过程。</p>
<p>接下来将介绍另一种重要的内中断，由int指令引发的中断。</p>
<h3 id="int指令-1"><a href="#int指令-1" class="headerlink" title="int指令"></a>int指令</h3><p>int指令的格式为：<code>int n</code>，n为中断类型码，它的功能是引发中断过程。</p>
<p>CPU执行<code>int n</code>指令，相当于引发一个n号中断的中断过程，执行过程如下：</p>
<ul>
<li><ol>
<li>取中断类型码n</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈，IF=0，TF=0</li>
</ol>
</li>
<li><ol start="3">
<li>CS、IP入栈</li>
</ol>
</li>
<li><ol start="4">
<li>(IP)=(n*4)，(CS)=(n*4+2)<ul>
<li>跳转去n号中断处理程序</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>编写提供应用程序调用的中断例程，与中断处理类似：</p>
<ul>
<li>编写功能程序</li>
<li>安装程序到内存中</li>
<li>设置中断向量，将程序的入口地址保存到对应的表项中</li>
</ul>
<h3 id="对int、iret和栈的深入理解"><a href="#对int、iret和栈的深入理解" class="headerlink" title="对int、iret和栈的深入理解"></a>对int、iret和栈的深入理解</h3><p>问题：编写名为7ch的中断例程来完成loop指令的功能</p>
<p>分析：loop s的执行需要两个信息，循环的次数和到s的位移</p>
<p>例：屏幕中间显示80个”!”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start   :mov ax,0b800h</span><br><span class="line">         mov es,ax</span><br><span class="line">         mov di,160*12</span><br><span class="line"></span><br><span class="line">         mov bx,offset s-offset se      ;设置从标号se到标号s的转移位移</span><br><span class="line">         mov cx,80</span><br><span class="line">    s   :mov byte ptr es:[di],&#39;!&#39;</span><br><span class="line">         add di,2</span><br><span class="line">         int 7ch                        ;如果(cx)!&#x3D;0，转移到s处</span><br><span class="line">   se   :nop</span><br><span class="line"></span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>7ch中断例程如下:</p>
<ul>
<li><code>int 7ch</code>引发中断后，在中断过程中将当前的标志寄存器、CS和IP入栈</li>
<li>通过修改栈中的CS和IP就能让程序返回标号s所在的位置<ul>
<li>用标号se的偏移地址加上bx中存放的转移位移就可以得到标号s的偏移地址</li>
<li>如果7ch和主程序在同一段中，则栈中的段寄存器CS就不用修改</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  7ch   :push bp                        </span><br><span class="line">         mov bp,sp</span><br><span class="line">         dec cx</span><br><span class="line">         jcxz lpret                     ;如果cx等于0则不修改偏移地址，直接返回</span><br><span class="line">         add [bp+2],bx                  ;[bp+2]处是IP的内容，栈顶处是bp的内容，下面是se的偏移地址</span><br><span class="line">lpret   :pop bp</span><br><span class="line">         iret</span><br></pre></td></tr></table></figure>


<h3 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h3><p>在系统板的ROM中存放着一套程序，称为BIOS(基本输入输出系统)，主要包含以下几个部分：</p>
<ul>
<li>硬件系统的检测和初始化程序</li>
<li>外部中断和内部中断的中断例程</li>
<li>用于对硬件设备进行I/O操作的中断例程</li>
<li>其他和硬件系统相关的中断例程</li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>各种储存器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们当作内存来对待，把它们总地看做一个由若干储存单元组成的逻辑储存器。</p>
<p>PC机的芯片中，都有一组可以由CPU读写的寄存器，这些寄存器在物理上可能处于不同的芯片中，但是它们都在以下两点上相同：</p>
<ul>
<li>都和CPU的总线相连</li>
<li>CPU对它们进行读写的时候都通过控制总线向它们所在的芯片发出端口读写命令</li>
</ul>
<p>从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立一个统一的端口地址空间。每个端口在地址空间中都有一个地址</p>
<p>CPU可以直接读写以下3个地方的数据：</p>
<ul>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口</li>
</ul>
<p>以下讨论端口的读写</p>
<h3 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h3><p>在访问端口时，CPU通过端口地址来定位端口。因为端口所在的芯片和CPU通过总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围是0～65535</p>
<p>对端口的读写不能用mov、push、pop等内存读写指令。端口的读写指令只有两条：in和out</p>
<ul>
<li>in表示从端口读取数据</li>
<li>out表示往端口写入数据</li>
</ul>
<h4 id="访问端口"><a href="#访问端口" class="headerlink" title="访问端口"></a>访问端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h       ;从60h号端口读入一个字节</span><br></pre></td></tr></table></figure>

<p>执行时与总线相关的操作如下：</p>
<ul>
<li>CPU通过地址线将地址信息60h发出</li>
<li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</li>
<li>端口所在的芯片将60h端口中的数据通过数据线送入CPU</li>
</ul>
<p><strong>注意</strong> ，在in和out指令中，只能使用ax或al来存放从端口读入的数据或要发送到端口的数据。访问8位端口时用al，访问16位端口时用ax</p>
<p>对0～255以内的端口进行读写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h   </span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure>

<p>对256～65535的端口进行读写时，端口号放在dx中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h</span><br><span class="line">in al,dx   </span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure>


<h3 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h3><p>PC机中，有一个CMOS RAM芯片，一般简称为CMOS。有如下特征：</p>
<ul>
<li>包含一个实时钟和一个128个储存单元的RAM储存器</li>
<li>该芯片靠电池供电。所以关机后内部实时钟仍可正常工作，RAM中信息不会丢失</li>
<li>128个字节的RAM中，内部实时钟占用0～0dh单元来保存时间信息，其余大部分单元保存系统配置信息</li>
<li>该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM</li>
<li>70h为地址端口，存放要访问的CMOS RAM单元地址;71h为数据端口，存放从选定的CMOS RAM单元中读取的数据或要写入其中的数据，对CMOS操作时读写分为两步：如读CMOS RAM的2号单元<ul>
<li><ol>
<li>将2送入段偶70h</li>
</ol>
</li>
<li><ol start="2">
<li>从端口71h读出2号单元的内容</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h3><p>shl和shr是逻辑位移指令，shl是逻辑左移，shr是逻辑右移</p>
<p>以shl为例，它的功能为：</p>
<ul>
<li>将一个寄存器或内存单元中的数据向左位移</li>
<li>将最后移出的一位写入CF中</li>
<li>最低位用0补充</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1            ;将al数据左移一位</span><br><span class="line">;结果al&#x3D;10010000b， CF&#x3D;0</span><br></pre></td></tr></table></figure>

<p>如果位移数大于1时，必须将位移数放在cl中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">mov cl,2</span><br><span class="line">shl al,cl            ;将al数据左移2位</span><br><span class="line">;结果al&#x3D;00100000b， CF&#x3D;1</span><br></pre></td></tr></table></figure>

<p>逻辑左移相当于执行<code>X=X*2</code></p>
<p>shr是逻辑右移，和shl的操作相反</p>
<h3 id="CMOS-RAM中存储的时间信息"><a href="#CMOS-RAM中存储的时间信息" class="headerlink" title="CMOS RAM中存储的时间信息"></a>CMOS RAM中存储的时间信息</h3><p>在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。这6个信息的长度为1个字节。这些数据以BCD码的方式存放。</p>
<table>
<thead>
<tr>
<th>存放单元</th>
<th>0</th>
<th>2</th>
<th>4</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>秒</td>
<td>分</td>
<td>时</td>
<td>日</td>
<td>月</td>
<td>年</td>
</tr>
</tbody></table>
<p>CMOS RAM储存时间信息的单元中，储存了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。如00010100b表示14。</p>
<p><strong>实战</strong> :</p>
<p>编程：在屏幕中显示当前的月份</p>
<p>分析：这个程序主要做一下两个部分工作：</p>
<ul>
<li>从CMOS RAM的8号单元中读出当前月的BCD码<ul>
<li><ol>
<li>向地址端口70h写入要访问的单元的地址<br><code>mov al,8; out 70h,al</code></li>
</ol>
</li>
<li><ol start="2">
<li>从数据端口71h中取得指定单元中的数据<br><code>in al,71h</code></li>
</ol>
</li>
</ul>
</li>
<li>将用BCD码表示的月份用十进制的形式显示<ul>
<li>因为BCD码值=十进制码值，则BCD码值+30h=十进制对应的ASCII码</li>
<li>从CMOS RAM的8号内存单元读出的一个字节中，包含了用两个BCD码表示的两位十进制数，高4位为十为，低4位为个位<ul>
<li>取出这两个BCD码<br><code>mov ah,al</code><br><code>cl,4</code>  移位数<br><code>shr ah,cl</code>         ah中为月份的十位<br><code>and al,00001111b</code>  al中为月份的个位数</li>
<li>显示(ah)+30h和(al)+30h对应的ASCII码字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>完整程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  mov al,8</span><br><span class="line">        out 70h,al</span><br><span class="line">        in al,71h</span><br><span class="line"></span><br><span class="line">        mov ah,al</span><br><span class="line">        mov cl,4</span><br><span class="line">        shr ah,cl</span><br><span class="line">        and al,00001111b</span><br><span class="line"></span><br><span class="line">        add ah,30h</span><br><span class="line">        add al,30h</span><br><span class="line"></span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov byte ptr es:[160*12+40*2],ah        ;显示月份的十位数码</span><br><span class="line">        mov byte ptr es:[160*12+40*2+2],al      ;接着显示月份的个位数码</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h2 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h2><p>要及时处理外设的输入，显然需要解决两个问题：</p>
<ul>
<li>外设的输入随时可能发生，CPU如何得知？</li>
<li>CPU从何处得到外设的输入？</li>
</ul>
<h3 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a>接口芯片和端口</h3><p>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中;CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。CPU还可以向外设输出控制命令，而这些命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设设施控制。</p>
<h3 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h3><p>外设的输入随时可能发生，CPU如何得知？</p>
<ul>
<li>当CPU外部需要处理的事情发生时，相关的芯片将向CPU发出相应的中断信息，引发中断过程。</li>
</ul>
<p>在PC系统中，外中断源一共有以下两类：</p>
<ul>
<li>可屏蔽中断<ul>
<li>可屏蔽中断是CPU可以不响应的外中断</li>
<li>CPU是否响应可屏蔽中断看标志寄存器IF位的设置，IF=1则响应</li>
<li><code>sti</code>设置IF=1</li>
<li><code>cti</code>设置IF=0</li>
</ul>
</li>
<li>不可屏蔽中断<ul>
<li>不可屏蔽中断的中断类型码固定为2</li>
</ul>
</li>
</ul>
<h3 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h3><ul>
<li><ol>
<li>键盘输入<ul>
<li>键盘上每个键相当于一个开关，键盘中有一个芯片对键盘上每个键的开关状态进行扫描</li>
<li>按下一个键，开关接通，芯片产生一个能说明按下键的位置的扫描码。扫描码送入主板上相关接口芯片的寄存器中，该寄存器的端口地址为60h</li>
<li>松开按键时也会产生扫描码，也被送入60h端口</li>
<li>一般称按下产生的扫描码为通码，松开产生的扫描码为断码，通码的第7位为0，断码的第7位为1，即：<ul>
<li><strong>断码=通码+80h</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>引发9号中断<ul>
<li>键盘输入到达60h端口时，相关的芯片就会向CPU发出中断类型为9的可屏蔽中断信息</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>执行int 9中断例程<ul>
<li>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="编写int-9中断例程"><a href="#编写int-9中断例程" class="headerlink" title="编写int 9中断例程"></a>编写int 9中断例程</h3><p>键盘输入的处理过程：</p>
<ul>
<li><ol>
<li>键盘产生扫描码</li>
</ol>
</li>
<li><ol start="2">
<li>扫描码送入60h端口</li>
</ol>
</li>
<li><ol start="3">
<li>引发9号中断</li>
</ol>
</li>
<li><ol start="4">
<li>CPU执行int 9中断例程处理键盘输入<ul>
<li>从端口60h读入输入：<code>in al,60h</code></li>
<li>调用BIOS的int 9中断例程</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>BIOS提供的int 9中断例程已经对一些硬件细节进行了处理，我们只要在自己编写的中断例程中调用BIOS的int 9中断例程就可以自定义操作了。</p>
<p>编程：在屏幕中间依次显示a～z，按下Esc后改变显示的颜色</p>
<ul>
<li>首先为了能够看清，应该在显示一个字母后延时一段时间</li>
<li>将我们自己写的9号中断写入向量表，同时保存BIOS的int 9中断例程，以便之后调用<ul>
<li>这里将原来的int 9中断例程的偏移地址和段地址保存在ds:[0]和ds:[2]单元中</li>
</ul>
</li>
<li>模拟int来实现对我们写的新中断例程进行调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line"></span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        push es:[9*4]</span><br><span class="line">        pop ds:[0]</span><br><span class="line">        push es:[9*4+2]</span><br><span class="line">        pop ds:[2]          ;将原来的int 9中断例程的入口地址保存在ds:0和ds:2单元中</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov ah,&#39;a&#39;</span><br><span class="line">s:      mov es:[160*12+40*2] ;显示</span><br><span class="line">        call delay</span><br><span class="line">        inc ah</span><br><span class="line">        cmp ah,&#39;z&#39;</span><br><span class="line">        jna s</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        push ds:[0]</span><br><span class="line">        pop es:[9*4]</span><br><span class="line">        push ds:[2]</span><br><span class="line">        pop es:[9*4+2]      ;将中断向量表中的int 9中断例程的入口地址恢复为原来的地址</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">delay:  push ax</span><br><span class="line">        push dx</span><br><span class="line">        mov dx,1000h</span><br><span class="line">        mov ax,0</span><br><span class="line">s1:     sub ax,1</span><br><span class="line">        sbb dx,0</span><br><span class="line">        cmp ax,0</span><br><span class="line">        jne s1</span><br><span class="line">        cmp dx,0</span><br><span class="line">        jne s1</span><br><span class="line">        pop dx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br><span class="line">; -------新int 9中断例程--------</span><br><span class="line">int9:   push ax</span><br><span class="line">        push bx</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">        in al,60h</span><br><span class="line"></span><br><span class="line">        pushf</span><br><span class="line">        pushf</span><br><span class="line">        pop bx</span><br><span class="line">        and bh,111111100b</span><br><span class="line">        push bx</span><br><span class="line">        popf</span><br><span class="line">        call dword ptr ds:[0]   ;对int指令进行模拟，调用原来的int 9中断例程</span><br><span class="line"></span><br><span class="line">        cmp al,1</span><br><span class="line">        jne int9ret</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        inc byte ptr es:[160*12+40*2+1] ;段地址控制的文本显示的信息，改变颜色</span><br><span class="line"></span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line">code ens</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h2 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h2><h3 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h3><p>之前的程序中，标号仅仅表示了内存单元的地址。但是我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示此单元是一个字节单元，还是双字单元。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    a db 1, 2, 3, 4, 5, 6, 7, 8         ;a、b后面没有&quot;:&quot;，它们是同时描述内存地址和单元长度的标号</span><br><span class="line">    b dw 0                              ;标号a描述了地址code:0，以后的单元都是字节单元;标号b表述了地址code:8，以后的字单元</span><br><span class="line"></span><br><span class="line">start:  mov si,0</span><br><span class="line">        mov cx,8</span><br><span class="line">s:      mov al,a[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add b,ax</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>因此这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。对于程序中的<code>b dw 0</code></p>
<ul>
<li>指令：<code>mov ax,b</code>相当于：<code>mov ax,cs:[8]</code></li>
<li>指令：<code>mov b,2</code>相当于：<code>mov word ptr cs:[8],2</code></li>
<li>指令：<code>inc b</code>相当于：<code>inc word ptr cs:[8]</code></li>
</ul>
<p>使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。我们称这种标号为数据标号。</p>
<h3 id="在其他段中使用数据标号"><a href="#在其他段中使用数据标号" class="headerlink" title="在其他段中使用数据标号"></a>在其他段中使用数据标号</h3><p>下面程序将data段中a标号处8个数据累加，结果储存在b中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">    a db 1, 2, 3, 4, 5, 6, 7, 8         </span><br><span class="line">    b dw 0                              </span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,8</span><br><span class="line">s:      mov al,a[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add b,ax</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：后面加有”:”的地址标号只能在代码段中使用，不能在其他代码段中使用。</li>
<li>如果想在代码段中直接使用数据标号访问数据，则需要用伪命令assume将标号所在的段和一个段寄存器联系起来<ul>
<li>只是编译器的工作需要，类系c语言中要有函数原型，assume并没有将段寄存器和某个段相联系</li>
<li>我们在程序中还要使用指令对寄存器进行设置</li>
</ul>
</li>
</ul>
<p>对于这个程序，编译器对相关指令的编译如下：</p>
<ul>
<li>指令：<code>mov al,a[si]</code>，编译为<code>mov al,ds:[si+0]</code></li>
<li>指令：<code>mov b,ax</code>，编译为<code>mov ds:[8],ax</code></li>
<li>在执行这些指令前，ds必须为data的段地址<code>mov ax,data;mov ds,ax</code></li>
</ul>
<h3 id="直接定址表-1"><a href="#直接定址表-1" class="headerlink" title="直接定址表"></a>直接定址表</h3><p>我们希望对数据建立某种映射关系，如果我们直接使用条件判断语句明显是可行的。但程序将要执行多条比较、转移指令。程序混乱。</p>
<p>因此我们可以建立一张表。假设我们要一次储存字符”0”<del>“F”，我们可以通过0</del>15直接查找对应字符。使用如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table db &#39;0123456789ABCDE&#39;</span><br><span class="line"></span><br><span class="line">mov ah,table[bx]</span><br><span class="line">等等</span><br></pre></td></tr></table></figure>

<p>以数值N为table表中的偏移，可以找到对应的字符</p>
<p>利用表，两个数据集合之间建立了一种映射关系，使我们可以用查表的方法根据给出的数据的到其在另一个集合中的对应数据。这样做的目的一般有以下3个：</p>
<ul>
<li>为了算法的清晰和简洁</li>
<li>为了加快运算速度<ul>
<li>如我们可以直接保存常见的三角函数，而不必计算</li>
</ul>
</li>
<li>为了使程序易于扩充</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>seg操作符，功能为取得某一标号的段地址</li>
<li>lea操作符，是mov的变种，功能为取有效地址(Load effect address)，即取偏移地址<ul>
<li>格式: lea 目的,源</li>
<li>leaw，两个字节</li>
<li>leal，4个字节</li>
<li>leaq，8个字节</li>
</ul>
</li>
<li>leave操作符，功能为将寄存器ebp(保留栈底指针)的内容复制到esp(保留栈顶指针)中，然后从栈中恢复ebp寄存器的旧值</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/universe/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/04/universe/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6/" class="post-title-link" itemprop="url">密码学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-04T00:00:00+08:00">2020-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="密码学和数据安全导论"><a href="#密码学和数据安全导论" class="headerlink" title="密码学和数据安全导论"></a>密码学和数据安全导论</h2><p>可靠的密码体制必须遵守Auguste Kerekhoffs在1883年提出的一个假说，即Kerekhoffs原理:</p>
<blockquote>
<p>即使密钥外的整个系统的一切都是公开的，这个密码体制也必须是安全的。尤其是即使攻击者知道系统的加密算法和解密算法，此系统也必须是安全的。</p>
</blockquote>
<p>需要强调的是，设计上一个隐藏细节的系统看似是更安全的。但是历史经验告诉我们这样的系统其实是很脆弱的，系统的细节可以通过逆向工程破解。这就是说为什么即使攻击者知道加密算法，加密方案仍必须保持安全的原因。</p>
<h3 id="模运算与多种古典密码"><a href="#模运算与多种古典密码" class="headerlink" title="模运算与多种古典密码"></a>模运算与多种古典密码</h3><h4 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h4><p>几乎所有的加密算法都是基于有限个元素的运算。模运算就是在有限个数集中执行运算的简单方法：</p>
<p>定义：模运算</p>
<blockquote>
<p>假设$a, r, m \in Z$(其中Z是所有整数的集合)，并且m&gt;0。如果m除a-r，可记作：<br>$$a \equiv r \bmod m$$<br>其中m称为模数，r称为余数</p>
</blockquote>
<blockquote>
<p>其中$a \equiv b (\bmod m)$表示a与b对于m同余</p>
</blockquote>
<h5 id="等价类中所有成员的等价行为"><a href="#等价类中所有成员的等价行为" class="headerlink" title="等价类中所有成员的等价行为"></a>等价类中所有成员的等价行为</h5><p>对于一个给定模数m，选择等价类中任何一个元素用于计算的结果都是一样的。因此我们可以选择等价类中最易于计算的一个元素进行模运算</p>
<p>计算$3^8$模7的的结果：</p>
<ul>
<li>$3^8 = 6561 \equiv 2 \bmod 7$</li>
<li>下面使用等价类进行计算<br>$$3^8 = 3^4 \cdot 3^4 = 81 \cdot 81$$</li>
<li>然后将中间结果的81替换为同一等价类中的其他元素。在模数7的等价类中，最小的正元素是4(因为$81 = 11 \cdot 7 + 4$)，因此：<br>$$3^8 = 3^4 \cdot 3^4 \equiv 4 \cdot 4 \equiv 16 \bmod 7 \equiv 2 \bmod 7$$</li>
</ul>
<p>通用的规则是：应该尽量使用模化简，使计算的数值尽可能小，这样做总是极具计算优势</p>
<h4 id="整数环"><a href="#整数环" class="headerlink" title="整数环"></a>整数环</h4><p>定义：环</p>
<blockquote>
<p>整数环$Z_m$由以下两部分组成：</p>
<ul>
<li><ol>
<li>集合$Z_m = (0, 1, 2, …, m-1)$</li>
</ol>
</li>
<li><ol start="2">
<li>两种操作”+”和”×”，使得所有的$a, b \in Z_m$有<ul>
<li>1)$a + b \equiv c \bmod m, (c \in Z_m)$</li>
<li>2)$a \times b \equiv d \bmod m, (d \in Z_m)$</li>
</ul>
</li>
</ol>
</li>
</ul>
</blockquote>
<p>环具有以下特征：</p>
<ul>
<li>如果环内任何两个数相加或相乘得到的结果始终在环内，那么这个环是封闭的</li>
<li>加法和乘法是可结合的，例如对所有的$a, b, c \in Z_m$，都有$a + (b+c) = (a+b) + c$和$a \cdot (b \cdot c) = (a \cdot b) \cdot c$</li>
<li>加法中存在中性元素0，使得对每个$a \in Z_m$都有$a + 0 \equiv a \bmod m$</li>
<li>环中的任何元素a都存在一个负元素-a，使得$a + (-a) \equiv 0 \bmod m$，即加法逆元始终存在</li>
<li>乘法中存在中性元素1，使得对每个$a \in Z_m$都有$a \times 1 \equiv a \bmod m$</li>
<li>不是所有元素都存在乘法逆元，假设$a \in Z$，乘法逆元$a^{-1}$可以定义为：<br>$$a \times a^{-1} = 1 \mod m$$<br>如果某个元素的乘法逆元存在，则可以除以这个元素，因为$b/a \equiv b \cdot a^{-1} \bmod m$</li>
<li>寻找逆元比较困难，可以通过一种简单的方法判断一个元素a的逆元是否存在：<ul>
<li>当且仅当$gcd(a, m) = 1$，一个元素$a \in Z$存在乘法逆元$a^{01}$，其中gcd表示最大公约数(Greatest Common divisor)，$gcd(a, m) = 1$就表示a和m(模数)互质</li>
</ul>
</li>
</ul>
<h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><p>仿射密码是一种改善的移位密码，仿射密码的思路是将明文密码乘以密钥的一部分，然后再加上密钥的剩余部分</p>
<p>定义：仿射加密</p>
<blockquote>
<p>假设$x, y ,a, b \in Z_26$(26个字母)</p>
<p>加密：$e_k(x) = y \equiv a \cdot x + b \bmod 26$</p>
<p>解密：$d_k(y) = x \equiv a^{-1} \cdot (y-b) \bmod 26$</p>
<p>密钥为：$k = (a, b)$，且满足限制条件gcd(a, 26)=1</p>
</blockquote>
<p>gcd(a, 26)=1 这个限制是源于这样一个事实：加密时需要求密钥参数a的逆元。</p>
<p>通过尝试所有$a^{-1}$的可能值，直到$a \cdot a^{-1} \equiv 1 \bmod 26$即可得到逆元</p>
<p>因此仿射加密的确比移位加密复杂，但也是可暴力破解的<br>$$密钥空间 = (a的可能值) \times (b的可能值)$$</p>
<h2 id="序列密码"><a href="#序列密码" class="headerlink" title="序列密码"></a>序列密码</h2><p>对称密码学分成分组密码和序列密码两部分</p>
<ul>
<li>序列密码<ul>
<li>单独加密每个位</li>
</ul>
</li>
<li>分组密码<ul>
<li>每次使用相同的密钥加密整个明文位分组</li>
</ul>
</li>
</ul>
<h3 id="序列密码加密与解密"><a href="#序列密码加密与解密" class="headerlink" title="序列密码加密与解密"></a>序列密码加密与解密</h3><p>定义：序列密码</p>
<blockquote>
<p>明文、密文和密钥序列都是由单独的位组成，即$x_i, y_i, s_i \in {0, 1}$</p>
<p>加密：$y_i \equiv x_i + s_i \bmod 2$</p>
<p>解密：$x_i \equiv y_i + s_i \bmod 2$</p>
</blockquote>
<p>加密解密推导：加密和解密用的是相同的函数</p>
<p>$$\begin{aligned}<br>d(y_i) &amp;\equiv y_i + s_i \bmod 2 \<br>&amp;\equiv x_i + s_i + s_i \bmod 2 \<br>&amp;\equiv x_i + 2s_i \bmod 2 \<br>&amp;\equiv x_i + 0 \bmod 2 \<br>&amp;\equiv x_i \bmod 2 \<br>\end{aligned}$$</p>
<p>下面给出模2加法的真值表</p>
<table>
<thead>
<tr>
<th>$x_i$</th>
<th>$s_i$</th>
<th>$y_i \equiv x_i + s_i \bmod 2$</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>事实上模2加法与异或XOR是等价的，密文为0或1的概率是完全相等的</p>
<p>密钥序列$s_1, s_2, …,s_i$是序列密码安全的核心问题，在攻击者看来$s_i$必须的随机的</p>
<h3 id="随机数与牢不可破的分组密码"><a href="#随机数与牢不可破的分组密码" class="headerlink" title="随机数与牢不可破的分组密码"></a>随机数与牢不可破的分组密码</h3><h4 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h4><ul>
<li>真随机数生成器(TRNG)<ul>
<li>TRNG的突出特征是它是输出是不可复制的<ul>
<li>如拋100次硬币，世界上另一个人抛出和我相同的结果概率很低</li>
</ul>
</li>
<li>TRNG都是基于物理过程，主要例子包括抛硬币等</li>
</ul>
</li>
<li>(通用的)伪随机数生成器(PRNG)<ul>
<li>PRNG从一个初始种子值开始通过各种计算得到序列</li>
<li>PRNG并不是真正意义上的随机，因为它们是可以算出来的</li>
<li>对PRNG的一个一般要求是：必须有良好的统计属性<ul>
<li>即它的输出与真随机数序列相同</li>
</ul>
</li>
</ul>
</li>
<li>加密安全的伪随机数生成器(CSPRNG)<ul>
<li>是一种不可预测的PRNG，即计算后续位在计算上是不可行的</li>
</ul>
</li>
</ul>
<h4 id="一次一密"><a href="#一次一密" class="headerlink" title="一次一密"></a>一次一密</h4><p>一个完美的密钥应该具有的特征：无条件安全。定义如下</p>
<blockquote>
<p>如果一个密码体制在无限计算资源的情况下也不能被破译，则说明它是无条件安全的或信息论上安全的</p>
</blockquote>
<p>一下是个简单的无条件安全的密码，这个密码是<strong>一次一密(OTP)</strong>，定义如下</p>
<blockquote>
<p>一个序列密码成为一次一密，必须满足一下条件：</p>
<ul>
<li><ol>
<li>通过真随机数生成器得到密钥序列$s_1, s_2, …$</li>
</ol>
</li>
<li><ol start="2">
<li>只有合法的通信方才知道密钥序列</li>
</ol>
</li>
<li><ol start="3">
<li>每个密钥序列位$s_i$仅使用一次<br>一次一密是无条件安全的</li>
</ol>
</li>
</ul>
</blockquote>
<p>证明OTP是无条件安全的方法如下</p>
<p>$$\begin{aligned}<br>y_0 &amp;\equiv x_0 + s_0 \bmod 2 \<br>y_1 &amp;\equiv x_1 + s_1 \bmod 2 \<br>…<br>\end{aligned}$$</p>
<p>每个单独的关系都是有两个未知数的线性等式模2,它们无法求解</p>
<p>OTP缺点如下，导致它在实际中很少使用：</p>
<ul>
<li>需要真随机数生成器</li>
<li>每个密钥序列使用一次，需要多次交换密钥序列</li>
</ul>
<h4 id="关于实际序列密码"><a href="#关于实际序列密码" class="headerlink" title="关于实际序列密码"></a>关于实际序列密码</h4><p>我们处理实际序列密码的方式就是使用伪随机数生成器(PRNG)代替真随机数生成器。实际上，所有已知的实际加密算法都不是无条件安全的。但是我们可以做到 <strong>计算安全</strong> </p>
<p>定义：计算安全</p>
<blockquote>
<p>如果为破解一个密码体制，最好的一直算法需要至少t个操作，则说明次密码体制是计算安全的</p>
</blockquote>
<p>这个定义看似合理但是存在若干问题。首先人们不知道对应的最好算法是哪一个，因此我们不知道是否存在更强大的攻击。</p>
<h5 id="利用PRNG构建密码流"><a href="#利用PRNG构建密码流" class="headerlink" title="利用PRNG构建密码流"></a>利用PRNG构建密码流</h5><p>虽然PRNG可以用来生成密钥流，但对于序列密码而言都不足够，考虑下面的例子：</p>
<p>假设一个基于线性同余生成器的PRNG：</p>
<p>$$\begin{aligned}<br>S_0 &amp;\equiv  seed \<br>S_{i+1} &amp;\equiv AS_i + B \bmod m, i = 0, 1, … \<br>\end{aligned}$$</p>
<p>设其中选择的m为100位长，$S_i, A, B \in {0, 1, …, m-1}$，我们通过仔细选择这些参数是的此PRNG具有良好的统计属性。密钥包含值(A, B)，可可能包含种子$S_0$，并且每个值的长度都是100，总共密钥长度就为200位。发送方使用一下方式加密：</p>
<p>$$y_i \equiv x_i + s_i \bmod 2$$</p>
<p>其中$s_i$为PRNG输出符号$S_j$的二进制表示的位</p>
<p>攻击者可以轻易发起攻击，如果攻击者知道明文的前300位(通过头文件、常用语等猜出部分明文)。那他可以利用下式计算密钥序列的前300位：</p>
<p>$$s_i \equiv y_i + x_i \bmod m, i = 1, 2, …, 300$$</p>
<p>于是就得到了:$S_1 = {s_1, …, s_{100}}, S_2 = {s_1, …, s_{200}}, S_3 = {s_3, …, s_{300}}$。攻击者现在可以得到两个等式：</p>
<p>$$\begin{aligned}<br>S_2 \equiv AS_1 + B \bmod m \<br>S_3 \equiv AS_2 + B \bmod m<br>\end{aligned}$$</p>
<p>对于一个基于$Z_m$的线性等式系统，拥有两个未知数A，B，我们可以得到：</p>
<p>$$\begin{aligned}<br>A &amp;\equiv (S_2 - S_3)/(S_1 - S_2) \bmod m \<br>B &amp;\equiv S_2 - S_1(S_2 - S_3)/(S_1 - S_2) \bmod m<br>\end{aligned}$$</p>
<p>在$gcd((S_1 - S_2), m) \neq 1$情况下可以得到多个解，如果已知明文的第四片段信息就可以唯一测出密钥。</p>
<p>这种类型的攻击正是发明CSPRNG表示方法的原因</p>
<h5 id="利用CSPRNG构建密钥序列"><a href="#利用CSPRNG构建密钥序列" class="headerlink" title="利用CSPRNG构建密钥序列"></a>利用CSPRNG构建密钥序列</h5><p>CSPRNG可以确保密钥序列是不可预测的，但是相当一部分在密码学之外的伪随机数生成器不是密码学安全的，因此我们需要使用专门的伪随机数生成器来生成密码序列</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/01/universe/vim/vimscript_backup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/01/universe/vim/vimscript_backup/" class="post-title-link" itemprop="url">learn vimscript the hard way</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-01T00:00:00+08:00">2020-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-20 20:39:27" itemprop="dateModified" datetime="2020-09-20T20:39:27+08:00">2020-09-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Remenber to use <code>:h &lt;arg&gt;</code> for help</p>
<p>Ref: <a href="https://learnvimscriptthehardway.stevelosh.com/" target="_blank" rel="noopener">https://learnvimscriptthehardway.stevelosh.com/</a></p>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><h3 id="Echo"><a href="#Echo" class="headerlink" title="Echo"></a>Echo</h3><ul>
<li><code>:echo &quot;hello&quot;</code></li>
<li><code>:echom &quot;hello&quot;</code></li>
</ul>
<p>区别在于echom会将消息放入消息队列中<code>:messages</code></p>
<h3 id="Setting-option"><a href="#Setting-option" class="headerlink" title="Setting option"></a>Setting option</h3><ul>
<li><code>:set &lt;name&gt;=&lt;value&gt;</code><ul>
<li><code>:set &lt;name&gt;?</code>可以查看设置的情况</li>
</ul>
</li>
</ul>
<h3 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a>Abbreviations</h3><ul>
<li><code>iabbrev adn and</code></li>
</ul>
<p>在输入模式下输入adn，然后空格会发现变成了and</p>
<h3 id="Buffer-Local-Options"><a href="#Buffer-Local-Options" class="headerlink" title="Buffer-Local Options"></a>Buffer-Local Options</h3><ul>
<li>local mapping<ul>
<li>like <code>:map &lt;buffer&gt; D dd</code>, the <code>&lt;buffer&gt;</code>told vim only consider that mapping when we are in the buffer where we dedine it</li>
</ul>
</li>
<li>local leader<ul>
<li><code>&lt;localleader&gt;</code> instead of <code>&lt;leader&gt;</code></li>
</ul>
</li>
<li>setting<ul>
<li><code>setlocal &lt;name&gt;</code></li>
</ul>
</li>
<li>shadowing  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:nnoremap &lt;buffer&gt; Q x</span><br><span class="line">:nnoremap          Q dd</span><br></pre></td></tr></table></figure>
<ul>
<li>first mapping is more specific, so the second not work</li>
</ul>
</li>
</ul>
<h3 id="Autocommands"><a href="#Autocommands" class="headerlink" title="Autocommands"></a>Autocommands</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">autocmd</span> BufNewFile * :<span class="keyword">write</span></span><br><span class="line">         ^          ^ ^</span><br><span class="line">         |          | |</span><br><span class="line">         |          | The <span class="keyword">command</span> <span class="keyword">to</span> run.</span><br><span class="line">         |          |</span><br><span class="line">         |          A <span class="string">"patterns"</span> <span class="keyword">to</span> <span class="built_in">filter</span> the event.</span><br><span class="line">         |</span><br><span class="line">         The <span class="string">"events"</span> <span class="keyword">to</span> watch <span class="keyword">for</span>.</span><br></pre></td></tr></table></figure>

<p><code>:help autocmd-events</code></p>
<h4 id="Autocommands-Group"><a href="#Autocommands-Group" class="headerlink" title="Autocommands Group"></a>Autocommands Group</h4><p>It is possible to create duplicate autocommands, so if you try running the following command:<code>:autocmd BufWrite * :sleep 200m</code> three times. Vim will sleep 600m.</p>
<p>Use <code>augroup</code> is the same</p>
<ul>
<li>Clearing Groups<ul>
<li><code>autocmd!</code></li>
</ul>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">augroup</span> testgroup</span><br><span class="line">:    autocmd!</span><br><span class="line">:    <span class="keyword">autocmd</span> BufWrite * :<span class="keyword">echom</span> <span class="string">"Cats"</span></span><br><span class="line">:<span class="keyword">augroup</span> END</span><br><span class="line">we enter the testgroup group, immediately clear it(gourp), <span class="built_in">and</span> <span class="keyword">no</span> more dup autocommands before any more</span><br></pre></td></tr></table></figure>

<p><code>:help autocmd-groups</code></p>
<h3 id="Operator-Pending-Mapping"><a href="#Operator-Pending-Mapping" class="headerlink" title="Operator-Pending Mapping"></a>Operator-Pending Mapping</h3><ul>
<li>like <code>:onoremap p i(</code>, when we run <code>dp</code> it was like saying “delete parameters”, which vim translates to “delete inside parentheses”</li>
</ul>
<h3 id="Status-Lines"><a href="#Status-Lines" class="headerlink" title="Status Lines"></a>Status Lines</h3><ul>
<li><code>:set statusline=%f\ -\ FileType:\ %y</code></li>
<li><code>:set statusline+=</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set statusline&#x3D;%l    &quot; Current line</span><br><span class="line">:set statusline+&#x3D;&#x2F;    &quot; Separator</span><br><span class="line">:set statusline+&#x3D;%L   &quot; Total lines</span><br></pre></td></tr></table></figure>

<ul>
<li>width and padding<ul>
<li><code>:set statusline=Current:\ %4l\ Total:\ %4L</code>, like this<ul>
<li><code>Current:   12 Total:  223</code></li>
</ul>
</li>
<li><code>:set statusline=Current:\ %-4l\ Total:\ %-4L</code><ul>
<li><code>Current: 12   Total: 223</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Programming-Language"><a href="#Programming-Language" class="headerlink" title="Programming Language"></a>Programming Language</h2><ul>
<li>set up folding for Vimscript files: <code>set foldmethod=&lt;value&gt;</code></li>
</ul>
<p>Add lines before and after that autocommands group so that it look like thik:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" Vimscript file settings ---------------------- &#123;&#123;&#123;</span></span><br><span class="line"><span class="keyword">augroup</span> filetype_vim</span><br><span class="line">    autocmd!</span><br><span class="line">    <span class="keyword">autocmd</span> FileType <span class="keyword">vim</span> <span class="keyword">setlocal</span> foldmethod=marker</span><br><span class="line"><span class="keyword">augroup</span> END</span><br><span class="line"><span class="comment">" &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>In normal mode, type <code>za</code>. Vim will fold/unfold the lines starting at the one containting <code>3{</code> and ending at <code>3}</code></p>
<p><code>:h foldlevelstart</code></p>
<h3 id="Multiple-Line-Statements"><a href="#Multiple-Line-Statements" class="headerlink" title="Multiple-Line Statements"></a>Multiple-Line Statements</h3><p>like</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">augroup</span> testgroup</span><br><span class="line">:    <span class="keyword">autocmd</span> BufWrite * :<span class="keyword">echom</span> <span class="string">"Baz"</span></span><br><span class="line">:<span class="keyword">augroup</span> END</span><br></pre></td></tr></table></figure>

<p>You can write this as three separate lines in a Vimscript file. Or you can separate each line with a pipe character <code>|</code>. Like this.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">echom</span> <span class="string">"foo"</span> | <span class="keyword">echom</span> <span class="string">"bar"</span></span><br></pre></td></tr></table></figure>


<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><ul>
<li><code>let</code> to init or assignment a variable(call it var below)</li>
<li><code>unlet</code> to delete a var</li>
<li><code>unlet</code> to delete a var and ignore warnning, if var did not exist</li>
</ul>
<p>You can add a prefix before :var to define its scope, like this</p>
<h4 id="Options-as-Variables"><a href="#Options-as-Variables" class="headerlink" title="Options as Variables"></a>Options as Variables</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> textwidth=<span class="number">80</span></span><br><span class="line">:<span class="keyword">echo</span> &amp;textwidth</span><br></pre></td></tr></table></figure>

<p>Using an ampersand in front of a name tells Vim that you’re referring to the option, not a variable that happens to have the same name</p>
<h4 id="Registers-as-Variables"><a href="#Registers-as-Variables" class="headerlink" title="Registers as Variables"></a>Registers as Variables</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">let</span> @a = <span class="string">"hello!"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>:echo @&quot;</code>, unnamed register, which is where text you yank</li>
<li><code>:echo @/</code>, echo search pattern you just use</li>
</ul>
<h4 id="Variables-Scoping"><a href="#Variables-Scoping" class="headerlink" title="Variables Scoping"></a>Variables Scoping</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g:var  # as global</span><br><span class="line">a:var  # as a function arg</span><br><span class="line">l:var  # as a function var</span><br><span class="line">b:var  # as buffer var</span><br><span class="line">w:var  # as window var</span><br><span class="line">t:var  # as tab var</span><br><span class="line">s:var  # as script var, which useful in this script only</span><br><span class="line">v:var  # as vim build-in var</span><br></pre></td></tr></table></figure>

<p><code>:h internal-variables</code></p>
<h3 id="Conditionals"><a href="#Conditionals" class="headerlink" title="Conditionals"></a>Conditionals</h3><p>Any decision making you do in your coding will be done with <code>if</code>s.</p>
<h4 id="Basic-If"><a href="#Basic-If" class="headerlink" title="Basic If"></a>Basic If</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">if</span> <span class="number">1</span></span><br><span class="line">:    <span class="keyword">echom</span> <span class="string">"One"</span></span><br><span class="line">:<span class="keyword">elseif</span> <span class="string">"nope"</span></span><br><span class="line">:    <span class="keyword">echom</span> <span class="string">"elseif"</span></span><br><span class="line">:<span class="keyword">else</span></span><br><span class="line">:    <span class="keyword">echom</span> <span class="string">"finally"</span></span><br><span class="line">:<span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>Vim dose not necessarily treat a non-empty string as “truthly”.</p>
<p>try this</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">echom</span> <span class="string">"hello"</span> + <span class="number">10</span></span><br><span class="line">:<span class="keyword">echom</span> <span class="string">"10hello"</span> + <span class="number">10</span></span><br><span class="line">:<span class="keyword">echom</span> <span class="string">"hello10"</span> + <span class="number">10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Vim will try to coerce variables (and literals) when necessary. When 10 + “20foo” is evaluated Vim will convert “20foo” to an integer (which results in 20) and then add it to 10.</li>
<li>Strings that start with a number are coerced to that number, otherwise they’re coerced to 0.</li>
<li>Vim will execute the body of an if statement when its condition evaluates to a non-zero integer, after all coercion takes place.</li>
</ul>
<h4 id="Comparisons"><a href="#Comparisons" class="headerlink" title="Comparisons"></a>Comparisons</h4><p>Vim is case senitive so <code>&quot;foo&quot; != &quot;FOO&quot;</code>. But if you <code>:set ignorecase</code>, vim is case insenitive.</p>
<p>So to be code defensively you can nevertrust the <code>==</code> comparison. A bare <code>==</code> should never appear in you plugins’ code. Vim has two extra sets of comparison operators to deal with this.</p>
<ul>
<li><code>==?</code> is the “case-insenitive”, no matter what user has set</li>
<li><code>==#</code> is the “case-senitive”, no matter what user has set</li>
</ul>
<h4 id="String-comparison"><a href="#String-comparison" class="headerlink" title="String comparison"></a>String comparison</h4><ul>
<li><code>&lt;string&gt; == &lt;string&gt;</code> equal</li>
<li><code>&lt;string&gt; != &lt;string&gt;</code> not equal</li>
<li><code>&lt;string&gt; =~ &lt;pattern&gt;</code> matching pattern</li>
<li><code>&lt;string&gt; !~ &lt;pattern&gt;</code> not matching pattern</li>
<li><code>&lt;operator&gt;#</code> matching with case</li>
<li><code>&lt;operator&gt;?</code> matching with ignorecase</li>
</ul>
<p><code>&lt;string&gt;.&lt;string&gt;</code> to connect string</p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p> <strong>Vimscript functions must start with a capital letter if they are unscoped!</strong> </p>
<p>Use <code>function</code> keywork to define a function, use <code>function!</code> to overwire a function. Be attention, function need to begin with capital letter.</p>
<ul>
<li><code>:echo Function()</code> if Function has no return, vim will implicit return 0</li>
<li><code>:delfunction &lt;function&gt;</code> to delete a function</li>
<li><code>:call &lt;function&gt;</code> to call a function </li>
</ul>
<h4 id="Function-Arguments"><a href="#Function-Arguments" class="headerlink" title="Function Arguments"></a>Function Arguments</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DisplayName</span><span class="params">(name)</span></span></span><br><span class="line">  <span class="keyword">echom</span> <span class="string">"Hello!  My name is:"</span></span><br><span class="line">  <span class="keyword">echom</span> <span class="variable">a:name</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>Notice the <code>a:</code> in the name of the variable represents a variable scope. And it tell vim that they’re in the argument scope.</p>
<h4 id="Varargs"><a href="#Varargs" class="headerlink" title="Varargs"></a>Varargs</h4><p>Vimscript call take variable-length argument lists.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Varg</span><span class="params">(...)</span></span></span><br><span class="line">  <span class="keyword">echom</span> <span class="variable">a:0</span></span><br><span class="line">  <span class="keyword">echom</span> <span class="variable">a:1</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="variable">a:000</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> Varg(<span class="string">"a"</span>, <span class="string">"b"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>a:0</code> will be set to the number of extra arguments you were given</li>
<li><code>a:1</code> will be set to the first extra argument</li>
<li><code>a:000</code> will be set to a list containing all the extra arguments</li>
</ul>
<h4 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h4><p>Vimscript not allow you to reassign argument variables.Try running the follow commands, vim will throw an error. And you need a temp var.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:<span class="function"><span class="keyword">function</span> <span class="title">Assign</span><span class="params">(foo)</span></span></span><br><span class="line">:  <span class="keyword">let</span> <span class="variable">a:foo</span> = <span class="string">"Nope"</span></span><br><span class="line">:  <span class="keyword">echom</span> <span class="variable">a:foo</span></span><br><span class="line">:<span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">:<span class="keyword">call</span> Assign(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure>


<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Vimscritp use <code>.</code> to connect strings. Use <code>\</code> to escape sequences.</p>
<p>Using single quotes tell vim that you want string exactly as-is, with no escape sequences. And two single quotes in a row will produce one single quote. <code>:echom &#39;That&#39;&#39;s enough.&#39;</code></p>
<h4 id="String-Functions"><a href="#String-Functions" class="headerlink" title="String Functions"></a>String Functions</h4><ul>
<li>Length<ul>
<li><code>strlen(&quot;foo&quot;)</code></li>
<li><code>len(&quot;foo&quot;)</code></li>
</ul>
</li>
<li>Splitting: splits a String into a List<ul>
<li><code>split(&quot;String&quot;, separator)</code>, separator is “whitespace” by default</li>
</ul>
</li>
<li>Joining: join a List into a String<ul>
<li><code>join(List, connector)</code></li>
</ul>
</li>
<li>Case<ul>
<li><code>tolower(&quot;String&quot;)</code></li>
<li><code>toupper(&quot;String&quot;)</code></li>
</ul>
</li>
</ul>
<h3 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a>Execute</h3><p>The <code>execute</code> command is user to evaluate a string as if it were a Vimscripte command.</p>
<h4 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h4><p>Try run</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">nnoremap</span> G dd</span><br><span class="line">:<span class="keyword">normal</span> G</span><br></pre></td></tr></table></figure>

<p>Vim will delete the current line. The <code>normal</code> command will take into account any mapping that exist.</p>
<p>Vim has a <code>normal!</code> command to avoid user mapping. So write Vimscript should  <strong>always</strong> use <code>normal!</code>.</p>
<p>The problem is that <code>normal!</code> dosen’t parse special character sequences like <code>&lt;cr&gt;</code>. Combining <code>normal!</code> with <code>execute</code> fixes that problem. Like this:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">execute</span> <span class="string">"normal! gg/print\&lt;cr&gt;"</span></span><br></pre></td></tr></table></figure>


<h3 id="Demos"><a href="#Demos" class="headerlink" title="Demos"></a>Demos</h3><h4 id="Grep-Operation-Part-One"><a href="#Grep-Operation-Part-One" class="headerlink" title="Grep Operation, Part One"></a>Grep Operation, Part One</h4><p><code>:nnoremap &lt;leader&gt;g :grep -R &#39;&lt;cWORD&gt;&#39; %&lt;cr&gt;</code></p>
<h5 id="Escaping-Shell-Command-Argument"><a href="#Escaping-Shell-Command-Argument" class="headerlink" title="Escaping Shell Command Argument"></a>Escaping Shell Command Argument</h5><p>Try the mapping on the word <code>that&#39;s</code>. It won’t work, because the single quote inside the word interferes with the quotes in the grep command!</p>
<p>To get around this we can use Vim’s <code>shellescape</code> function. <code>:h shellescape()</code> and <code>:h escape</code></p>
<p>The problem is that <strong>Vim performed the <code>shellescape()</code> call before it expended out special string like <code>&lt;cword&gt;</code>.</strong> So <code>:echom shellescape(&quot;&lt;cWORD&gt;&quot;)</code> is literally output <code>&#39;&lt;cword&gt;&#39;</code></p>
<p>To fix this we’ll <strong>use the <code>expand()</code> function to force th expansion of <code>&lt;cword&gt;</code> into the actual string</strong> before it gets passed to <code>shellescape</code>.</p>
<p>try following over the word like <code>that&#39;s</code>:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">echom</span> <span class="built_in">expand</span>(<span class="string">"&lt;cWORD&gt;"</span>)</span><br><span class="line">:<span class="keyword">echom</span> <span class="built_in">shellescape</span>(<span class="built_in">expand</span>(<span class="string">"&lt;cWORD&gt;"</span>))</span><br></pre></td></tr></table></figure>

<p>Finally, try <code>:nnoremap &lt;leader&gt;g :silent execute &quot;grep! -R &quot; . shellescape(expand(&quot;&lt;cWORD&gt;&quot;)) . &quot; .&quot;&lt;cr&gt;:copen&lt;cr&gt;</code></p>
<ul>
<li><code>:h copen</code>, <ul>
<li>Open a window to show the current list of errors</li>
</ul>
</li>
<li><code>:h silent</code><ul>
<li>The <code>silent</code> command just runs the command that follows it while hiding any messages it would normally display</li>
</ul>
</li>
</ul>
<h4 id="Grep-Operator-Part-Two"><a href="#Grep-Operator-Part-Two" class="headerlink" title="Grep Operator, Part Two"></a>Grep Operator, Part Two</h4><ul>
<li>Create a File<ul>
<li>Inside <code>.vim/plugin</code> create file named <code>grep-operato.vim</code></li>
<li>This is where you’ll place the code.</li>
</ul>
</li>
<li>Skeleton<ul>
<li>To create a new Vim operator you’ll start with two components:a function and a mapping  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>g :<span class="keyword">set</span> operatorfunc=GrepOperator<span class="symbol">&lt;cr&gt;</span>g@</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">GrepOperator</span><span class="params">(type)</span></span></span><br><span class="line">    <span class="keyword">echom</span> <span class="string">"Test"</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure></li>
<li>we set the <code>operatorfunc</code> option to our function</li>
<li>then we run <code>g@</code> which calls this function as an operator<ul>
<li><strong>try type <code>g@</code> in normal mode</strong></li>
</ul>
</li>
</ul>
</li>
<li>Visual Mode<ul>
<li>Add another mapping <code>vnoremap &lt;leader&gt;g :&lt;c-u&gt;call GrepOperator(visualmode())&lt;cr&gt;</code><ul>
<li><code>&lt;c-u&gt;</code> to say “delete from the cursor to the bebginning of the line”</li>
<li><strong><code>visualmode()</code> is a built-in Vim function</strong> that return a one-character string representing the last type of visual mode. “v、V and Crtl-v”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Motion-type"><a href="#Motion-type" class="headerlink" title="Motion type"></a>Motion type</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>g :<span class="keyword">set</span> operatorfunc=GrepOperator<span class="symbol">&lt;cr&gt;</span>g@</span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span>g :<span class="symbol">&lt;c-u&gt;</span><span class="keyword">call</span> GrepOperator(<span class="built_in">visualmode</span>())<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">GrepOperator</span><span class="params">(type)</span></span></span><br><span class="line">    <span class="keyword">echom</span> <span class="variable">a:type</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Pressing <code>viw&lt;leader&gt;g</code> echoes <code>v</code> because we were in characterwise visual mode.</li>
<li>Pressing <code>Vjj&lt;leader&gt;g</code> echoes <code>V</code> because we were in linewise visual mode.</li>
<li>Pressing <code>&lt;leader&gt;giw</code> echoes <code>char</code> because we used a characterwise motion with the operator.</li>
<li>Pressing <code>&lt;leader&gt;gG</code> echoes <code>line</code> because we used a linewise motion with the operator.</li>
</ul>
<h5 id="Copying-the-Text"><a href="#Copying-the-Text" class="headerlink" title="Copying the Text"></a>Copying the Text</h5><p>Edit a function look like this:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>g :<span class="keyword">set</span> operatorfunc=GrepOperator<span class="symbol">&lt;cr&gt;</span>g@</span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span>g :<span class="symbol">&lt;c-u&gt;</span><span class="keyword">call</span> GrepOperator(<span class="built_in">visualmode</span>())<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">GrepOperator</span><span class="params">(type)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">a:type</span> ==# <span class="string">'v'</span></span><br><span class="line">        <span class="keyword">execute</span> <span class="string">"normal! `&lt;v`&gt;y"</span></span><br><span class="line">    <span class="keyword">elseif</span> <span class="variable">a:type</span> ==# <span class="string">'char'</span></span><br><span class="line">        <span class="keyword">execute</span> <span class="string">"normal! `[v`]y"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echom</span> <span class="built_in">shellescape</span>(@@)</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>==#</code> case-sensitive comparison</li>
<li><strong><code>normal!</code> dose two things</strong>:<ul>
<li>Visually select the range of text we want by:<ul>
<li>Moving to mark at the beginning of the range.</li>
<li>Entering characterwise visual mode.</li>
<li>Moving to the mark at the end of the range.</li>
</ul>
</li>
<li>Yanking the visually selected text.</li>
</ul>
</li>
<li><code>@@</code> is the “unnamed” register: the one that Vim places text into then yank or delete by default</li>
</ul>
<h4 id="Grep-Operator-Part-Three"><a href="#Grep-Operator-Part-Three" class="headerlink" title="Grep Operator, Part Three"></a>Grep Operator, Part Three</h4><p><strong>Namespacing</strong> </p>
<p>Our script create a function named <code>GrepOperator</code> in the global namespace.</p>
<p>We can avoid polluting the global namespace by tweaking a couple of lines in our code.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span>g :<span class="keyword">set</span> operatorfunc=<span class="symbol">&lt;SID&gt;</span>GrepOperator<span class="symbol">&lt;cr&gt;</span>g@</span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;leader&gt;</span>g :<span class="symbol">&lt;c-u&gt;</span><span class="keyword">call</span> <span class="symbol">&lt;SID&gt;</span>GrepOperator(<span class="built_in">visualmode</span>())<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">GrepOperator</span><span class="params">(type)</span></span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<ul>
<li>modified the function name to start with <code>s:</code> which places it in the current script’s namespace</li>
<li>modified the mapping and prepended the <code>GrepOperator</code> function name with <code>&lt;SID&gt;</code> so they could find the function.<ul>
<li>If we hadn’t done this they would have tried to find the function in the global namespace, which wouldn’t have worked</li>
</ul>
</li>
</ul>
<p><code>:h &lt;SID&gt;</code></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Vim List is much like python.</p>
<ul>
<li>Lists<ul>
<li><code>:echo [&#39;foo&#39;, 3, &#39;bar&#39;]</code></li>
<li><code>:echo [&#39;foo&#39;, [3, &#39;bar&#39;]]</code> of course can be nested</li>
</ul>
</li>
<li>Indexing<ul>
<li><code>:echo [0, [1, 2]][1]</code> will display <code>[1, 2]</code></li>
<li><code>:echo [0, [1, 2]][-2]</code> will display <code>0</code></li>
</ul>
</li>
<li>Slicing<ul>
<li><code>:echo [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;][0:2]</code></li>
<li><code>:echo [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;][:2]</code></li>
</ul>
</li>
<li>Concatenation<ul>
<li><code>:echo [&#39;a&#39;, &#39;b&#39;] + [&#39;c&#39;]</code></li>
</ul>
</li>
<li>Built-in List Function<ul>
<li><code>:call add(list, &#39;b&#39;)</code> append <code>b</code> </li>
<li><code>:echo len(list)</code></li>
<li><code>:echo get(foo, 100, &#39;default&#39;)</code><ul>
<li>The <code>get</code> function will get the item at the given index from the given list, or return the given default value if the index is out of range in the list.</li>
</ul>
</li>
<li><code>:echo index(foo, &#39;b&#39;)</code><ul>
<li>return the first index of <code>b</code>, or <code>-1</code> if not in list</li>
</ul>
</li>
<li><code>:echo join(list, &#39;--&#39;)</code> join item in list together into a string</li>
<li><code>:call reverse(list)</code></li>
</ul>
</li>
</ul>
<p><code>:h functions</code></p>
<h3 id="Looping"><a href="#Looping" class="headerlink" title="Looping"></a>Looping</h3><ul>
<li>For Loops  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">endfor</span></span><br></pre></td></tr></table></figure></li>
<li>While Loops  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">c</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">c</span> &lt;= <span class="number">4</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">c</span> += <span class="number">1</span></span><br><span class="line"><span class="keyword">endfor</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h3><ul>
<li>Dictionaries<ul>
<li><code>:echo {&#39;a&#39;: 1, 100: &#39;foo&#39;}</code></li>
</ul>
</li>
<li>Indexing<ul>
<li><code>:echo {&#39;a&#39;: 1, 100: &#39;foo&#39;,}[&#39;a&#39;]</code></li>
<li>Or Javascritp-style “dot” <code>:echo {&#39;a&#39;: 1, 100: &#39;foo&#39;,}.a</code></li>
</ul>
</li>
<li>Assigning and Adding <code>:let foo = {&#39;a&#39;: 1}</code><ul>
<li>Assigning: <code>:let foo.a = 100</code> </li>
<li>Add: <code>:let foo.b = 200</code></li>
</ul>
</li>
<li>Removing Entries<ul>
<li><code>:let test = remove(foo, &#39;a&#39;)</code><ul>
<li>Remove the entry with the given key</li>
<li>And return the removed value</li>
</ul>
</li>
<li><code>unlet foo.b</code><ul>
<li>Also removes entries, but you can’t use the value</li>
</ul>
</li>
</ul>
</li>
<li>Dictionary Functions<ul>
<li><code>:echom get({&#39;a&#39;: 100}, &#39;b&#39;, &#39;default&#39;)</code><ul>
<li>just like get function for lists</li>
</ul>
</li>
<li><code>:echom has_key({&#39;a&#39;: 100}, &#39;a&#39;)</code><ul>
<li>return <code>0</code> as falsy</li>
</ul>
</li>
<li><code>:echo items({&#39;a&#39;: 100, &#39;b&#39;: 200})</code><ul>
<li>You can pull the key-value pairs out of a dict with <code>item</code></li>
<li>display like <code>[[&#39;a&#39;, 100], [&#39;b&#39;, 200]]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Toggling"><a href="#Toggling" class="headerlink" title="Toggling"></a>Toggling</h3><p>For boolean options we can use <code>set someoption!</code> to “toggle” the option.If we want to toggle a non-boolean option we’ll need to do a bit more work.</p>
<p>Like this. Remember Vim treats the 0 as falsy and any other number as truthy</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">FoldColumnToggle</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> &amp;foldcolumn</span><br><span class="line">        <span class="keyword">setlocal</span> foldcolumn=<span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">setlocal</span> foldcolumn=<span class="number">4</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Or</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">QuickfixToggle</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">g:quickfix_is_open</span></span><br><span class="line">        <span class="keyword">cclose</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">g:quickfix_is_open</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">copen</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">g:quickfix_is_open</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>:h wincmd</code></li>
<li><code>:h winnr()</code></li>
</ul>
<h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a>Functional Programming</h3><h4 id="Immutable-Data-Structures"><a href="#Immutable-Data-Structures" class="headerlink" title="Immutable Data Structures"></a>Immutable Data Structures</h4><p>Vim dosen’t have any immutable collections, but by create some helper functions we can fake it to some degree.</p>
<p>Like this:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">Sorted</span><span class="params">(l)</span></span></span><br><span class="line">    <span class="keyword">let</span> new_list = <span class="built_in">deepcopy</span>(<span class="variable">a:l</span>)</span><br><span class="line">    <span class="keyword">call</span> <span class="keyword">sort</span>(new_list)</span><br><span class="line">    <span class="keyword">return</span> new_list</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>Vim’s <code>sort()</code> sorts the list in place, so we create a full copy so original list won’t changed.</p>
<h4 id="Functions-as-Variables"><a href="#Functions-as-Variables" class="headerlink" title="Functions as Variables"></a>Functions as Variables</h4><p>Vimscript supports using variables to store functions, but the syntax is a bit obtuse.</p>
<p>If a Vimscript variable refers to a function it must start with a capital letter.</p>
<h4 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher-Order Functions"></a>Higher-Order Functions</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">Mapped</span><span class="params">(fn, l)</span></span></span><br><span class="line">    <span class="keyword">let</span> new_list = <span class="built_in">deepcopy</span>(<span class="variable">a:l</span>)</span><br><span class="line">    <span class="keyword">call</span> <span class="keyword">map</span>(new_list, <span class="built_in">string</span>(<span class="variable">a:fn</span>) . <span class="string">'(v:val)'</span>)</span><br><span class="line">    <span class="keyword">return</span> new_list</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">:h <span class="keyword">map</span>()</span><br><span class="line">:h <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>


<h3 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h3><ul>
<li>Relative Paths<ul>
<li><code>:echom expand(&#39;%&#39;)</code>. <code>%</code>means the file you’re editing.</li>
</ul>
</li>
<li>Absolute Paths<ul>
<li><code>:echom expand(&#39;%:p&#39;)</code>. The <code>:p</code> in the string tells Vim that you want the absolute path.</li>
<li><code>:echo fnamemodify(&#39;foo.txt&#39;, &#39;:p&#39;)</code> did the same. <code>fnamemodify()</code> is a Vim function that’s more flexible than <code>expand()</code> in that you can specify any file name, not just special stirngs.</li>
</ul>
</li>
<li>Listing Files<ul>
<li><code>:echo split(globpath(&#39;.&#39;, &#39;*&#39;), &#39;\n&#39;)</code>, list of files in a specific directory(here is all files of current dir).</li>
<li>You can recursively list file with <code>**</code>:<code>:echo split(globpath(&#39;.&#39;, &#39;**&#39;), &#39;\n&#39;)</code></li>
</ul>
</li>
</ul>
<h2 id="Creating-a-Full-Plugin"><a href="#Creating-a-Full-Plugin" class="headerlink" title="Creating a Full Plugin"></a>Creating a Full Plugin</h2><h3 id="Basic-Layout"><a href="#Basic-Layout" class="headerlink" title="Basic Layout"></a>Basic Layout</h3><ul>
<li>Files in <code>~/.vim/colors</code> are treated as color schemes</li>
<li>Files in <code>~/.vim/plugin</code> will each be run once every time Vim starts</li>
<li>Files in <code>~/.vim/ftdetect</code> will also be run every time you start Vim<ul>
<li><code>ftdetect</code> stands for “filetype detection”</li>
<li>The file in this dir should set up autocommmands that detect and set the <code>filetype</code> of files</li>
</ul>
</li>
<li>Files in <code>~/.vim/ftplugin</code>. When Vim sets a buffer’s <code>filetype</code> to a value it then looks for a file(or dir) in <code>ftplugin</code> that matches and run it.<ul>
<li>The naming of these files matters!</li>
<li>Because these files are run every time a buffer’s filetype is set they must only set buffer-local options! If they set options globally they would overwrite them for all open buffers!</li>
</ul>
</li>
<li>Files in <code>~/.vim/indent</code> are a lot like <code>ftplugin</code> files. They get loaded based on their names.</li>
<li>Files in <code>~/.vim/compiler</code> work exactly like <code>indent</code> files.<ul>
<li>They should set compiler-related options in the current buffer based on their names</li>
</ul>
</li>
<li>Files in <code>~/.vim/after</code> Files in this dir will be loaded every time Vim start, but after the file in <code>~/.vim/plugin</code></li>
<li>Files in <code>~/.vim/autoload</code> </li>
<li>Files in <code>~/.vim/syntax</code> When Vim sets a buffer’s <code>filetype</code> to a value it then looks for a file(or dir) in <code>syntax</code> that matches and run it.</li>
<li>Files in <code>~/.vim/doc</code> is where you can add doc for your plugin</li>
</ul>
<h3 id="Runtimepath"><a href="#Runtimepath" class="headerlink" title="Runtimepath"></a>Runtimepath</h3><p>Much like <code>PATH</code> on <code>Linux/Unix/BSD</code> systems, Vim has the runtimepath setting which tells it where to find files to load.</p>
<p><code>:set runtimepath?</code></p>
<p>So a plugin manager automatically add paths to your <code>runtimepath</code> when you load vim</p>
<h3 id="Detecting-Filetype"><a href="#Detecting-Filetype" class="headerlink" title="Detecting Filetype"></a>Detecting Filetype</h3><p>Vim dosen’t what a <code>.type</code> file is yet.</p>
<p>Create <code>ftdetect/TYPE.vim</code></p>
<p><code>au BufNewFile,BufRead *.TYPE set filetype=TYPE</code></p>
<h3 id="Basic-Syntax-Highlighting"><a href="#Basic-Syntax-Highlighting" class="headerlink" title="Basic Syntax Highlighting"></a>Basic Syntax Highlighting</h3><ul>
<li><code>:help syn-keyword</code></li>
<li><code>:help iskeyword</code></li>
<li><code>:help group-name</code></li>
<li><code>:help syntax</code></li>
</ul>
<p>Create a <code>syntax/potion.vim</code> file and set you buffer filetype to potion <code>:set filetype=potion</code>. The <code>to</code>, <code>times</code> and <code>if</code> words will be highlighted as keywords.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">syntax</span> keyword potionKeyword <span class="keyword">to</span> times</span><br><span class="line"><span class="keyword">syntax</span> keyword potionKeyword <span class="keyword">if</span></span><br><span class="line"><span class="keyword">highlight</span> link potionKeyword Keyword</span><br></pre></td></tr></table></figure>

<p>These two lines show the basic structure of simple sytax highlight in Vim.</p>
<ul>
<li>You first define a “chunk” of syntax using <code>syntax keyword</code> or a related command (which we’ll talk about later)</li>
<li>You then link “chunks” to highlighting groups. A highlighting group is something you define in a color scheme, for example “function names should be blue”.</li>
</ul>
<h4 id="Highlighting-Functions"><a href="#Highlighting-Functions" class="headerlink" title="Highlighting Functions"></a>Highlighting Functions</h4><p>Another standard Vim highlighting group is <code>Function</code>.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">syntax</span> keyword potionFunction <span class="keyword">print</span> <span class="keyword">join</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">highlight</span> link potionFunction Function</span><br></pre></td></tr></table></figure>


<h4 id="Advanced-Syntax-Highlighting"><a href="#Advanced-Syntax-Highlighting" class="headerlink" title="Advanced Syntax Highlighting"></a>Advanced Syntax Highlighting</h4><p>Because some character not in <code>iskeyword</code> we need to use a regular expression to match it. We’ll do this with <code>syntax match</code> instead of <code>syntax keyword</code>.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">syntax</span> <span class="keyword">match</span> potionComment <span class="string">"\v#.*$"</span></span><br><span class="line"><span class="keyword">highlight</span> link potionComment Comment</span><br></pre></td></tr></table></figure>

<p>We use <code>syntax match</code> which tells Vim to match regexes instead of literal keywords.</p>
<h4 id="Highlighting-Operators"><a href="#Highlighting-Operators" class="headerlink" title="Highlighting Operators"></a>Highlighting Operators</h4><p>Another part we need to regexes to highlight is operators. <code>:h group-name</code></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">syntax</span> <span class="keyword">match</span> potionOperator <span class="string">"\v-\="</span></span><br><span class="line"><span class="keyword">highlight</span> link potionOperator Operator</span><br></pre></td></tr></table></figure>


<h4 id="Highlighting-Strings"><a href="#Highlighting-Strings" class="headerlink" title="Highlighting Strings"></a>Highlighting Strings</h4><p><code>:help syn-region</code></p>
<p>To highlight strings, we’ll use the <code>syntax region</code> command.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">syntax</span> region potionString start=/\v<span class="string">"/ skip=/\v\\./ end=/\v"</span>/</span><br><span class="line"><span class="keyword">highlight</span> link potionString String</span><br></pre></td></tr></table></figure>

<p>You’ll see the string between “” is highlighted!</p>
<ul>
<li>Regions hava a “start” pattern and an “end” pattern that specify where they start and end</li>
<li>The <code>skip</code> argument tells Vim to ignore this matching region<ul>
<li>The “skip” argument to <code>syntax region</code> allow us to handle string escapes like <code>&quot;she said: \&quot;hello\&quot;!&quot;</code></li>
</ul>
</li>
</ul>
<h3 id="Basic-Folding"><a href="#Basic-Folding" class="headerlink" title="Basic Folding"></a>Basic Folding</h3><ul>
<li><code>:help usr_28</code></li>
<li><code>:help fold-XXX</code></li>
</ul>
<ul>
<li>Manual<ul>
<li>You create the folds by hand and they stored in RAM. When you close Vim they go away.</li>
</ul>
</li>
<li>Marker<ul>
<li>Vim folds your code based on characters in the actual text.</li>
<li>Usually these characters put in comments (like<code>3{</code>), but in some languages you can get away with using something in the language’s syntax itself, like <code>{</code> in javascript file.</li>
<li>It may seem ugly to clutter up your code with comments, but it let you hand-craft folds for a specific file.</li>
</ul>
</li>
<li>Diff<ul>
<li>A special folding mode used when diff’ing files.</li>
</ul>
</li>
<li>Expr<ul>
<li>This lets you use a custom piece of Vimscript to define where folds occur.</li>
</ul>
</li>
<li>Indent<ul>
<li>Vim uses your code’s indentation to determine folds.</li>
</ul>
</li>
</ul>
<p><code>setlocal foldmethod=&lt;method&gt;</code> and play around with <code>zR</code>, <code>zM</code>, <code>za</code>, <code>zf</code>…</p>
<h4 id="Advanced-Folding"><a href="#Advanced-Folding" class="headerlink" title="Advanced Folding"></a>Advanced Folding</h4><ul>
<li>Folding Theory<ul>
<li>Each line of code in a file has a “foldlevel”. This is always either zero or a positive interger.</li>
<li>Lines with a foldlevel of zero are never include in any fold</li>
<li>Adjacant line with the same foldlevel are folded togerther</li>
<li>If a fold level X is closed, any subsequent lines with a foldlevel greater then or equal to X are folded along with it until you reach a line with a level less than X.</li>
</ul>
</li>
</ul>
<h5 id="Expr-Folding"><a href="#Expr-Folding" class="headerlink" title="Expr Folding"></a>Expr Folding</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">setlocal</span> foldmethod=expr</span><br><span class="line"><span class="keyword">setlocal</span> foldexpr=GetPotionFold(<span class="variable">v:lnum</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">GetFold</span><span class="params">(lnum)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<ul>
<li>first line tells Vim to use <code>expr</code> folding</li>
<li>second line defines the expression Vim should use to get the foldlevel of a line<ul>
<li>When Vim runs the expression it will set <code>v:lnum</code> to the line number of the ling it wants to know about.</li>
</ul>
</li>
<li>The expr function return a String and not an Integer</li>
</ul>
<p>Our funciont return <code>&#39;0&#39;</code> for every lines, so Vim won’t fold andthing at all.</p>
<h5 id="Blank-Lines"><a href="#Blank-Lines" class="headerlink" title="Blank Lines"></a>Blank Lines</h5><p>Modify the <code>GetFold</code> function to look like this:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">GetPotionFold</span><span class="params">(lnum)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">getline</span>(<span class="variable">a:lnum</span>) =~? <span class="string">'\v^\s*$'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'-1'</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Use <code>getline(a:lnum)</code> to get the content of the current line as a String.<ul>
<li>This regex <code>\v^\s*$</code> will match “beginning of line, any number of whitespace characters, end of line”</li>
</ul>
</li>
</ul>
<h5 id="Special-Foldlevels"><a href="#Special-Foldlevels" class="headerlink" title="Special Foldlevels"></a>Special Foldlevels</h5><p>Your custom folding expression can return one of a few “special” strings that tell Vim how to fold the line.</p>
<p><code>-1</code> is one of these special strings. It tells Vim that the level of this line is “underfined”, which means “the foldlevel of this line is equal to the foldlevel of the line above or below it”</p>
<h5 id="An-Indentation-Level-Helper"><a href="#An-Indentation-Level-Helper" class="headerlink" title="An Indentation Level Helper"></a>An Indentation Level Helper</h5><p>To tackle non-blank lines we’ll need to know their indentation level.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">IndentLevel</span><span class="params">(lnum)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">indent</span>(<span class="variable">a:lnum</span>) / &amp;<span class="built_in">shiftwidth</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>And run <code>:echom IndentLevel(1)</code> to see line 1 indent level.</p>
<h3 id="Section-Movement-Theory"><a href="#Section-Movement-Theory" class="headerlink" title="Section Movement Theory"></a>Section Movement Theory</h3><p>If you’ve never used Vim’s section movement commands(like: <code>[[</code>, <code>]]</code>, <code>[]</code>, <code>][</code>) take a second and read <code>:help section</code></p>
<h4 id="Nroff-Files"><a href="#Nroff-Files" class="headerlink" title="Nroff Files"></a>Nroff Files</h4><p>The four “section movement” commands are conceptually meant to move around between “sections” of a file.</p>
<p>These commands are designed to work with <a href="https://en.wikipedia.org/wiki/Nroff" target="_blank" rel="noopener">nroff files</a> by default.</p>
<h3 id="External-Commands"><a href="#External-Commands" class="headerlink" title="External Commands"></a>External Commands</h3><p>The <code>:!</code> command (pronounced “bang”) in Vim runs external commands and display their output on the screen.</p>
<p>Vim doesn’t pass any input to the command then run this way: <code>:!cat</code></p>
<p>To run an external command without the <code>Press ENTER or type command to continue</code> prompt, use <code>:silent !</code>. Note that this command is <code>:silent !</code> and not <code>:silent!</code></p>
<h4 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h4><p>The <code>system()</code> Vim function takes a command string as a parameter and returns the output of that command as String.</p>
<p>You can pass a second string as an argument to <code>system()</code>. Run the following command: <code>:echom system(&quot;wc -c&quot;, &quot;abcdefg&quot;)</code></p>
<p>If you pass a second argument like this, Vim will write it to a temporary file and pipe it into the command on standard input.</p>
<h4 id="Scratch-Splits"><a href="#Scratch-Splits" class="headerlink" title="Scratch Splits"></a>Scratch Splits</h4><p><code>:split BufferName</code> create an new splite for a buffer named <code>BufferName</code></p>
<h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><p>The <code>append()</code> Vim function takes two arguments: a line number to append after, and a list of Strings to append as lines. For example:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> <span class="keyword">append</span>(<span class="number">3</span>, [<span class="string">"foo"</span>, <span class="string">"bar"</span>])</span><br></pre></td></tr></table></figure>

<p><code>:help append()</code></p>
<h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><p><code>split()</code> takes a String to split and regular expression to find the split points.</p>
<p><code>:help split()</code></p>
<h3 id="Autoloading"><a href="#Autoloading" class="headerlink" title="Autoloading"></a>Autoloading</h3><p><code>:help autoload</code></p>
<p>Autoload lets you delay loading code until it’s actually needed.</p>
<p>Look at the following command:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">call</span> somefile#Hello()</span><br></pre></td></tr></table></figure>

<p>If this function has already been loaded, Vim will simply call it normally. Otherwise Vim will look for a file called <code>autoload/somefile.vim</code>.</p>
<p>If this file exists, Vim will load/source that file. It will then try to call the function normally.</p>
<p>Inside this file, the function should be defined like this:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somefile</span>#<span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">" ...</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<p>You can use multiple <code>#</code> characters in the function name like <code>:call myplugin#somefile#Hello()</code>. And it will look for <code>autoload/myplugin/somefile.vim</code></p>
<p>If a autoload function like <code>somefile#Hello()</code> has been loaded, Vim doesn’t need to reload the file to call it. </p>
<p>If <code>somefile#A()</code> has been load and <code>somefile#B()</code> doesn’t load. At that time, you rewrite function A. Without closing Vim and call funcion B, Vim will reload this file and your modify in function A will be update.</p>
<h3 id="Documentetion"><a href="#Documentetion" class="headerlink" title="Documentetion"></a>Documentetion</h3><h4 id="How-Documentetion-Works"><a href="#How-Documentetion-Works" class="headerlink" title="How Documentetion Works"></a>How Documentetion Works</h4><p>A documentation <code>filetype=help</code>.</p>
<p>Create a file called <code>doc/somefile.txt</code> in you plugin repo. This is where we’ll write help for our plugin.</p>
<p>Open this file in Vim and run <code>:set filetype=help</code> so you can see the syntax highlighting as you type.</p>
<h4 id="Help-Header"><a href="#Help-Header" class="headerlink" title="Help Header"></a>Help Header</h4><p>The format of help files is a matter of personal taste, but better to be popular with the modern Vimscript community.</p>
<ul>
<li>The first line of the file should contain the filename of the help file.<ul>
<li><code>*myhelp.txt* functionality for the potion programming language</code></li>
</ul>
</li>
<li>Surrounding a word witd asterisks in a help file create a “tag” that can be jumped to.<ul>
<li>Run <code>:Helptags</code> to rebuild the index of help tags, and then open a new Vim window and run <code>:help myhelp.txt</code>. Vim will open your help document like any other one.</li>
</ul>
</li>
<li>Title, description, authors and something<ul>
<li>The <code>~</code> characters at the end of the lines ensure that Vim dosen’t try to highlight or hide individual characters inside the art.</li>
</ul>
</li>
</ul>
<h4 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">====================================================</span><br><span class="line">CONTENTS                                            *PotionContents*</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>. Usage ................ |PotionUsage|</span><br><span class="line">    <span class="number">2</span>. Mappings ............. |PotionMappings|</span><br><span class="line">    <span class="number">3</span>. License .............. |PotionLicense|</span><br><span class="line">    <span class="number">4</span>. Bugs ................. |PotionBugs|</span><br><span class="line">    <span class="number">5</span>. Contributing ......... |PotionContributing|</span><br><span class="line">    <span class="number">6</span>. Changelog ............ |PotionChangelog|</span><br><span class="line">    <span class="number">7</span>. Credits .............. |PotionCredits|</span><br></pre></td></tr></table></figure>

<ul>
<li>The line of <code>=</code> character will be syntax highlight. Use to divide.<ul>
<li>You can also use line of <code>-</code></li>
</ul>
</li>
<li>The <code>*PotionContents*</code> will create another tag, so run <code>:help PotionContents</code> to go directly to the table of contents.</li>
<li>Each of the word surrounded by <code>|</code> create a ling to a tag<ul>
<li>Users can press <code>&lt;c-]&gt;</code> in the file file to jump to the tag, Or click with mouse</li>
</ul>
</li>
</ul>
<h3 id="The-Command-Command"><a href="#The-Command-Command" class="headerlink" title="The Command Command"></a>The Command Command</h3><p>Read <code>:help user-commands</code></p>
<p>Some plugin hava commands like <code>:Gdiff</code> and leave it up to the user to decide how to call them.</p>
<p>Commands like this are create with the <code>:command</code> command.</p>
<h3 id="Omnicomplete"><a href="#Omnicomplete" class="headerlink" title="Omnicomplete"></a>Omnicomplete</h3><ul>
<li><code>:help ins-completion</code></li>
<li><code>:help omnifunc</code></li>
<li><code>:help compl-omni</code></li>
</ul>
<p>Vim offer a number of different ways to complete text. The most powerful of them is “omnicomplete” which let you call a custom Vimscirpt function to determin completions.</p>
<h3 id="Compiler-Support"><a href="#Compiler-Support" class="headerlink" title="Compiler Support"></a>Compiler Support</h3><p>Read <code>:help quickfix.txt</code></p>
<p>Vim offer much deeper support for interacting with compilers, including parsing compile error.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/universe/the_nature_of_code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/14/universe/the_nature_of_code/" class="post-title-link" itemprop="url">用processing模拟自然系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-14T00:00:00+08:00">2020-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="随机游走"><a href="#随机游走" class="headerlink" title="随机游走"></a>随机游走</h2><ul>
<li>processing中的random()函数生成的随机数是均匀分布的</li>
<li>可以利用random函数生成非均匀分布的随机数<ul>
<li>创建一个非均匀的数组，用random来随机的取索引</li>
</ul>
</li>
<li>也可用random来取概率，但是注意数据类型(float和int有区别)</li>
<li>随机数的正态分布<ul>
<li><code>(float)generator.nextGaussian()</code>返回一个高斯随机数，nextGaussian返回值的类型是double</li>
</ul>
</li>
</ul>
<h3 id="Perlin噪声-一种更平滑的算法"><a href="#Perlin噪声-一种更平滑的算法" class="headerlink" title="Perlin噪声(一种更平滑的算法)"></a>Perlin噪声(一种更平滑的算法)</h3><p>Perlin生成的随机数更平滑，但仍有一定的随机性。</p>
<p>Processing内置了<code>noise()</code>函数，可以有1~3个参数。<br>分别表示一维、二维、三维随机数。</p>
<p>noise函数返回的结果总是在0~1之间，我们可以通过map函数来改变结果的范围，<br>可以吧一维的Perlin噪声当作随着时间推移而发生变化的线性序列。<br>通过往noise传入一个”指定的时间”来获取这个时间点上的噪声。</p>
<p>同理，二维噪声像个崎岖不平的面</p>
<h3 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h3><p><code>map(a, b, c, d)</code>, 原范围(a, b), 希望映射到的范围(c, d)</p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Travis TuRing</p>
  <div class="site-description" itemprop="description">Mens et Manus</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Travis TuRing</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
