<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Mens et Manus">
<meta property="og:type" content="website">
<meta property="og:title" content="Ring&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Ring&#39;s Blog">
<meta property="og:description" content="Mens et Manus">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Travis TuRing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Ring's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ring's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/23/universe/tech_tips/regular_expression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/23/universe/tech_tips/regular_expression/" class="post-title-link" itemprop="url">正则表达式基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-23 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-23T00:00:00+08:00">2020-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-22 11:33:47" itemprop="dateModified" datetime="2020-11-22T11:33:47+08:00">2020-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Base/Extended Regex</p>
<ul>
<li><code>.</code><ul>
<li>匹配任何一个字符</li>
</ul>
</li>
<li><code>*</code><ul>
<li>(贪婪)匹配任何数量(包括0)的前面的内容，贪婪匹配</li>
</ul>
</li>
<li><code>+</code><ul>
<li>匹配一个或多个的前面的内容，非贪婪匹配</li>
</ul>
</li>
<li><code>-</code><ul>
<li>匹配零个或多个的前面的内容，非贪婪匹配</li>
</ul>
</li>
<li><code>{1}</code><ul>
<li>重复次数1</li>
</ul>
</li>
<li><code>\S</code><ul>
<li>任何非空白字符</li>
</ul>
</li>
<li><code>\s</code><ul>
<li>任何空白字符</li>
</ul>
</li>
<li><code>?</code><ul>
<li>前面内容是可选的</li>
</ul>
</li>
<li><code>\</code><ul>
<li>有时可以起到转意的作用，<code>\S</code>等就是例外</li>
</ul>
</li>
<li><code>[0-9]</code><ul>
<li>任何0到9的数字，范围可变但要按顺序</li>
</ul>
</li>
<li><code>[a-z]</code><ul>
<li>任何a到z的小写字符，范围可变但要按顺序</li>
</ul>
</li>
<li><code>[A-Z]</code><ul>
<li>任何A到Z的大写字符，范围可变但要按顺序</li>
</ul>
</li>
<li><code>[A-Za-z]</code><ul>
<li>任何A到Z的字符，范围可变但要按顺序</li>
</ul>
</li>
<li>锚定<ul>
<li><code>$</code><ul>
<li>以前面的内容结束</li>
</ul>
</li>
<li><code>^</code><ul>
<li>以前面的内容开头</li>
</ul>
</li>
<li><code>\&lt; ,\b</code><ul>
<li>锚定单词首部</li>
</ul>
</li>
<li><code>\&gt; ,\b</code><ul>
<li>锚定单词结尾</li>
</ul>
</li>
</ul>
</li>
<li><code>|</code><ul>
<li>or，整个左边或整个右边如<code>C|cat</code>表示C或cat</li>
<li>也可使用分组改变执行顺序<code>(C|c)at</code>表示Cat或cat</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/universe/linux/linux_note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/universe/linux/linux_note/" class="post-title-link" itemprop="url">Linux学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-20T00:00:00+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-01 20:43:32" itemprop="dateModified" datetime="2020-11-01T20:43:32+08:00">2020-11-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux哲学"><a href="#Linux哲学" class="headerlink" title="Linux哲学"></a>Linux哲学</h2><ul>
<li>Linux基本原则<ul>
<li><ol>
<li>由目的单一的小程序组成，组合小程序完整复杂任务</li>
</ol>
</li>
<li><ol start="2">
<li>一切皆文件</li>
</ol>
</li>
<li><ol start="3">
<li>避免捕获用户接口，避免与用户交互</li>
</ol>
</li>
<li><ol start="4">
<li>配置文件保存为纯文本格式</li>
</ol>
</li>
</ul>
</li>
<li>命令格式<code>命令 选项 参数</code><ul>
<li>短选项：<code>-</code>加某个字母，如<code>-h</code>查看help<ul>
<li>短选项可以多个选项写一起<code>-a -b = -ab</code></li>
</ul>
</li>
<li>长选项：<code>--&lt;option&gt;</code></li>
</ul>
</li>
<li>命令模板<ul>
<li><code>[]</code>中表示可选的内容</li>
<li><code>&lt;&gt;</code>中表示必须给出的内容</li>
<li><code>...</code>表示可以出现多个，可以使用多次</li>
<li>用<code>|</code>分割表示多选一，如<code>[-a|-b]</code></li>
</ul>
</li>
<li>魔数Magic Number：标记文件的执行格式，如<code>#!/bin/sh</code>，也称为shebang</li>
</ul>
<h3 id="FHS-文件层级系统"><a href="#FHS-文件层级系统" class="headerlink" title="FHS(文件层级系统)"></a>FHS(文件层级系统)</h3><ul>
<li>/boot: 系统启动相关文件</li>
<li>/dev: 设备文件</li>
<li>/etc: 配置文件，存文本</li>
<li>/home: 用户家目录</li>
<li>/root: 管理员家目录</li>
<li>/lib: 库文件<ul>
<li>/lib/modules: 内核模块文件</li>
<li>静态库<ul>
<li>linux下表现为.a</li>
</ul>
</li>
<li>动态库:载入到内存中可以复用<ul>
<li>win下表现为.dll文件，linux下表现为.so(shared object)</li>
</ul>
</li>
</ul>
</li>
<li>/opt: 可选目录，第三方程序的安装目录</li>
<li>/proc: 伪文件系统，内核映射</li>
<li>/sys: 伪文件系统，跟硬件相关的属性映射</li>
<li>/tmp: 临时文件，会定时清理</li>
<li>/var: 可变化文件</li>
<li>/bin: 可执行文件，用户命令</li>
<li>/sbin: 管理命令</li>
<li>/usr: universal shared read-only<ul>
<li>usr下之所以有/usr/bin和/usr/sbin是因为/bin跟启动系统相关，而/usr下跟启动系统后提供正常功能相关</li>
</ul>
</li>
<li>/usr/local: 又是一个独立的文件系统，也有bin，sbin。是第三方软件的安装路径</li>
</ul>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><ul>
<li>man：查看手册<ul>
<li><code>whatis name</code>查看name的目录，使用<code>man [n] name</code>打开name第n章</li>
</ul>
</li>
<li>tr：字符串转换或删除<ul>
<li><code>tr &#39;a-z&#39; &#39;A-Z&#39;</code>把输入中的字符转换成大写</li>
<li><code>tr -d &#39;abc&#39;</code>删除出现的字符，这里是a，b，c</li>
</ul>
</li>
<li>shell中可以开子shell，使用<code>pstree</code>可以查看父子关系，使用exit退出一个</li>
<li>环境变量<ul>
<li><code>PATH</code>命令搜索路径</li>
<li><code>HISTSIZE</code>命令历史缓冲区<ul>
<li>使用<code>history</code>查看命令历史</li>
<li>使用<code>!n</code>执行命令历史中第n条历史命令</li>
<li>使用<code>!-n</code>执行命令历史中倒数第n条历史命令</li>
<li>使用<code>!!</code>执行刚才执行的命令</li>
<li>使用<code>!string</code>执行命令历史中最近的以指定字符串开头的命令</li>
<li>使用<code>!$</code>引用上一个命令的最后一个参数</li>
</ul>
</li>
</ul>
</li>
<li>命令替换：<code>$(COMMAND)</code>或使用反引号`COMMAND`<ul>
<li>把命令的结果放入一个命令中</li>
<li><code>echo $(ls)</code></li>
</ul>
</li>
<li><strong>shell中的引号</strong>：<ul>
<li>反引号``：命令替换</li>
<li>双引号””：弱引用。可以实现变量替换</li>
<li>单引号’’：强引用。不能实现变量替换</li>
</ul>
</li>
<li>文件名通配，globbing<ul>
<li><code>*</code>：任意长度的任意字符</li>
<li><code>?</code>：任意单个字符</li>
<li><code>[]</code>：指定范围内的任意单个字符</li>
<li><code>[^]</code>：指定范围外的任意单个字符</li>
<li>特殊字符，形如<code>[:punct:]</code>。<code>[:punct:]</code>所有的标点符号</li>
</ul>
</li>
<li>生成列表<ul>
<li><code>seq [OPTION] [FIRST] [INCREMENT] LAST</code></li>
</ul>
</li>
<li><code>xargs</code><ul>
<li>从标准输入接收命令并执行</li>
</ul>
</li>
<li><code>w</code><ul>
<li>显示已登录的用户</li>
</ul>
</li>
<li><code>last</code><ul>
<li>显示登录日志，即显示<code>/var/log/wtmp</code>文件</li>
</ul>
</li>
<li><code>lastb</code><ul>
<li>显示错误的登录日志，即显示<code>/var/log/btmp</code>文件</li>
</ul>
</li>
<li><code>lastlog</code><ul>
<li>显示每一个用户最近一次的成功登录信息</li>
</ul>
</li>
<li><code>basename</code><ul>
<li>显示文件的基路径名</li>
</ul>
</li>
</ul>
<h2 id="管道及IO重定向"><a href="#管道及IO重定向" class="headerlink" title="管道及IO重定向"></a>管道及IO重定向</h2><ul>
<li>系统设定<ul>
<li>默认输入设备，标准输入，stdin, 0</li>
<li>默认输出设备，标准输出，stdout, 1</li>
<li>标准错误输出，stderr, 2</li>
</ul>
</li>
<li>重定向及文件描述符<ul>
<li>输出重定向<ul>
<li><code>&gt;</code>覆盖输出<ul>
<li>强制覆盖：当设置了不允许覆盖已存在文件时使用<code>&gt;|</code></li>
</ul>
</li>
<li><code>&gt;&gt;</code>追加输出</li>
<li><code>2&gt;</code>, <code>2&gt;&gt;</code>重定向错误输出<ul>
<li>可以使用<code>ls ./ &gt; a.out 2&gt; b.out</code>这样的形式</li>
</ul>
</li>
<li><code>&amp;&gt;</code>将两种输出(标准输出，标准错误)同时输出到同个文件</li>
<li><code>2&gt;&amp;1</code><strong>重定向绑定</strong>，2(标准错误)重定向到1定向的文件<ul>
<li>shell脚本从左所以注意顺序<code>&gt;/dev/null 2&gt;&amp;1</code> VS <code>2&gt;&amp;1 &gt;/dev/null</code><ul>
<li>前者1定向到null，2再定向到1定向的文件(null)</li>
<li>前者1定向到null，2再定向到1定向的文件(stdout)，然后1才定向到null</li>
</ul>
</li>
<li>为什么不用<code>&gt;/path/to 2&gt;/path/to</code><ul>
<li>这种方法，标准输出和错误输出会抢占out文件的管道，因此输出的顺序无法估计</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>输入重定向<ul>
<li><code>&lt;</code>输入重定向</li>
<li><code>&lt;&lt;</code>Here Document  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &lt;&lt; END_SIGN</span><br><span class="line">&gt; hello</span><br><span class="line">&gt; END_SIGN</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>关闭/打开文件描述符(输入输出)<ul>
<li><code>[n]&gt;&amp;-</code>或<code>[n]&lt;&amp;-</code>，都是把文件描述符n关闭</li>
<li><code>[n]&lt;&gt;file</code>，打开file，指定其文件描述符为n，不指定默认为0</li>
<li><code>exec 1&gt;&amp;-</code>后尝试<code>echo mess</code>将会失败</li>
<li><code>exec closed_fd&gt;new_fd</code>或<code>exec new_fd&lt;close_fd</code>，打开文件描述符</li>
</ul>
</li>
<li>文件描述符复制<ul>
<li><code>[fd1]&gt;&amp;fd2</code>或<code>[fd1]&lt;&amp;fd2</code>，把fd2复制给fd1</li>
<li>在不缺省的情况下两者的等价的，都是将fd2的描述符复制给fd1</li>
<li>如果fd1缺省，则<code>&gt;&amp;fd2</code>默认复制给标准输出；而<code>&lt;&amp;fd2</code>默认复制给标准输入</li>
</ul>
</li>
<li>文件描述符移动<ul>
<li><code>[fd1]&gt;&amp;fd2-</code>，把文件描述符fd2代表的输出文件复制给fd1，并关闭fd2<ul>
<li>即输出重定向，然后关闭</li>
</ul>
</li>
<li><code>[fd1]&lt;&amp;fd2-</code>，把文件描述符fd2代表的输入文件复制给fd1作为输入文件，并关闭fd2</li>
</ul>
</li>
</ul>
</li>
<li>管道<ul>
<li><code>cmd1 | cmd2</code>前一个命令的输出作为后一个命令的输入</li>
</ul>
</li>
<li>tee<ul>
<li><code>man tee</code>一个输入两个输出</li>
</ul>
</li>
</ul>
<h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><code>VARNAME=VALUE</code></p>
<ul>
<li>引用：<code>$VAENAME</code> or <code>${VARNAME}</code>，注意<code>$()</code>是引用执行结果，而<code>{}</code>才是引用内容</li>
<li>环境变量：作用域为当前shell或器子进程<ul>
<li>用<code>export</code>导出，<code>export var=value</code></li>
</ul>
</li>
<li>位置变量<ul>
<li><code>$0, $1, ...</code>，所有参数，第一个参数…</li>
<li><code>shift [n]</code>，把第一个变量弹出。因此有很多变量时可以使用shift</li>
</ul>
</li>
<li>特殊变量<ul>
<li><code>$?</code>，上一个命令的<strong>执行状态</strong>返回值，0正确，1~255执行错误</li>
<li><code>$#</code>，参数个数</li>
<li><code>$*</code>，参数列表</li>
<li><code>$@</code>，参数列表</li>
</ul>
</li>
<li>声明<code>declare [OPTION] VAR=VALUE</code><ul>
<li><code>declare -i SUM=0</code>，声明整形变量SUM</li>
<li><code>declare -x A=0</code>，声明export变量A</li>
</ul>
</li>
</ul>
<h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if expression; then</span><br><span class="line">    statement</span><br><span class="line">elif</span><br><span class="line">    statement</span><br><span class="line">else</span><br><span class="line">    statement</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ul>
<li>条件测试的表达式<ul>
<li><code>[ expression ]</code>， <strong>注意</strong> 中扩号两端的空格是必须的</li>
<li><code>[[ expression ]]</code>，两种方法用法相同，但是两个中括号是bash的关键字</li>
<li><code>test expression</code></li>
<li>因为if语句取的是表达式执行状态的结果，所以如果条件判断是命令则不需要中括号，如<code>if test expression; then</code></li>
</ul>
</li>
<li>shell中进行算数运算<ul>
<li><strong>shell把所有的变量都当作字符</strong>，所以要进行算数运算需要额外操作</li>
<li><ol>
<li><code>let</code>，见<code>help let</code>。如<code>let c=$a+$b</code></li>
</ol>
</li>
<li><ol start="2">
<li><code>$[expression]</code>。如<code>c=$[$a+$b]</code></li>
</ol>
</li>
<li><ol start="3">
<li><code>$(())</code>。如<code>c=$(($a+$b))</code></li>
</ol>
</li>
<li><ol start="4">
<li><code>expr expression</code>，表达式中，各操作数和操作符直接要有空格，且要使用命令引用。因为本质是调用<code>expr</code>程序。如<code>c=$(expr $a + $b)</code></li>
</ol>
</li>
</ul>
</li>
<li>退出脚本：<code>exit</code><ul>
<li>如果没有指定退出状态，则返回上一条命令的执行状态</li>
<li>0正确，1～255错误</li>
</ul>
</li>
<li>文件测试<ul>
<li><code>-e FILE</code>，是否存在</li>
<li><code>-f FILE</code>，是否普通文件</li>
<li><code>-d FILE</code>，是否为目录</li>
<li><code>-r/w/x</code>，是否可读写执行</li>
</ul>
</li>
<li>组合测试条件<ul>
<li><code>-a</code>，逻辑与</li>
<li><code>-o</code>，逻辑或</li>
<li><code>!</code>，非</li>
<li>也可以使用<code>[ expression ] || [ expression ]</code></li>
</ul>
</li>
</ul>
<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SWITCH <span class="keyword">in</span></span><br><span class="line">    value1)</span><br><span class="line">        statement</span><br><span class="line">        ...</span><br><span class="line">        ;;</span><br><span class="line">    value2|value3)</span><br><span class="line">        statement</span><br><span class="line">        ...</span><br><span class="line">        ;;</span><br><span class="line">    [0-9])</span><br><span class="line">        statement</span><br><span class="line">        ...</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        statement</span><br><span class="line">        ...</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>


<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>流编辑器(Stream EDitor, sed)。行编辑器。默认将输出到屏幕</p>
<p><code>sed [option] &#39;AddressCommand&#39; file...</code></p>
<ul>
<li>option<ul>
<li><code>-n</code>静默模式，不再显示模式空间中的内容</li>
<li><code>-i</code>修改原文件</li>
<li><code>-r</code>使用扩展正则表达式</li>
</ul>
</li>
<li>Address:<ul>
<li><ol>
<li>Startline,Endline<ul>
<li>$ 表示最后一行</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>/RegExp/</li>
</ol>
</li>
<li><ol start="3">
<li>/pattern1/,/pattern2/<ul>
<li>从被1匹配到的行开始到被2匹配的行结束</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>Startline, +N<ul>
<li>从起始行开始向后N行</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>Command<ul>
<li><code>d</code>删除<ul>
<li>如<code>sed 1,2d</code></li>
</ul>
</li>
<li><code>p</code>显示符合条件行</li>
<li><code>a string</code>在指定行后追加</li>
<li><code>i string</code>在指定行前面加</li>
<li><code>r FILE</code>将指定文件的内容添加都符号条件的行</li>
<li><code>w FILE</code>将地址指定的范围的行保存到指定文件中</li>
<li><code>s/pattern/string/[opt]</code>查找并替换<ul>
<li><code>g</code>全局替换</li>
<li><code>i</code>忽略大小写</li>
<li>分隔符号不一定是<code>/</code>也可是<code>@, #, ~...</code>等</li>
<li><code>%</code>全文查找</li>
</ul>
</li>
<li>引用匹配串<ul>
<li><code>&amp;</code>整个串</li>
<li><code>\1</code>第1组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><ul>
<li><p>SUID：文件运行时，相应进程的属主是程序文件自身的属主，而非启动者</p>
<ul>
<li><code>chmod u+s FILE</code></li>
<li><code>chmod u-s FILE</code></li>
<li>如果FILE本身就有执行权限，则SUID显示为s，否则为S</li>
</ul>
</li>
<li><p>GUID：文件运行时，相应进程的属组是程序文件自身的属组，而非启动者所属的基本组</p>
<ul>
<li><code>chmod g+s FILE</code></li>
<li><code>chmod g-s FILE</code></li>
</ul>
</li>
<li><p>Sticky：在一个公共目录，每个用户都可以创建文件，删除自己的文件，但不能删除别人的文件</p>
<ul>
<li><code>chmod o+t DIR</code></li>
<li><code>chmod o-t DIR</code></li>
</ul>
</li>
<li><p>也可用<code>111</code>，二进制表示</p>
</li>
<li><p>FACL, Filesystem Access Control List</p>
<ul>
<li><code>setfacl OPTION FILE</code><ul>
<li><code>-m</code>，设定<ul>
<li><code>u:UID:perm</code></li>
<li><code>g:GID:perm</code></li>
</ul>
</li>
<li><code>-x</code>，取消设定</li>
</ul>
</li>
<li><code>getfacl FILE</code></li>
</ul>
</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="创建设备节点"><a href="#创建设备节点" class="headerlink" title="创建设备节点"></a>创建设备节点</h3><p><code>mknod</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                         主设备号  次设备号             </span><br><span class="line">crw-rw----+ 1 root video      81,   2   Aug 31 17:04 video2</span><br></pre></td></tr></table></figure>


<h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件系统类型众多，接口可能各异，软件开发不可能要为每种文件系统的不同接口编写代码，那就本末倒置了。所以 <strong>Linux使用VFS(虚拟文件系统)作为翻译官</strong> 以支持众多文件系统。</p>
<p>linux常用的文件系统有ext3、ext4、xfs…</p>
<p>创建文件系统：<code>mkfs</code></p>
<ul>
<li>格式化<ul>
<li>高级格式化：创建文件系统<code>mkfs</code></li>
</ul>
</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>linux使用线性虚拟内存做中介，从虚拟内存映射到物理内存。当物理内存满时，将闲置的程序内存放到交换空间。</p>
<p>查看内存以及交换空间<code>free</code>，默认单位是字节，<code>free -m</code>以兆为单位显示。</p>
<ul>
<li>交换空间扩容<ul>
<li><ol>
<li>新建分区</li>
</ol>
</li>
<li><ol start="2">
<li>创建交换分区文件系统<code>mkswap /path/dev</code></li>
</ol>
</li>
<li><ol start="3">
<li>启用交换空间<code>swapon /path/dev</code>，关闭交换分区<code>swapoff /path/dev</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h3><p><code>man dd</code> conver and copy a file，转换并复制文件。取别于cp，cp是以文件为单位复制，而dd复制的是底层是数据流。cp复制文件需要将文件从文件系统读取到内存，然后再从内存复制到文件系统的其他位置。而dd复制相当于直接复制文件的二进制代码。</p>
<p>dd的好处是可以只复制文件的某一部分。</p>
<ul>
<li><code>dd if=&lt;src&gt; of=&lt;tar&gt;</code><ul>
<li>dd备份<ul>
<li><code>dd if=/dev/sda of=/mnt/usb/mdr.bak bs=512 count=1</code></li>
<li><code>dd if=/mnt/usb/mdr.bak of=/dev/sda bs=512 count=1</code></li>
<li>每次复制512byte，共复制1次</li>
</ul>
</li>
<li>用dd做磁盘镜像<ul>
<li><code>dd if=/path/dev of=/path/xxx.iso bs=1M count=1024</code></li>
<li>还可以用来做磁盘性能测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="fstab文件"><a href="#fstab文件" class="headerlink" title="fstab文件"></a>fstab文件</h3><p>文件系统配置文件<code>/etc/fstab</code>文件系统表。初始化时会自动挂载此文件中定义的每个文件系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要挂载的设备 挂载点 文件系统类型 挂载选项 转储频率 文件系统检测次序</span><br><span class="line">    转储频率 表示多长时间(天)做次备份</span><br><span class="line">    文件系统检测次序 只有根可以为1</span><br></pre></td></tr></table></figure>


<h3 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h3><ul>
<li><code>mount DEVICE MOUNT_POINT</code><ul>
<li><code>-o loop</code>挂载本地回环设备。<strong>如iso镜像</strong></li>
<li><code>-a</code>挂载定义在fstab中的所有文件系统 </li>
</ul>
</li>
</ul>
<p>当<code>umount</code>busy时，可以使用<code>fuser -v /mount/point</code>查看谁在访问。使用<code>fuser -km /mount/point</code>杀死所有进程</p>
<h3 id="文件压缩与归档"><a href="#文件压缩与归档" class="headerlink" title="文件压缩与归档"></a>文件压缩与归档</h3><p>对于文本文件，会发现压缩比非常打，这是因为对文本文件的压缩，是对文本进行标记，以后该文本再次出现时，使用标记代替文本，以达到压缩的目的。算法不同压缩比也可能不同。</p>
<ul>
<li>目流行的压缩格式(工具):xz(zx), bz2(bzip2), gz(gzip)。只能压缩文件，不能压缩目录。默认还会删除原文件。<ul>
<li>gzip<ul>
<li>压缩<code>gzip &lt;FILE&gt;</code><ul>
<li><code>-[1-9]</code>指定压缩比</li>
</ul>
</li>
<li>解压缩<code>gunzip &lt;FILE&gt;</code>或<code>gzip -d &lt;FILE&gt;</code></li>
<li><code>zcat</code>在不解压的情况下查看文本文件的内容</li>
</ul>
</li>
<li>bz2<ul>
<li><code>bzip2</code>压缩，对于大文件比gzip有更大压缩比的工具，格式近似</li>
<li><code>-d</code>解压缩</li>
<li><code>-k</code>压缩保留源文件</li>
<li><code>bunzip2</code>解压</li>
<li><code>bzcat</code></li>
</ul>
</li>
<li>xz<ul>
<li>格式类似<code>man xz</code></li>
</ul>
</li>
<li>zip<ul>
<li><strong>压缩比不大</strong>，但可以压缩目录，格式也独特</li>
<li><code>zip OUT_FILE.ZIP IN_FILE1 ...</code></li>
<li>这种能将多个文件整合在一起就叫<strong>archive(归档)</strong></li>
</ul>
</li>
</ul>
</li>
<li>归档工具，只归档不压缩，体积还会变大<ul>
<li>tar<ul>
<li><code>-c</code>创建归档文件</li>
<li><code>-f</code>FILE` <strong>操作的文件</strong></li>
<li><code>-x</code>展开归档, 一般用<code>-xf</code></li>
<li><code>--xattrs</code>归档时保留其扩展属性信息</li>
<li><code>-t</code>查看归档里有啥</li>
</ul>
</li>
</ul>
</li>
<li>即归档又压缩<ul>
<li>当然可以先使用tar归档，再压缩。但是可以直接一步到位<ul>
<li><code>-zcf</code>归档然后调用gzip压缩</li>
<li><code>-zxf</code>调用gzip解压缩然后展开归档</li>
<li><code>-jcf</code>, <code>-jxf</code>调用bz2</li>
<li><code>-Jcf</code>, <code>-Jxf</code>调用xz</li>
<li>展开时使用的工具可以省略，如<code>-xf</code></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/Major/compuer_organization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/10/Major/compuer_organization/" class="post-title-link" itemprop="url">Computer Organization</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-10T00:00:00+08:00">2019-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-09 19:04:27" itemprop="dateModified" datetime="2020-11-09T19:04:27+08:00">2020-11-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>从纯文本的程序到可执行的编码，以<code>hello.c</code>为例<ul>
<li>预处理：把头文件的内容直接插入程序文本。结果得到另一个c程序，通常以.i结尾</li>
<li>编译：编译器将本文文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序</li>
<li>汇编：汇编器将hello.s翻译成机器指令(编码)，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件hello.o中(一个二进制文件)。</li>
<li>链接：hello程序可能会用到许多函数，如printf。printf函数存在与一个名为printf.o的单独编译的与编译好了的目标文件中，这个文件需要以某种形式合并到我们的hello.o程序中。链接器就负责处理这种合并</li>
</ul>
</li>
</ul>
<ul>
<li>虚拟内存：虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都在单独的使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间</li>
<li>虚拟地址空间的结构：<ul>
<li>程序代码和数据</li>
<li>堆：代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像malloc和free这样的函数时，堆可以在运行时动态伸缩</li>
<li>共享库：大约在地址空间的中间部分是一块用来存放像C标准这样的共享库的代码和数据的区域</li>
<li>栈</li>
<li>内核虚拟内存：地址空间的顶部区域是为内核保留的。不允许任何程序的读写</li>
</ul>
</li>
</ul>
<h2 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h2><h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><h4 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h4><p>考虑两个非负整数x和y，满足$0 \leq x, y&lt;2^w$。每个数都能表示为w为无符号数字。如果计算他们的和，我们就有一个可能的范围$0 \leq x+y \leq 2^{w+1} - 2$，表示这个和可能需要w+1位。对于固定精度的编程语言会发生溢出。</p>
<p>我们为x和y定义运算$+^u_w, 其中0 \leq x, y &lt; 2^w$，该操作是把整数和x+y截断为w位得到的结果。这也可以被视为一种形式的模运算，对于x+y的位级表示，简单的丢弃任何权重大于$2^{w-1}$的位就可以计算出和模$2^w$。如考虑一个4位数字表示$x=12, y=9,x+y=21([10101])$如果丢掉最高位，我们的到[0101]，也就是十进制的5。也就和值21 mod 16 = 6一致。</p>
<blockquote>
<p>定义$+^u_w$:</p>
<p>对于满足$0 \leq x, y &lt; 2^w$的x和y有</p>
<p>$$<br>x+^u_w y =<br>\begin{cases}<br>x+y&amp; ,{x+y&lt;2^w}&amp; 正常\<br>x+y-2^w&amp; ,{2^w \leq x+y &lt; 2^{w+1}}&amp; 溢出<br>\end{cases}<br>$$</p>
</blockquote>
<p>如何判断是否发生了溢出：</p>
<ul>
<li>原理：对在范围$0 \leq x, y \leq UMax_w$中的x和y，令$s = x +^u_w y$。则对计算是，当且仅当s&lt;x(或等价地s&lt;y)时发生溢出</li>
<li>推导：显然$x+y \geq x$，因此如果s没有溢出$s \geq x$。如果s发生溢出，有$s = x+y-2^w$，假设$y &lt; 2^w$，有$y-2^w &lt; 0$，因此$s = x+(y-2^w) &lt; x$</li>
</ul>
<h4 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h4><p>整数乘法指令相当慢，需要多个时钟周期，然而其他的整数运算(如加法、减法、位移)之需要1个时钟周期。因此编译器使用了一项重要的优化：试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
<p>如$x \times 14$，$14=2^3+2^2+2^1$，编译器将乘法重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)，将一个乘法代替为3个移位和2个加法。甚至还可以$14=2^4-2^1$。</p>
<p>到这里，无符号数和补码的结果还是相同的</p>
<h4 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h4><p>在大多数机器上，整数除法要比整数乘法更慢：需要30个或者更多的时钟周期。除以2的幂也可以通过用移位(左移)运算来实现。</p>
<p>无符号和补码数分别使用逻辑移位和算数移位来达到目的：</p>
<ul>
<li>逻辑移位<ul>
<li>移出的空位用0补上</li>
</ul>
</li>
<li>算术移位<ul>
<li>对于无符号型，算术移位等同于逻辑移位</li>
<li>对于有符号型，算数左移等同于逻辑左移，算数右移补的是符号位</li>
</ul>
</li>
</ul>
<blockquote>
<p>定义$\lfloor a \rfloor$为向下舍入，$\lceil a \rceil$为向上舍入。</p>
</blockquote>
<p>对于$x \geq 0$和$y&gt;0$，结果会是$\lfloor x/y \rfloor$，对于$x&lt;0$和$y&gt;0$，结果会是$\lceil x/y \rceil$。也就是说要向下舍入一个正值，而向上舍入一个负值。</p>
<ul>
<li>除以2的幂的无符号数除法<ul>
<li>很简单，就直接右移，产生$\lfloor x/2^k \rfloor$</li>
</ul>
</li>
<li>除以2的幂的补码，正值情况，向下舍入<ul>
<li>也是直接右移，直接右移的结果是向下舍入的</li>
</ul>
</li>
<li>除以2的幂的补码，负值情况，向上舍入<ul>
<li>不能直接右移，因为直接右移导致结果向下舍入，而我们需要向上舍入</li>
<li>执行算数右移前要加上一个适当的偏执量才能使得结果正确舍入</li>
<li>表达式：(x+(1&lt;&lt;k)-1)&gt;&gt;k产生数值$\lceil x/2^k \rceil$</li>
<li>偏置技术利用如下属性：对于整数x和y(y&gt;0)，$\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$。这样就可以通过逻辑移位来的到向上取整的结果了</li>
<li><strong>推导:</strong> $\lceil x/y \rceil=\lfloor (x+y-1)/y \rfloor$，设$x = qy+r$，其中$0 \leq r &lt; y$，得到(x+y-1)/y=q+(r+y-1)，因此$\lfloor (x+y-1)/y \rfloor = q + \lfloor (r+y-1)/y \rfloor$。当r=0时，后面一项等于0，当r&gt;0时，等于1。级通过给x增加一个偏移量y-1,然后再将除法向下舍入，当y整除x时，我们得到q，否则，得到q+1。</li>
</ul>
</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="IEEE浮点数表示"><a href="#IEEE浮点数表示" class="headerlink" title="IEEE浮点数表示"></a>IEEE浮点数表示</h4><p>定点表示法不能很有效地表示非常大的数字。我们希望通过给定x和y的值，来表示形如$x \times 2^y$的数。</p>
<blockquote>
<p>IEEE浮点数标准用$V = (-1)^s \times M \times 2^E$的形式来表示一个数：</p>
<ul>
<li>符号(sign)<ul>
<li>s决定是负数(s=1)还是正数</li>
</ul>
</li>
<li>尾数(significand) M<ul>
<li>M是一个二进制小数，它的取值范围是<code>[1, 2)</code>或<code>[0, 1)</code></li>
<li>有n位小数字段$frac=f_{n-1}…f_0$编码尾数M，但编码出来的值也依赖于阶码字段是否等于0(规格化的和非规格化的)</li>
</ul>
</li>
<li>阶码(exponent) E<ul>
<li>E的作用是对浮点数加权，这个权重是2的E次幂</li>
<li>由k位的阶码字段组成$exp=e_{k-1}…f_0$来编码阶码E</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>以下是两种常见的格式：单精度和双精度<ul>
<li>单精度:s、exp、frac字段分别为1位、k=8位和n=23位，得到一个32位的表示</li>
<li>双精度:s、exp、frac字段分别为1位、k=11位和n=52位，得到一个64位的表示</li>
</ul>
</li>
<li>给定位的表示，根据exp的值，被编码的值可以分成三种不同的情况(最后一种情况有两种变种)<ul>
<li>规格化的<ul>
<li>exp字段既不全为0也不全为1</li>
<li>阶码的值E=e-Bias，e是无符号数，而$Bias=2^{k-1}-1$的偏置值</li>
<li>尾数M=1+f，f是frac字段描述的小数值$0 \leq f &lt; 1$</li>
</ul>
</li>
<li>非规格化的值<ul>
<li>exp字段全为0时</li>
<li>阶码E=1-Bias</li>
<li>尾数M=f</li>
<li>注意和规格化的区别</li>
</ul>
</li>
<li>特殊值<ul>
<li>当exp全为1，frac字段全为0时，得到的值表示无穷</li>
<li>当exp全为1，frac字段不全为0时，得到的值表示NaN(Not a Number)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例：假定用6位格式表示，k=3的阶码位和n=2的尾数位，如下</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>位表示</th>
<th>e</th>
<th>E</th>
<th>$2^E$</th>
<th>f</th>
<th>M</th>
<th>$2^E \times M$</th>
<th>V</th>
<th>十进制</th>
<th>公式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0 0000 000</td>
<td>0</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac08$</td>
<td>$\frac08$</td>
<td>$\frac0{512}$</td>
<td>0</td>
<td>0.0</td>
<td>E=1-Bias</td>
</tr>
<tr>
<td>最小非规格化数</td>
<td>0 0000 001</td>
<td>0</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac18$</td>
<td>$\frac18$</td>
<td>$\frac1{512}$</td>
<td>$\frac1{512}$</td>
<td>0.001953</td>
<td>M=f</td>
</tr>
<tr>
<td></td>
<td>0 0000 010</td>
<td>0</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac28$</td>
<td>$\frac38$</td>
<td>$\frac2{512}$</td>
<td>$\frac1{256}$</td>
<td>0.003906</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>..</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>最大非规格化数</td>
<td>0 0000 111</td>
<td>0</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac78$</td>
<td>$\frac78$</td>
<td>$\frac7{512}$</td>
<td>$\frac7{512}$</td>
<td>0.013672</td>
<td></td>
</tr>
<tr>
<td>——–</td>
<td>——</td>
<td>–</td>
<td>–</td>
<td>—</td>
<td>—-</td>
<td>—-</td>
<td>——</td>
<td>—–</td>
<td>—–</td>
<td></td>
</tr>
<tr>
<td>最小规格化数</td>
<td>0 0001 000</td>
<td>1</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac08$</td>
<td>$\frac88$</td>
<td>$\frac8{512}$</td>
<td>$\frac1{64}$</td>
<td>0.015625</td>
<td>E=e-Bias</td>
</tr>
<tr>
<td></td>
<td>0 0001 001</td>
<td>1</td>
<td>-6</td>
<td>$\frac1{64}$</td>
<td>$\frac18$</td>
<td>$\frac98$</td>
<td>$\frac9{512}$</td>
<td>$\frac9{256}$</td>
<td>0.017578</td>
<td>M=1+f</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>..</td>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>0 1110 110</td>
<td>14</td>
<td>7</td>
<td>128</td>
<td>$\frac68$</td>
<td>$\frac{14}8$</td>
<td>$\frac{1792}8$</td>
<td>224</td>
<td>224</td>
<td></td>
</tr>
<tr>
<td>最大规格化数</td>
<td>0 1110 111</td>
<td>14</td>
<td>7</td>
<td>128</td>
<td>$\frac78$</td>
<td>$\frac{15}8$</td>
<td>$\frac{1920}8$</td>
<td>240</td>
<td>240</td>
<td></td>
</tr>
<tr>
<td>——–</td>
<td>——</td>
<td>–</td>
<td>–</td>
<td>—</td>
<td>—-</td>
<td>—-</td>
<td>——</td>
<td>—–</td>
<td>—–</td>
<td></td>
</tr>
<tr>
<td>无穷大</td>
<td>0 1111 000</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>无穷</td>
<td>-</td>
<td></td>
</tr>
</tbody></table>
<h2 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h2><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><table>
<thead>
<tr>
<th>C声明</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小(字节)</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>一个x86-64的CPU包含一组16个储存64位值的通用目的寄存器。每个寄存器都有特殊的用途，它们的名字就反映了这些用途。</p>
<table>
<thead>
<tr>
<th>64寄存器</th>
<th>32位寄存器</th>
<th>16位寄存器</th>
<th>8位寄存器</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>%rax</td>
<td>%eax</td>
<td>%ax</td>
<td>%ax</td>
<td>返回值</td>
</tr>
<tr>
<td>%rbx</td>
<td>%ebx</td>
<td>%bx</td>
<td>%bl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td>%ecx</td>
<td>%cx</td>
<td>%cl</td>
<td>第4个参数</td>
</tr>
<tr>
<td>%rdx</td>
<td>%edx</td>
<td>%dx</td>
<td>%dl</td>
<td>第3个参数</td>
</tr>
<tr>
<td>%rsi</td>
<td>%esi</td>
<td>%si</td>
<td>%sil</td>
<td>第2个参数</td>
</tr>
<tr>
<td>%rdi</td>
<td>%edi</td>
<td>%di</td>
<td>%dil</td>
<td>第1个参数</td>
</tr>
<tr>
<td>%rbp</td>
<td>%ebp</td>
<td>%bp</td>
<td>%bpl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td>%esp</td>
<td>%sp</td>
<td>%spl</td>
<td>栈指针</td>
</tr>
<tr>
<td>%r8</td>
<td>%r8d</td>
<td>%r8w</td>
<td>%r8b</td>
<td>第5个参数</td>
</tr>
<tr>
<td>%r9</td>
<td>%r9d</td>
<td>%r9w</td>
<td>%r9b</td>
<td>第6个参数</td>
</tr>
<tr>
<td>%r10</td>
<td>%r10d</td>
<td>%r10w</td>
<td>%r10b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>%r11d</td>
<td>%r11w</td>
<td>%r11b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>%r12d</td>
<td>%r12w</td>
<td>%r12b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>%r13d</td>
<td>%r13w</td>
<td>%r13b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>%r14d</td>
<td>%r14w</td>
<td>%r14b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>%r15d</td>
<td>%r15w</td>
<td>%r15b</td>
<td>被调用者保存</td>
</tr>
</tbody></table>
<p>指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>*AX</td>
<td>累加器Accumulator</td>
</tr>
<tr>
<td>*BX</td>
<td>基地址寄存器Base Register</td>
</tr>
<tr>
<td>*CX</td>
<td>计数寄存器Count Register</td>
</tr>
<tr>
<td>*DX</td>
<td>数据寄存器Data Register</td>
</tr>
<tr>
<td>*BP</td>
<td>堆栈基指针Base Pointer</td>
</tr>
<tr>
<td>*SI/*DI</td>
<td>变址寄存器Index Register</td>
</tr>
<tr>
<td>*SP</td>
<td>堆栈顶指针Stack Pointer</td>
</tr>
<tr>
<td>*S</td>
<td>段寄存器Segement Register</td>
</tr>
</tbody></table>
<h2 id="MIPS体系结构"><a href="#MIPS体系结构" class="headerlink" title="MIPS体系结构"></a>MIPS体系结构</h2><p>Microprocessor without Interlocked Piped Stage，流水线不会互锁的处理器。避免不同指令间的相互影响。如x86指令的标志寄存器，前一条指令作出的改动会对后面的产生影响，这MIPS所要避免的。</p>
<ul>
<li>它的主要关注点<ul>
<li>减少指令类型</li>
<li>降低指令复杂度</li>
</ul>
</li>
<li>基本原则是用非常简单的CPU解决非常复杂的系统<ul>
<li>越简单的CPU越快</li>
</ul>
</li>
<li>MIPS特点<ul>
<li>固定指令长度(32bit)<ul>
<li>简化了从存储器取指令</li>
</ul>
</li>
<li>简单的寻址模式<ul>
<li>简化了从存储器取操作数</li>
</ul>
</li>
<li>指令数量少，功能简单<ul>
<li>一条指令之完成一个操作</li>
<li>简化指令的执行过程</li>
</ul>
</li>
<li>只允许Load和Store指令访问存储器</li>
<li>MIPS这些特点让使用MIPS进行编程变得困难</li>
</ul>
</li>
</ul>
<h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><ul>
<li>格式：<code>OPT a, b, c</code><ul>
<li>如<code>add a, b, c</code>将b和c求和，结果存如a中</li>
<li>如此还有<ul>
<li><code>sub a, b, c</code></li>
<li><code>mul a, b, c</code></li>
<li><code>div a, b, c</code></li>
<li><code>and a, b, c</code></li>
<li><code>or a, b, c</code></li>
<li><code>sll a, b, c</code>，左移</li>
<li><code>srl a, b, c</code>，右移</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>指令高度统一，而且操作数都不可是存储器操作数，要使用存储器就必须使用专门的访存指令。</p>
<ul>
<li><code>lw $a, $b</code>, load word，读取寄存器b的字(32bit)，放入a中<ul>
<li>MIPS的寄存器编号用<code>$</code>符进行标记</li>
</ul>
</li>
<li><code>sw $a, $b</code>, store word，将寄存器a的字(32bit)，存到b中</li>
</ul>
<p>MIPS有32个通用寄存器，编号从0到31，可以实用<code>$</code>加编号进行指示，也可使用他们的名称(每个寄存器都另有一个名称，并约定了特定的用途)</p>
<h3 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h3><p>MIPS的指令非常的精简</p>
<ul>
<li>按照功能划分<ul>
<li>运算指令</li>
<li>访存指令</li>
<li>分支指令</li>
</ul>
</li>
<li>从指令的格式划分<ul>
<li>R：Register，寄存器</li>
<li>I：Immediate，立即数</li>
<li>J：Jump，转移</li>
</ul>
</li>
</ul>
<h4 id="R型"><a href="#R型" class="headerlink" title="R型"></a>R型</h4><table>
<thead>
<tr>
<th>R</th>
<th>opcode</th>
<th>rs</th>
<th>rt</th>
<th>rd</th>
<th>shamt</th>
<th>funct</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~21</td>
<td>20~16</td>
<td>15~11</td>
<td>10~6</td>
<td>5~0</td>
</tr>
</tbody></table>
<ul>
<li><p>R型指令的格式</p>
<ul>
<li>opcode域指定指令的类型，对于R型指令均为0</li>
<li>funct来精确指定指令的类型</li>
<li>rs：Source Register，通常指定第一个源操作数所在寄存器编号</li>
<li>rt：Target Register，通常指定第二个源操作数所在寄存器编号</li>
<li>rd：Destination Register，通常指定目的操作数所在寄存器编号</li>
<li>shamt用于指定移位指令进行操作数的位数，对于非移位指令为0</li>
</ul>
</li>
<li><p>通过指令得到编码，如<code>add $8, $9, $10</code></p>
<ul>
<li>查MIPS的指令编码表：对于add，opcode=0, funct=32, shamt=0</li>
<li>分析指令操作数：rd=8, rs=9, rt=10</li>
<li>把对应的值转化为二进制数即可得到编码</li>
</ul>
</li>
</ul>
<h4 id="I型"><a href="#I型" class="headerlink" title="I型"></a>I型</h4><p>如果只用5bit来表示立即数，显然不够用，所以对于I型指令需要新的格式</p>
<table>
<thead>
<tr>
<th>I</th>
<th>opcode</th>
<th>rs</th>
<th>rt</th>
<th>immediate</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>16</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~21</td>
<td>20~16</td>
<td>15~0</td>
</tr>
</tbody></table>
<ul>
<li><p>I型指令的格式</p>
<ul>
<li>opcode域指定指令的类型，没有funct</li>
<li>funct来精确指定指令的类型</li>
<li>rs：Source Register，通常指定第一个源操作数所在寄存器编号</li>
<li>rt：Target Register，通常指定第二个源操作数所在寄存器编号</li>
<li>immediate可以存放16位的立即数</li>
</ul>
</li>
<li><p>通过指令得到编码，如<code>add $21, $22, -50</code></p>
<ul>
<li>opcode=8</li>
<li>rs=22, rt=21, immedaite=-50</li>
</ul>
</li>
</ul>
<h4 id="分支指令-条件指令"><a href="#分支指令-条件指令" class="headerlink" title="分支指令(条件指令)"></a>分支指令(条件指令)</h4><ul>
<li>条件分支<ul>
<li>根据比较结果改变控制流</li>
<li><code>beq</code>(branch if equal)<ul>
<li>opcode=4</li>
</ul>
</li>
<li><code>bne</code>(branch if not equal)<ul>
<li>opcode=5</li>
</ul>
</li>
</ul>
</li>
<li>非条件分支<ul>
<li>无条件地改变控制流</li>
<li><code>j</code>(jump)</li>
</ul>
</li>
</ul>
<p>格式：<code>bep reg1, reg2, L1</code><br>    - 前两个是寄存器操作数，第三个是存储器地址(一个立即数，偏移量)<br>    - 不同于x86指令，没有标志寄存器，在一条语句中完成了比较和转移</p>
<table>
<thead>
<tr>
<th>I</th>
<th>opcode</th>
<th>rs</th>
<th>rt</th>
<th>immediate</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>16</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~21</td>
<td>20~16</td>
<td>15~0</td>
</tr>
</tbody></table>
<ul>
<li>如何发挥16bit的作用？<ul>
<li>以当前的PC为基准，16bit偏移量可以表示$\pm 2^{15}$bytes</li>
<li>由于MIPS指令长度固定为32bit，因此我们可以用16bit的立即数来表示每4个字节为一个单位的地址，这样目标地址范围可以扩大4倍。</li>
<li>16bit偏移量可以表示$\pm 2^{17}$bytes</li>
</ul>
</li>
<li>目标地址计算方法<ul>
<li>分支条件不成立时，PC = PC + 4 = 下一条语句</li>
<li>分支条件成立时，PC = PC + 4  + immediate*4</li>
</ul>
</li>
</ul>
<p>对于非条件分支指令</p>
<table>
<thead>
<tr>
<th>J</th>
<th>opcode</th>
<th>immediate</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>26</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~0</td>
</tr>
</tbody></table>
<ul>
<li>不同于条件分支，需要两个寄存器比较，所以可以表示更大的范围</li>
<li>目标地址计算方法：New PC = {(PC+4)后取最高4位, address, 00}</li>
<li>J型指令的目标地址范围：<code>\pm 2^{28}</code>bytes<ul>
<li>如何到达更远的目标地址？<ul>
<li>两次调用j指令</li>
<li>使用jr指令：<code>jr rs</code>，可把要转移的目标地址放在寄存器中，这样就可以使用32位的目标地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="算数逻辑单元"><a href="#算数逻辑单元" class="headerlink" title="算数逻辑单元"></a>算数逻辑单元</h2><p>通过MIPS指令来做示例</p>
<h3 id="算数运算和逻辑运算"><a href="#算数运算和逻辑运算" class="headerlink" title="算数运算和逻辑运算"></a>算数运算和逻辑运算</h3><p>把编码好的指令，如<code>add r1, r2, r3</code>放入IR寄存器中，根据各个域的数值控制电路向ALU发出信号：输入、输出、运算方法等。</p>
<p>在如对于立即数加法：<code>addi</code>，ALU接受到信号，通过opcode知道要进行立即数加法，把把源寄存器作为输入，把输出放入目标寄存器。</p>
<ul>
<li>立即数是16bit的，但寄存器是32bit的，要能成功相加，需要扩展16bit<ul>
<li>MIPS使用补码，所以这个立即数采用符号扩展，不会改变补码的值</li>
</ul>
</li>
</ul>
<p>对于逻辑运算，与算数运算类似，只是立即数采用0扩展。</p>
<h3 id="门电路的基本原理"><a href="#门电路的基本原理" class="headerlink" title="门电路的基本原理"></a>门电路的基本原理</h3><p>现代集成电路通常使用MOS晶体管</p>
<ul>
<li>N型MOS管<ul>
<li>Source源：电流流入</li>
<li>Drain漏：电流流出</li>
<li>Gate门：控制，高电频导通</li>
</ul>
</li>
<li>P型MOS管<ul>
<li>Source源：电流流入</li>
<li>Drain漏：电流流出</li>
<li>Gate门：控制，低电频导通</li>
</ul>
</li>
<li>用这两种晶体管就构成了互补型的MOS关：CMOS</li>
</ul>
<p>逻辑门由晶体管构成，各种逻辑门的结构这里就不说了</p>
<h3 id="寄存器的原理"><a href="#寄存器的原理" class="headerlink" title="寄存器的原理"></a>寄存器的原理</h3><p>在MIPS结构中，寄存器是由32个位组成，从电路上来说每个bit都是一样的，都是一个 <strong>D触发器</strong>。</p>
<ul>
<li>D触发器<ul>
<li>具有存储信息能力的基本单元</li>
<li>由若干逻辑门构成，有多种实现方式</li>
<li>主要有1个数据输入、1个数据输出和1个时钟输入</li>
<li>在上升沿，采样输入D的值，传送到输出Q，其余时间输出Q的值不变</li>
<li>要求采样信号前后有一段很短的稳定时间</li>
</ul>
</li>
</ul>
<p>用32个D触发器构成MIPS的寄存器，在将寄存器用逻辑门相连，就构成了CPU。</p>
<h3 id="逻辑运算的实现"><a href="#逻辑运算的实现" class="headerlink" title="逻辑运算的实现"></a>逻辑运算的实现</h3><p>ALU中包含很多中运算单元，以与元算单元为例：32位的输入需要32个与逻辑门处理，得到对应的32位输出。ALU包含多个单元，一组输入通过不同的单元，的到多组输出，这时需要一个多选器根据选择信号(opcode)对这些输出进行选择，得到一个32位的输出。</p>
<h3 id="加减法的实现"><a href="#加减法的实现" class="headerlink" title="加减法的实现"></a>加减法的实现</h3><ul>
<li><p>半加器</p>
<ul>
<li>将两个一位二进制数相加</li>
<li>不能将进位位用与加法</li>
</ul>
</li>
<li><p>全加器</p>
<ul>
<li>由两个半加器组成</li>
<li>能将进位位用与加法</li>
</ul>
</li>
<li><p>MIPS对溢出的处理方式</p>
<ul>
<li>将操作数看做有符号数<code>add</code>和<code>addi</code><ul>
<li>发生溢出时会产生异常</li>
</ul>
</li>
<li>将操作数看做无符号数<code>addu</code>和<code>addiu</code><ul>
<li>不处理溢出</li>
</ul>
</li>
</ul>
</li>
<li><p>x86对溢出的处理方式</p>
<ul>
<li>采用溢出标志OF，根据标志寄存器OF来进行相应的操作</li>
</ul>
</li>
</ul>
<p>对于减法运算，减法可以转换成加法，那么就要对一个数进行取反操作</p>
<ul>
<li>补码表示的二进制数取反<ul>
<li>规则：按位取反，末位加一</li>
<li>推导 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x :010101</span><br><span class="line">~x:101010</span><br><span class="line">----------</span><br><span class="line">-1:111111</span><br><span class="line"></span><br><span class="line">x + (~x) &#x3D; -1</span><br><span class="line"></span><br><span class="line">(~x) + 1 &#x3D; -x</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="加法器的优化"><a href="#加法器的优化" class="headerlink" title="加法器的优化"></a>加法器的优化</h3><p>前面将的加法有一个个的全加器串联而成，需要等待进位输入，延迟长。进位像波一样传递，这样的加法器也称为 <strong>行波进位加法器(RCA)</strong> 。</p>
<ul>
<li>超前进位加法器(CLA)<ul>
<li>优点： <ul>
<li>计算延迟时间固定为三级门延迟</li>
</ul>
</li>
<li>缺点：<ul>
<li>进一步扩宽加法器的位数，则电路变得非常复杂</li>
</ul>
</li>
<li>因此通常使用小规模的CLA拼接形成加法器</li>
</ul>
</li>
</ul>
<h2 id="乘法器和除法器"><a href="#乘法器和除法器" class="headerlink" title="乘法器和除法器"></a>乘法器和除法器</h2><p>整数乘法指令相当慢，需要多个时钟周期，然而其他的整数运算(如加法、减法、位移)之需要1个时钟周期。因此编译器使用了一项重要的优化：试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
<p>如$x \times 14$，$14=2^3+2^2+2^1$，编译器将乘法重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)，将一个乘法代替为3个移位和2个加法。甚至还可以$14=2^4-2^1$。</p>
<h3 id="乘法器的实现"><a href="#乘法器的实现" class="headerlink" title="乘法器的实现"></a>乘法器的实现</h3><p>观察下列乘法过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   1000</span><br><span class="line">   1001</span><br><span class="line">   ------</span><br><span class="line">   1000</span><br><span class="line">  0000_   好似乘数左移乘</span><br><span class="line"> 0000__</span><br><span class="line">1000___</span><br></pre></td></tr></table></figure>

<p>一个N位乘法器需要3个寄存器，分别设为被乘数md，乘mr，结果res。由上列过程得到启发，过程如下：</p>
<ul>
<li><p>如果被乘数第一位不为0则乘以乘数</p>
</li>
<li><p>把结果加到res中</p>
</li>
<li><p>乘数右移，被乘数左移</p>
</li>
<li><p>如果执行了N次则乘法结束，否则回到第一步</p>
</li>
<li><p>对N位乘法器进行优化</p>
<ul>
<li><ol>
<li>加法移位并行<ul>
<li>通过控制器，控制移位，在一个时钟周期完成移位操作</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>减少不必要的硬件资源<ul>
<li>md由于左移，储存需要的位数是它原始位宽的两倍<ul>
<li>取消左移</li>
</ul>
</li>
<li>mr右移有效数字每个周期减少1位<ul>
<li>用res的低4为存放，因此可以取消mr</li>
</ul>
</li>
<li>res每个周期增加1位<ul>
<li>增加右移，来代替md的左移，乘积始终放在高4位</li>
</ul>
</li>
<li>加法器参加运输，但实际有效数字自由其位宽的一半<ul>
<li>md和res的高4位进行运算</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="除法的运算过程"><a href="#除法的运算过程" class="headerlink" title="除法的运算过程"></a>除法的运算过程</h3><p>观察除法的运算过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">         0001        结果累加，相当于左移</span><br><span class="line">        0001</span><br><span class="line">       0000</span><br><span class="line">      0000</span><br><span class="line">     0000            0010&lt;0000所以商为0</span><br><span class="line">0010&#x2F;00000111</span><br><span class="line">     0010____        相当于右移</span><br><span class="line">      0010</span><br><span class="line">       0010</span><br><span class="line">        0010</span><br><span class="line">        ----</span><br><span class="line">         0011</span><br><span class="line">         0010</span><br><span class="line">         ----</span><br><span class="line">            1        记录余数</span><br></pre></td></tr></table></figure>

<p>过程如下</p>
<ul>
<li>余数寄存器减去除数，检测最高位判断大小</li>
<li>除数右移</li>
<li>商左移，累加</li>
</ul>
<p>除法器的优化:</p>
<ul>
<li><ol>
<li>硬件资源优化<ul>
<li>除数寄存器实际只用了一半</li>
<li>商寄存器初始的空的，从右到左逐位填满</li>
<li>余数初始是满的，有意义的位从左到右逐位减少</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>性能资源优化</li>
</ol>
</li>
</ul>
<h2 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h2><h3 id="处理器设计的主要步骤"><a href="#处理器设计的主要步骤" class="headerlink" title="处理器设计的主要步骤"></a>处理器设计的主要步骤</h3><ul>
<li><ol>
<li>分析指令系统，得出对数据通路的需求</li>
</ol>
</li>
<li><ol start="2">
<li>为数据通路选择合适的组件</li>
</ol>
</li>
<li><ol start="3">
<li>连接组件建立数据通路</li>
</ol>
</li>
<li><ol start="4">
<li>分析每条指令的实现，以确定控制信号</li>
</ol>
</li>
<li><ol start="5">
<li>集成控制信号，形成完整的控制逻辑，控制器</li>
</ol>
</li>
</ul>
<p>下面以一个简化的MIPS指令系统作为实例，改系统的指令有：</p>
<ul>
<li>无符号加法和和减法<ul>
<li><code>addu rd, rs, rt</code></li>
<li><code>subu rd, rs, rt</code></li>
</ul>
</li>
<li>立即数的逻辑或<ul>
<li><code>ori rt, rs, imm16</code></li>
</ul>
</li>
<li>装载和储存一个字<ul>
<li><code>lw rt, imm16(rs)</code></li>
<li><code>sw rt, imm16(rs)</code></li>
</ul>
</li>
<li>条件分支<ul>
<li><code>bep rs, rt, imm16</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>R</th>
<th>opcode</th>
<th>rs</th>
<th>rt</th>
<th>rd</th>
<th>shamt</th>
<th>funct</th>
</tr>
</thead>
<tbody><tr>
<td>大小(bit)</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>位置</td>
<td>31~26</td>
<td>25~21</td>
<td>20~16</td>
<td>15~11</td>
<td>10~6</td>
<td>5~0</td>
</tr>
</tbody></table>
<ul>
<li><p>指令位域分解</p>
<ul>
<li>R型指令：{op, rs, rt, rd, shamt, funct}</li>
<li>I型指令：{op, rs, rt, imm16}</li>
<li>需求：<ul>
<li>存放指令的存储器</li>
<li>PC:存放地址的32位寄存器</li>
</ul>
</li>
</ul>
</li>
<li><p>通过指令操作分析需求</p>
<ul>
<li>运算指令需求：<ul>
<li>一组存放数据的通用寄存器，这些寄存器称为寄存器堆</li>
<li>同时读取两个寄存器的内容</li>
<li>写入一个寄存器的内容，保存结果</li>
<li>将16位的立即数扩展到32位，供I型指令需要</li>
<li>提供加、减、逻辑或功能的运算器</li>
<li>运算器的操作数可以时寄存器或立即数</li>
</ul>
</li>
<li>访存指令<ul>
<li>存放数据的储存器，可读可写</li>
<li>将16位的立即数扩展到32位，供I型指令需要</li>
</ul>
</li>
<li>分支指令<ul>
<li>比较内容，判断是否相等</li>
<li>PC寄存器支持两种自增方式，加4或加一个立即数</li>
</ul>
</li>
</ul>
</li>
<li><p>整理：</p>
<ul>
<li>算数逻辑单元(ALU)<ul>
<li>支持运算类型</li>
<li>操作数</li>
</ul>
</li>
<li>立即数扩展部件<ul>
<li>支持0扩展、符号扩展</li>
</ul>
</li>
<li>程序计数器(PC)<ul>
<li>支持两种自增方式，加4或加一个立即数</li>
</ul>
</li>
<li>寄存器堆<ul>
<li>支持读操作：rs和rt</li>
<li>支持写操作：rt和rd</li>
</ul>
</li>
<li>存储器<ul>
<li>一个只读指令存储器</li>
<li>一个可读写的数据存储器</li>
</ul>
</li>
</ul>
</li>
<li><p>寄存器堆</p>
<ul>
<li>内部构成<ul>
<li>32个32位的寄存器</li>
</ul>
</li>
<li>数据接口信号<ul>
<li>busA、busB：两组32位的数据输出</li>
<li>busW：一组32位的数据输入</li>
</ul>
</li>
<li>读写控制<ul>
<li>Ra(5bit)：选中对应编号的寄存器，将其内容放到busA</li>
<li>Rb(5bit)：选中对应编号的寄存器，将其内容放到busB</li>
<li>Rw(5bit)：选中对应编号的寄存器，在时钟信号的上升沿，如果写使能信号有效，将busW的内容写入改寄存器</li>
<li>读操作不受时钟信号控制</li>
</ul>
</li>
</ul>
</li>
<li><p>存储器</p>
<ul>
<li>数据接口信号<ul>
<li>Date In：32位的数据输入信号</li>
<li>Data Out：32位的数据输出信号</li>
</ul>
</li>
<li>读写操作<ul>
<li>Address：32位的地址信号。该信号指定一个存储单元，将其内容送到数据输入信号</li>
<li>Write Enable：写使能信号，在时钟上升沿，如果写使能信号有效，将数据输入信号的内容存入地址信号指定的存储单元</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据通路的建立"><a href="#数据通路的建立" class="headerlink" title="数据通路的建立"></a>数据通路的建立</h3><ul>
<li>基本原则<ul>
<li>根据指令需求，连接组件，建立数据通路</li>
</ul>
</li>
<li>指令的需求<ul>
<li>所有指令的共同需求<ul>
<li>取指令，由IFU(Instruction Fetch Unit)完成<ul>
<li>程序计数器(PC)的内容是指令的地址</li>
<li>用PC的内容作为地址，访问指令存储器获得指令编码</li>
</ul>
</li>
<li>更新程序计数器PC<ul>
<li>顺序时PC+=4</li>
<li>分支时PC=目标地址</li>
</ul>
</li>
</ul>
</li>
<li>不同指令的各自需求<ul>
<li>加减法指令的需求</li>
<li>逻辑运算指令的需求</li>
<li>访存指令需求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="运算指令的控制信号"><a href="#运算指令的控制信号" class="headerlink" title="运算指令的控制信号"></a>运算指令的控制信号</h3><p>以加法运算指令为例：</p>
<ul>
<li><ol>
<li>通过IFU取指令</li>
</ol>
</li>
<li><ol start="2">
<li>执行加法<ul>
<li>解析IFU的输出，放入寄存器堆对应的输入中</li>
<li>busB如果是立即数需要扩展<ul>
<li>扩展又有0扩展和符号扩展</li>
</ul>
</li>
<li>对ALU：给ALU信号使其执行加法计算</li>
<li>对数据存储器：如果不需要数据存储器，写使能信号关闭，防止对结果修改</li>
<li>要写入寄存器，所有要把寄存器的写使能信号设为有效</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>更新PC寄存器的内容</li>
</ol>
</li>
</ul>
<p>访存指令、分支指令同理</p>
<h3 id="控制信号的集成"><a href="#控制信号的集成" class="headerlink" title="控制信号的集成"></a>控制信号的集成</h3><p>把之前的控制信号集成起来，形成完整的控制逻辑。</p>
<h2 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h2><h3 id="流水线的基本原理"><a href="#流水线的基本原理" class="headerlink" title="流水线的基本原理"></a>流水线的基本原理</h3><p>执行MIPS指令的主要步骤：</p>
<ul>
<li>取值</li>
<li>译码</li>
<li>执行</li>
<li>访存</li>
<li>回写</li>
</ul>
<p>分工明确好似非常适合使用流水线，每个人专注于自己的工作，每个硬件都有使用。</p>
<p>我们需要将每个部分的输出放入一个流水线寄存器，这样当输出保存在流水线寄存器后，前面的寄存器就可以开始新的工作而不影响后面的工作。下一个硬件又从流水线寄存器中取上一个硬件的输入。</p>
<p>虽然每条指令要经历的时间不变，但是当流水线填满是，每个时钟周期都能产生一条指令，性能提升不少。</p>
<h3 id="流水线的优化"><a href="#流水线的优化" class="headerlink" title="流水线的优化"></a>流水线的优化</h3><p>如果只是简单的按照指令执行的步骤取切分流水线的话不能充分发挥流水线的优势。</p>
<p>时钟周期的大小取决于耗时最长的那个步骤，如果流水线平衡性较差，性能提升幅度下降。</p>
<p>流水线的深度并非越深越好，应用流水线寄存器也会产生时延。越深的流水线说明需要的流水线寄存器越多。单条指令的执行时间越长。</p>
<h3 id="超标量流水线"><a href="#超标量流水线" class="headerlink" title="超标量流水线"></a>超标量流水线</h3><p>除了增加流水线深度来提供速度，还有一种方式就是拓宽流水线，这样的流水线就称为超标量流水线。通常具有两条或以上并行工作的流水线称为超标量结构。也可称为超量。</p>
<h3 id="流水线的”冒险”"><a href="#流水线的”冒险”" class="headerlink" title="流水线的”冒险”"></a>流水线的”冒险”</h3><ul>
<li>“冒险”(Hazard)：阻止下一条指令在下一个时钟周期开始执行的情况<ul>
<li>结构冒险<ul>
<li>所有的硬件部件正在位之前的指令工作</li>
<li>对于只读存储器，一次只能有一个硬件进行读取<ul>
<li>解决方案1：流水线停顿(不同时使用这个硬件)，产生空泡(不会影响状态的值)<ul>
<li>但如果等待后有与另一个硬件冲突则又要停顿，这样效率很低</li>
</ul>
</li>
<li>解决方案2：指令和数据放在不同的存储器中</li>
</ul>
</li>
<li>对于可读写的寄存器，读写同时发生显然不是一个明智的选择<ul>
<li>解决方案：前半个时钟周期写，后半个读，并设置独立的读写口</li>
<li>支持这么做的原因是寄存器的读写速度较快</li>
</ul>
</li>
</ul>
</li>
<li>数据冒险<ul>
<li>需要等待之前的指令完成数据的读写</li>
<li>如果下一条指令需要上一条指令的数据，但是上一条指令可能还没写回<ul>
<li>解决方案1：停顿</li>
</ul>
</li>
</ul>
</li>
<li>控制冒险<ul>
<li>需要根据之前指令的结果决定下一步的行为</li>
<li>类似数据冒险，指令不能确定是否发生分支，需要几个周期后才知道<ul>
<li>解决方案1：停顿</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据冒险的处理"><a href="#数据冒险的处理" class="headerlink" title="数据冒险的处理"></a>数据冒险的处理</h3><ul>
<li>软件解决方案(停顿)：插入nop指令，什么都不干<ul>
<li>插入几条nop指令存在问题，不同的处理器的流水线深度可能不同，导致兼容。因此一般不通过软件层面解决硬件问题</li>
</ul>
</li>
<li>流水线停顿，产生空泡<ul>
<li>这样的空泡由硬件产生</li>
<li>检查数据冒险，如果有则插入空泡</li>
</ul>
</li>
<li>数据前递(或称为旁路)<ul>
<li>如加法运算，即使没有写回，它的运算结果其实已经在流水线寄存器中了，我们只需引用流水线寄存器上的值</li>
<li>但对于load指令数据前递不适用，因为load指令的值较迟产生</li>
</ul>
</li>
</ul>
<h3 id="控制冒险的处理"><a href="#控制冒险的处理" class="headerlink" title="控制冒险的处理"></a>控制冒险的处理</h3><ul>
<li>当执行了转移指令，并确实发生转移时，产生如下的开销，称为”转移开销”<ul>
<li><ol>
<li>将按顺序预取的指令废除(排空流水线)</li>
</ol>
</li>
<li><ol start="2">
<li>从转移目标地址重新取指定</li>
</ol>
</li>
</ul>
</li>
<li>转移开销的构成<ul>
<li>要不要转移，判断条件引起的开销</li>
<li>转移到哪，生成目标地址引起的开销</li>
</ul>
</li>
</ul>
<h2 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h2><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><ul>
<li>冯诺依曼计算机结构：<ul>
<li>运算器CA</li>
<li>控制器CC</li>
<li>存储器M<ul>
<li>层次结构：<ul>
<li>通用寄存器：CPU</li>
<li>高速缓存：SRAM</li>
<li>主存：DRAM</li>
<li>本地二级存储：Disk</li>
<li>越往上越快、容量越小价格越高</li>
</ul>
</li>
</ul>
</li>
<li>输入I</li>
<li>输出O</li>
</ul>
</li>
</ul>
<h3 id="DRAM和SRAM"><a href="#DRAM和SRAM" class="headerlink" title="DRAM和SRAM"></a>DRAM和SRAM</h3><table>
<thead>
<tr>
<th></th>
<th>DRAM</th>
<th>SRAM</th>
</tr>
</thead>
<tbody><tr>
<td>储存单元</td>
<td>电容</td>
<td>双稳态触发器</td>
</tr>
<tr>
<td>集成度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>功耗</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>价格</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>块</td>
</tr>
<tr>
<td>刷新</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="主存-内存-的工作原理"><a href="#主存-内存-的工作原理" class="headerlink" title="主存(内存)的工作原理"></a>主存(内存)的工作原理</h3><p>DRAM芯片以一个存储阵列位核心，通过指定行列地址取出对应的存储单元(4比特或8比特)。一个内存条往往有多个DRAM芯片(4的倍数)，构成一个内存模组。从外部给入行列地址后地址会同时送到每个DRAM芯片，每个DRAM芯片同时选择储存器单元，存储单元同时输出，组成一个64/32位的数。</p>
<p>缓存速度很快，一般放在CPU中。CPU访问内存的过程：SDRAM(同步DRAM)的访存过程为例：</p>
<ul>
<li>CPU通过系统总线连接到内存控制器，内存控制器再通过存储总线连接到内存条<ul>
<li>CPU需要访问控制器时：<ul>
<li>申请系统总线，获得总线控制权后把地址发到控制器中</li>
</ul>
</li>
<li>控制器对地址分解形成行地址和列地址，然后向DRAM发起访存操作<ul>
<li><ol>
<li>预充电</li>
</ol>
</li>
<li><ol start="2">
<li>行访问:DRAM中的行译码芯片，选出对应行，所有单元的信号放大后放在一个缓冲区</li>
</ol>
</li>
<li><ol start="3">
<li>缓冲区信号稳定后，才能发出列地址，其中tRCD是冲行选到列选的延迟</li>
</ol>
</li>
<li><ol start="4">
<li>列译码器接受到列地址后，从缓冲区读出对应的列，放到数据接受接口。其中从发出列地址到选出对应存储单元的数的过程称为列访问，这段时间称为CL</li>
</ol>
</li>
</ul>
</li>
<li>内存送出数据后，控制器采样并送到CPU<ul>
<li>如果CPU的下次请求是同一行，则控制器不再发送行地址，而是直接发送列地址</li>
<li>如果下次访问不是同一行则需把缓冲区的行关闭，这个过程就叫做 <strong>预充电</strong> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="主存技术的发展"><a href="#主存技术的发展" class="headerlink" title="主存技术的发展"></a>主存技术的发展</h3><ul>
<li>DDR:Double Data Rate<ul>
<li>时钟的上升沿和下降沿都传输</li>
</ul>
</li>
<li>SDR:Single Data Rate<ul>
<li>只在时钟的上升沿传输</li>
</ul>
</li>
</ul>
<p>building</p>
<h3 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h3><p>$$Cpu \leftrightarrow Cache \leftrightarrow Main Memory$$</p>
<ul>
<li>程序的局部性原理:计算机程序从空间和时间都表现出局部性<ul>
<li>时间局部性<ul>
<li>最近被访问的存储器单元(指令或数据)很快会被访问</li>
</ul>
</li>
<li>空间局部性<ul>
<li>正在被访问的存储器单元附近的单元很快会被访问到</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        sum+=a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i很快会(频繁)被访问</span></span><br><span class="line"><span class="comment">// a数组附件的单元很快会被访问</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>cache的基本原理</p>
<ul>
<li>cache对空间局部性的利用<ul>
<li>从主存中取回待访问数据时，会同时取回与位置相邻的主存单元的数据</li>
<li>以数据块(Block)为单位和主存进行数据交换</li>
</ul>
</li>
<li>cache对时间局部性的利用<ul>
<li>保存近期频繁被访问的主存单元的数据</li>
</ul>
</li>
<li>这样如果cache中有数据(cache命中)则从cache中获取</li>
</ul>
</li>
<li><p>cache的写策略</p>
<ul>
<li>cache命中时的写策略<ul>
<li>写穿透：数据同时写入cache和主存</li>
<li>写返回：数据只写入cache，仅当改数据块被替换时才写入主存</li>
</ul>
</li>
<li>cache失效时的写策略<ul>
<li>写不分配：直接写入主存</li>
<li>写分配：将该数据所在的块读入cache后，在将数据写入cache，利用局部性原理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="高速缓存的设计要点"><a href="#高速缓存的设计要点" class="headerlink" title="高速缓存的设计要点"></a>高速缓存的设计要点</h3><ul>
<li>平均访存时间(Average Memory Access Time)=Hit Time + Miss Penalty x Miss Rate<ul>
<li>Hit Time：命中时间，从cache将命中数据返回的时间</li>
<li>Miss Penalty：失效代价，从主存读取数据并返回的时间</li>
<li>Miss Rate：失效率，未命中的概率</li>
<li>降低访存时间主要就是降低这3个参数</li>
</ul>
</li>
<li>cache失效的原因<ul>
<li>义务失效：第一次访问<ul>
<li>无法避免</li>
</ul>
</li>
<li>容量失效：无法保存程序所需的所有数据块<ul>
<li>可增加cache容量缓解，但会增加命中时间</li>
</ul>
</li>
<li>冲突失效：多个存储器位置映射到同一个cache位置<ul>
<li>需要精心设计映射策略</li>
</ul>
</li>
</ul>
</li>
<li>映射策略<ul>
<li>直接映射</li>
<li>多路组相联(相当于用几个表来保存，但是表越多就要用越复杂的电路判断是否在其中一个表中)</li>
<li>常见的cache替换算法<ul>
<li>随机</li>
<li>轮换</li>
<li>最近最少使用(LRU)：效果最好但设计复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存储器容量的计算"><a href="#存储器容量的计算" class="headerlink" title="存储器容量的计算"></a>存储器容量的计算</h3><table>
<thead>
<tr>
<th>&lt;++&gt;</th>
<th>&lt;++&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>Ki:kibi</td>
<td>$1024^1$</td>
</tr>
<tr>
<td>Mi:mebi</td>
<td>$1024^2$</td>
</tr>
<tr>
<td>..</td>
<td>..</td>
</tr>
</tbody></table>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="中断向量表的结构"><a href="#中断向量表的结构" class="headerlink" title="中断向量表的结构"></a>中断向量表的结构</h3><p>不同的中断产生不同的中断码，根据中断向量表查询得到对应的处理方法。</p>
<ul>
<li>中断向量：中断服务程序的入口地址</li>
<li>中断向量表存放在固定的地址</li>
<li>处理方法会事先存放在中断向量对应的地址处</li>
</ul>
<h3 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h3><ul>
<li><ol>
<li>关中断<ul>
<li>CPU关闭中断响应，不再接受其他外部中断请求</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>保存断点<ul>
<li>将发送中断处理的指令压入堆栈，处理完后正确返回</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>识别中断源<ul>
<li>确定中断类型号，从而找到相应的中断处理程序的入口地址</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>保存现场<ul>
<li>保存正在处理的程序</li>
</ul>
</li>
</ol>
</li>
<li><ol start="5">
<li>执行中断服务程序<ul>
<li>转到中断服务程序入口开始执行，可在适当的时刻重新开放中断，以便允许相应较高优先级的外部中断</li>
<li>重新开放由标识寄存器控制</li>
</ul>
</li>
</ol>
</li>
<li><ol start="6">
<li>恢复现场(8086为例)<ul>
<li>IRET指令(中断返回)，从栈顶弹出3个字分别送入IP、CS和FLAGS寄存器</li>
<li>放在中断服务程序的末尾</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="基于中断的功能调用"><a href="#基于中断的功能调用" class="headerlink" title="基于中断的功能调用"></a>基于中断的功能调用</h3><ul>
<li>指令<code>int N</code><ul>
<li>调用n号中断,由运行指令主动触发</li>
</ul>
</li>
</ul>
<h2 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h2><h3 id="输入输出接口的基本功能"><a href="#输入输出接口的基本功能" class="headerlink" title="输入输出接口的基本功能"></a>输入输出接口的基本功能</h3><ul>
<li>I/O接口改的基本功能<ul>
<li>数据缓冲<ul>
<li>解决CPU和外设之间的速度差距</li>
</ul>
</li>
<li>提供联络信息<ul>
<li>协调与同步数据交换过程</li>
</ul>
</li>
<li>信号与信息格式的转换<ul>
<li>模/数、数/模交换，串/并、并/串交换，电平转换</li>
</ul>
</li>
<li>设备选择</li>
<li>中断管理</li>
<li>可编程功能</li>
</ul>
</li>
</ul>
<h3 id="输入输出接口的编址方式"><a href="#输入输出接口的编址方式" class="headerlink" title="输入输出接口的编址方式"></a>输入输出接口的编址方式</h3><ul>
<li>I/O端口和存储器分开编址<ul>
<li>I/O映像的I/O方式，I/O Mapped I/O</li>
<li>x86就是这种方式</li>
<li>I/O指令<ul>
<li>IN指令<ul>
<li><code>IN AC, PORT</code></li>
<li>把外设端口内容输入到AL或AX</li>
</ul>
</li>
<li>OUT指令<ul>
<li><code>OUT PORT, AC</code></li>
<li>把AL或AX的内容输出到外设端口</li>
</ul>
</li>
<li>端口地址小于255时可以用立即数，否则需要寄存器</li>
</ul>
</li>
</ul>
</li>
<li>I/O端口和存储器统一编址<ul>
<li>存储器映像的I/O方式，Memory Mapped I/O</li>
<li>MIPS就是这种方式</li>
<li>优点<ul>
<li>可以用访问存储器的指令访问I/O端口，可以实现直接对I/O端口内的数据进行处理</li>
<li>CPU中的I/O操作与访问存储器的操作统一为一套控制逻辑，简化内部结构，减少PCU引脚的数目</li>
</ul>
</li>
<li>缺点<ul>
<li>I/O端口占用一部分存储器地址空间，使得存储器地址空间减小</li>
<li>由于利用访问存储器的指令来进行IO操作，指令的长度通常比单独IO指令要长，执行时间也较长</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="输入输出的控制方式"><a href="#输入输出的控制方式" class="headerlink" title="输入输出的控制方式"></a>输入输出的控制方式</h3><ul>
<li>IO控制方式的分类<ul>
<li>程序控制方式<ul>
<li>无条件传送方式<ul>
<li>假设外设已经准备号</li>
<li>CPU直接使用指令与外设传送数据</li>
<li>不查询外设的工作状态</li>
</ul>
</li>
<li>程序查询传送方式<ul>
<li>CPU通过指令一段程序，不断查询外设的工作状态<ul>
<li>握手信号，检查输入输出缓冲</li>
</ul>
</li>
<li>在外设准备就绪后草进行数据传送</li>
<li>CPU的不断查询浪费了很多资源</li>
</ul>
</li>
</ul>
</li>
<li>中断控制方式<ul>
<li>通过中断的方式，将数据”一块一块”地传送，当输入输出缓冲达到一定条件时，引发中断，提醒CPU的继续输入或读取等</li>
<li>优点<ul>
<li>CPU可和外设并行工作</li>
<li>外围设备具有申请父亲的主动权</li>
<li>一定程度上满足了IO处理的实时性要求</li>
</ul>
</li>
<li>缺点<ul>
<li>输入输出的数据仍由CPU承担</li>
<li>进入和退出中断增加消耗</li>
</ul>
</li>
</ul>
</li>
<li>直接存储器访问(DMA)方式<ul>
<li>前面的方式的共同确定是数据传输仍由CPU承担，但是如果是显示器，网络等需要大量数据传输的设备就难以应对了</li>
<li>Direct Memory Access(DMA)<ul>
<li>数据传送过程不需要CPU干预(不需要指令程序指令)</li>
<li>由专门的硬件控制电路控制，进行外设与存储器间直接数据传送</li>
<li>该专门硬件控制电路称为DMA控制器，简称DMAC</li>
</ul>
</li>
<li>DMAC的基本工作步骤(以使用独立DMAC进行外设到内存传送为例)<ul>
<li><ol>
<li>CPU设置DMAC内部配置寄存器<ul>
<li>源地址的初始值以及传送是的地址增减方式</li>
<li>目的地址的初始值以及传送是的地址增减方式</li>
<li>待传送数据的长度</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>DMAC处于空闲等待状态</li>
</ol>
</li>
<li><ol start="3">
<li>IO接口向DMAC传送申请</li>
</ol>
</li>
<li><ol start="4">
<li>DMAC响应IO接口的申请</li>
</ol>
</li>
<li><ol start="5">
<li>DMAC向IO接口发起总线读传输</li>
</ol>
</li>
<li><ol start="6">
<li>DMAC向存储器发起总线写传输</li>
</ol>
</li>
<li><ol start="7">
<li>重复5～6直到本次DMA传送完成</li>
</ol>
</li>
<li><ol start="8">
<li>返回2，等待下一次DMA传送申请</li>
</ol>
</li>
</ul>
</li>
<li>通常，DMA传送完成后DMAC会通过中断信号通知CPU</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/universe/c/c_fragments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/04/universe/c/c_fragments/" class="post-title-link" itemprop="url">C语言碎片知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-04T00:00:00+08:00">2019-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-14 10:27:55" itemprop="dateModified" datetime="2021-01-14T10:27:55+08:00">2021-01-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="读取字符串"><a href="#读取字符串" class="headerlink" title="读取字符串"></a>读取字符串</h2><ul>
<li>读取单个字符<ul>
<li><code>getchar()</code>是<code>scanf(&quot;%c&quot;, c)</code>的简化版本，除了更简介无其他优势</li>
<li><code>getche()</code>，没有缓冲区，输入一个字符后立即读取，不等待用户按回车</li>
<li><code>getch()</code>，没有缓冲区，输入一个字符后立即读取，不等待用户按回车，区别于<code>getche</code>它<strong>没有回显</strong> </li>
</ul>
</li>
<li>读取字符串<ul>
<li><code>scanf(&quot;%s&quot;, str)</code>遇到空格后停止接收后面的字符串</li>
<li><code>gets()</code>有缓冲区，可以读取空格，直到回车才会结束</li>
<li><code>scanf(&quot;%[^\n]&quot;,str)</code>，可以读取带空格的字符串，直到回车才结束</li>
</ul>
</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针声明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型(*指针变量名)(参数列表)</span><br><span class="line"><span class="keyword">int</span>(*func_ptr)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp; func; <span class="comment">// &amp;可以省略</span></span><br></pre></td></tr></table></figure>

<p>上面声明了一个指向 <em>返回值为int，有两个int类型参数的函数</em> 的指针<code>func_ptr</code>，接下来就可以通过<code>func_ptr(int, int)</code>调用了</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数指针变量作为某个函数的参数，即别人的函数执行时调用你实现的函数</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static有如下功能</p>
<ul>
<li><ol>
<li>隐藏变量<ul>
<li>对于未加static的全局变量和函数具有全局可见性，可在另一个文件中<code>extern</code>关键字声明使用</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>保持变量内容的持久<ul>
<li>存储在静态数据区的变量会在程序运行时就初始化，且也是唯一一次初始化。全局变量和static变量就是静态数据区的变量</li>
<li>不同于全局变量，static可以控制变量的可见范围，也就是隐藏局部变量，但局部变量从储存是全局的</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>初始化为0<ul>
<li>静态数据区中所有的字节默认都是0x00</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>简单的讲，宏就是把一个缩略语(宏，macro)指定成任何一段文本。预处理时会用定义和文本把这个缩略语替换掉。</p>
<ul>
<li>没有参数的宏<ul>
<li><code>#define 宏名称 文本</code></li>
</ul>
</li>
<li>带参数的宏<ul>
<li><code>#define 宏名称(参数列表) 文本</code></li>
<li><strong>注意</strong> 宏参数的替换也是文本的替换，因此不要吝啬括号  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T(x, y) x*y</span></span><br><span class="line">T(<span class="number">1</span>+<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 结果是1+1*2 = 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T(x, y) (x)*(y) <span class="comment">// 这样才能得到4</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>可选参数的宏<ul>
<li><code>#define 宏名称(参数列表,...) 文本</code><ul>
<li>省略号必须放在参数列表的后面，表示可选参数</li>
</ul>
</li>
<li>可选参数会用<strong>连同分隔他们的逗号</strong>打包在<code>__VA_ARGS__</code>中</li>
</ul>
</li>
<li>字符串化运算符<ul>
<li>形参中使用<code>#</code>可以将宏中的实参转换用双引号<code>&quot;</code>包裹成字符串<ul>
<li>如果实参有双引号<code>&quot;</code>，则每个双引号前面会加反斜杠<code>\</code></li>
<li>同理反斜杠以后自动转意</li>
<li><strong>PS</strong> 编译器会合并紧邻的字符串字面量(<code>&quot;ab&quot;&quot;c&quot; -&gt; &quot;abc&quot;</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>记号粘贴运算符</strong><ul>
<li><code>##</code>，会把左、右操作数组合在一起作为一个记号<ul>
<li><code>#define A(x) a_##x -&gt; A(1) -&gt; a_1</code></li>
<li>出现在<code>##</code>两边的空白符会连同<code>##</code>一起删除</li>
<li>如果得到的结果是宏则预处理器继续进行宏替换，即 <strong>记号粘贴完成后才进行宏展开</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>不同平台提供的api不同，根据平台编译代码是必须的</p>
<p><code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>都是预处理命令，这些操作都是在预处理阶段完成的，多余的代码以及宏都不会参与编译，保证正确性还缩小了体积。</p>
<p><code>#ifdef</code>，意思是如果宏被定义过，<code>#ifndef</code>则是它的非</p>
<p>需要注意的是<code>#if</code>后面跟的是”整型常量表达式”，而<code>#ifdef</code>和<code>#ifndef</code>后面只能跟宏名</p>
<h2 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h2><p>用符号名称代表常数，提高程序可读性。枚举常量是int类型的，因此任何int类型使用的地方都可以用它。定义枚举类型方法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名 &#123;枚举元素<span class="number">1</span>, 枚举元素<span class="number">2</span>,...&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是</strong> 第一个枚举元素默认为0，后续元素在前一个元素上加1。</p>
<p>可以在声明时指定枚举元素的值，没指定值的元素会在前一个元素的值上加1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> H &#123;A, B=<span class="number">3</span>, C, D=<span class="number">7</span>, E&#125;;</span><br><span class="line"><span class="comment">// A=0, B=3, C=4, D=7, E=8</span></span><br></pre></td></tr></table></figure>

<h3 id="定义枚举变量"><a href="#定义枚举变量" class="headerlink" title="定义枚举变量"></a>定义枚举变量</h3><p>枚举变量是值可以用枚举类型中定义的名称赋值(当然也可以用任意int或unsigned int赋值，但这么做就失去了可读性)，如<code>enum day = MON</code>。定义枚举变量有三种方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义枚举类型再定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">    MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">enum</span> DAY day;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定义枚举类型同时定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">    MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略枚举类型名，直接定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> </span><br><span class="line">&#123;</span><br><span class="line">    MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>


<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><ul>
<li>向后跳转</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..       |</span><br><span class="line">..       |</span><br><span class="line">label:  &lt;</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure>

<ul>
<li>向前跳转</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">label:         &lt;-|</span><br><span class="line">    statement    |</span><br><span class="line">..               |</span><br><span class="line">..               |</span><br><span class="line"><span class="keyword">goto</span> label;     -</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure>


<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offsize)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要用途<ul>
<li>将普通文件映射到内存，这样频繁读写时就可直接在内存读写，提高性能</li>
<li>为关联的进程提供共享内存空间</li>
<li>为无关联的进程提供共享内存空间</li>
</ul>
</li>
<li>参数说明<ul>
<li>start：指向内存起始地址，为NULL则让系统自动选定，映射成功返回该地址</li>
<li>length：文件中多大的部分映射到内存</li>
<li>prot：映射区域的保护方式，可以是以下几种方式的组合：<ul>
<li><code>PROT_EXEC</code>，映射区域可被执行</li>
<li><code>PROT_READ</code>，映射区域可被读取</li>
<li><code>PROT_WRITE</code>，射区域可被写入</li>
<li><code>PROT_NONE</code>，映射区域不能存取</li>
</ul>
</li>
<li>flags：会影响映射区域的各种特性<ul>
<li>在调用mmap()时必须要指定<code>MAP_SHARED</code> 或<code>MAP_PRIVATE</code></li>
<li><code>MAP_FIXED</code>，如果参数 start 所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。</li>
<li><code>MAP_SHARED</code>，对应射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</li>
<li><code>MAP_PRIVATE</code>，对应射区域的写入操作会产生一个映射文件的复制，即私人的”写入时复制”对此区域作的任何修改都不会写回原来的文件内容。</li>
<li><code>MAP_ANONYMOUS</code>，建立匿名映射，此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</li>
<li><code>MAP_DENYWRITE</code>，只允许对应射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</li>
<li><code>MAP_LOCKED</code>，将映射区域锁定住，这表示该区域不会被置换(swap)。</li>
</ul>
</li>
<li>fd：<code>open()</code>返回的文件描述符，代表欲映射到内存的文件</li>
<li>offset：文件映射的偏移量，0表示从最前方开始，offset必须是分页大小的整数倍</li>
<li>返回值：若映射成功则返回映射区内存的起始地址，否则返回<code>MAP_FAILED</code>(-1)</li>
</ul>
</li>
<li>解除内存映射<ul>
<li><code>int munmap(void *start, size_t length)</code></li>
<li>取消从<code>start</code>起<code>length</code>大小的内存映射</li>
<li>关闭文件描述符不会自动解除映射</li>
</ul>
</li>
<li>错误代码<ul>
<li><code>EBADF</code>，参数fd 不是有效的文件描述词</li>
<li><code>EACCES</code>，存取权限有误。如果是<code>MAP_PRIVATE</code>情况下文件必须可读，使用<code>MAP_SHARED</code>则要有<code>PROT_WRITE</code>以及该文件要能写入。</li>
<li><code>EINVAL</code>，参数start、length 或offset有一个不合法。</li>
<li><code>EAGAIN</code>，文件被锁住，或是有太多内存被锁住。</li>
<li><code>ENOMEM</code>，内存不足。</li>
</ul>
</li>
</ul>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>linux下<code>sleep()</code>函数在<code>#include&lt;unistd.h&gt;</code>中</li>
<li>windows下<code>sleep()</code>函数在<code>#include&lt;windows.h&gt;</code>中</li>
<li>跨平台  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>需要<strong>注意</strong>的是<code>printf()</code>是一个<strong>行缓冲函数</strong>，先写到缓冲区，满足一定条件后才，才刷新。刷新缓冲区的条件如下：</p>
<ul>
<li>缓冲区填满</li>
<li>写入字符有<code>\n</code>，<code>\r</code></li>
<li>调用<code>fflush</code>手动刷新时</li>
<li>调用<code>scanf</code>需要从缓冲区读取数据时</li>
</ul>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><h4 id="execv"><a href="#execv" class="headerlink" title="execv"></a>execv</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>以新进程(filename)替换当前进程，pid不变。如果正常执行，<code>execv</code>永远不会返回</p>
<ul>
<li>filename：二进制可执行程序</li>
<li>arg：传入被执行程序的参数序列</li>
</ul>
<p>execve同理，可以携带环境变量参数序列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>filename：二进制可执行程序</li>
<li>arg：传入被执行程序的参数序列</li>
<li>envp：环境变量序列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">char</span> **args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[]=&#123;<span class="string">"python"</span>,<span class="string">"./test.py"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *envp[]=&#123;<span class="number">0</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(<span class="string">"/usr/bin/env"</span>,argv,envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/Major/algorithm/arithmetic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/26/Major/algorithm/arithmetic/" class="post-title-link" itemprop="url">算法学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-26T00:00:00+08:00">2019-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-01 17:17:15" itemprop="dateModified" datetime="2021-01-01T17:17:15+08:00">2021-01-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>比较大小,如果符合条件(升序)就交换两个元素的位置  <ul>
<li>每次执行N-1次</li>
<li>严格大/小,保证了原序(稳定性)</li>
<li>没次能保证最大/最小的元素会在最后</li>
</ul>
</li>
<li>如果全程无交换,则说明有序了,跳出即可</li>
<li>$T=O(x),x\in(N,N^2)$</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>每次无序列首抽取一个元素,然后从有序列末尾开始进行比较(省空间)</li>
<li>查找插入位置，若符合条件,往后移位</li>
<li>然后插入元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|----------------------|</span><br><span class="line">|有序    |R| 无序      |</span><br><span class="line">|----------------------|</span><br><span class="line"></span><br><span class="line">将待插元素R 插入有序列中</span><br><span class="line">有序列后移</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从小到大序列</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    ar[<span class="number">0</span>] = ar[i];   <span class="comment">// 哨兵：保存待插入元素R</span></span><br><span class="line">    <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;ar[<span class="number">0</span>]&lt;ar[j];j--)&#123;  <span class="comment">// 有序列后移腾空间</span></span><br><span class="line">        ar[j+<span class="number">1</span>] = ar[j];</span><br><span class="line">    &#125;</span><br><span class="line">    ar[j+<span class="number">1</span>] = ar[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong> ：用二分法查找待插入元素的位置</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>对插入排序的改进,每次消除多个逆序对以达到加速的效果  </p>
<ul>
<li>按照一定增量序列,每次进行D排序 $D_N &gt; D_{N-1}…&gt;D_1$ ,这样一来一趟就有可能消除多个逆序对<ul>
<li>按照$D_N &gt; D_{N-1}…&gt;D_1$进行排序,后一次会保持前一次的顺序,故可用</li>
<li>但最终都要进行1排序</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(D=N/<span class="number">2</span>;D&gt;<span class="number">0</span>;D/=<span class="number">2</span>)&#123;  <span class="comment">// 希尔增量序列。Hibbard增量序列:Dk=2^k-1...等等</span></span><br><span class="line">    <span class="keyword">for</span>(p=D;p&lt;N;p++)&#123;  <span class="comment">// 插入排序</span></span><br><span class="line">        Tmp = A[p];</span><br><span class="line">        <span class="keyword">for</span>(i=p;i&gt;=D&amp;&amp;A[i-D]&gt;Tmp;i-=D)&#123;</span><br><span class="line">            A[i] = A[i-D];</span><br><span class="line">        &#125;</span><br><span class="line">        A[i] = Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>heap本质是一段连续的地址空间，堆排序则在连续空间的基础上加入完全二叉树的结构。即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rn &lt; R2n</span><br><span class="line">Rn &lt; R2n+1</span><br><span class="line">或</span><br><span class="line">Rn &gt; R2n</span><br><span class="line">Rn &gt; R2n+1</span><br></pre></td></tr></table></figure>

<p>即子节点比父节点小/大的二叉树叫做小/大顶堆，有时也称为最小堆/最大堆。</p>
<p>每次需要最大/小值时，将堆顶和堆尾(即地址为0和地址末尾)的元素交换，那么最大/小元素就在堆尾，取出，然后调整剩下部分再次满足小/大顶堆。交换后从末尾取出原因是可以不破坏原始树的结构，即仍然可以通过<code>2n 2n+1</code>等访问子节点</p>
<p>堆排序的主要问题有两个，一是<strong>初始化构建</strong>，二是取出后<strong>调整</strong>。</p>
<h4 id="调整方法"><a href="#调整方法" class="headerlink" title="调整方法"></a>调整方法</h4><p>调整也是一个上浮下沉的过程，以大顶堆为例，取出最大值后，较小值换到了根节点，使得大顶堆结构破坏。</p>
<ul>
<li><ol>
<li>从导致结构破坏的根节点出发</li>
</ol>
</li>
<li><ol start="2">
<li>选取其孩子中的最大值，与根节点交换</li>
</ol>
</li>
<li><ol start="3">
<li>此时导致结构破坏的根节点来到了子树，又以子树开始重复步骤1</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将堆s到m范围内调整成大顶堆</span></span><br><span class="line">    RedType rc;</span><br><span class="line">    rc = H.r[s];   <span class="comment">// 寄存起来减少写入次数，H类是r用来储存堆</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s; j&lt;=m; j*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m &amp;&amp; H.r[j].key&lt;H.r[j+<span class="number">1</span>].key) j++; <span class="comment">// j为key较大的下标</span></span><br><span class="line">        <span class="keyword">if</span>(rc.key &gt;= H.r[j].key) <span class="keyword">break</span>;  <span class="comment">// 如果已经根节点已经较大，符合最大堆，则跳出</span></span><br><span class="line">        H.r[s] = H.r[j];</span><br><span class="line">        s = j;  <span class="comment">// 从子树再次开始调整</span></span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s] = rc;  <span class="comment">// rc应插入在位置s上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="初始化构建方法"><a href="#初始化构建方法" class="headerlink" title="初始化构建方法"></a>初始化构建方法</h4><ul>
<li>法一：利用上面的调整函数，有(大顶堆为例)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(HeapType &amp;H)</span></span>&#123;</span><br><span class="line">    RedType temp;</span><br><span class="line">    <span class="keyword">for</span>(i=H.length/<span class="number">2</span>; i&gt;<span class="number">0</span>; --i)&#123;    <span class="comment">// 从底(叶子节点的父节点)向上，把1到H.length范围构建成大顶堆</span></span><br><span class="line">        HeapAdjust(H, i, H.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (UNUSED  TODO看书)</span></span><br><span class="line">    <span class="comment">// for(i=H.length; i&gt;1; --i)&#123;</span></span><br><span class="line">    <span class="comment">//     temp = H.r[i];</span></span><br><span class="line">    <span class="comment">//     H.r[i] = H.r[1];</span></span><br><span class="line">    <span class="comment">//     H.r[1] = temp;</span></span><br><span class="line">    <span class="comment">//     HeapAdjust(H, 1, i-1);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>法二：上浮下沉法(小顶堆为例)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第一个非叶子节点开始，以它为子树，先自下而上把小的节点上浮，到达子树根节点后自上而下把大的节点下沉</span></span><br><span class="line"><span class="comment">// 知道根节点结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> *heap,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=len/<span class="number">2</span><span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = j;</span><br><span class="line">        <span class="keyword">while</span>((t+<span class="number">1</span>)*<span class="number">2</span>&lt;=len)&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = (t+<span class="number">1</span>)*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span>+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">                <span class="keyword">if</span>(heap[<span class="built_in">min</span>+<span class="number">1</span>]&lt;heap[<span class="built_in">min</span>])&#123;</span><br><span class="line">                    <span class="built_in">min</span>++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(heap[<span class="built_in">min</span>]&lt;heap[t])&#123;</span><br><span class="line">                swop(<span class="built_in">min</span>,t,heap);</span><br><span class="line">                t = <span class="built_in">min</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>法三：插入法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从根节点出发，若父节点比插入元素大，则调整位置，如此循环，保证父节点小于子节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> *heap,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-1000</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=i;heap[j/<span class="number">2</span>]&gt;temp;j/=<span class="number">2</span>)&#123;</span><br><span class="line">            heap[j] = heap[j/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="利用小-大顶堆排序"><a href="#利用小-大顶堆排序" class="headerlink" title="利用小/大顶堆排序"></a>利用小/大顶堆排序</h4><ul>
<li>根据小/大顶堆的性质，可以确定顶部一定是最大或最小的元素</li>
<li>交换根节点和最后一个节点，那么最后一个节点一定是最大/最小</li>
<li>把最后的节点排除，剩下节点构成的子树再调整成小/大顶堆，重复以上步骤</li>
</ul>
<h3 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h3><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列    </p>
<ul>
<li>先从数列中取出一个数作为主元<ul>
<li>主元选不好会影响速度</li>
<li>法1.选头,中,尾三个数的中位数做主元</li>
</ul>
</li>
<li>分区过程，交替移动，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边</li>
<li>再对左右区间重复第二步，直到各区间只有一个数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> *ar,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = ar[l];   <span class="comment">/* 做寄存，减少写入读出的次数 */</span></span><br><span class="line">    <span class="keyword">int</span> left = l,right = r;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;ar[r]&gt;num)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            ar[l] = ar[r];</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;ar[l]&lt;=num)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            ar[r] = ar[l];</span><br><span class="line">        &#125;</span><br><span class="line">        ar[l] = num;</span><br><span class="line">        quicksort(ar,left,l<span class="number">-1</span>);</span><br><span class="line">        quicksort(ar,l+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 若选取的比较位是序列的首位或尾位，则当序列有序时使用快速排序，时间复杂度退化为$O(n^2)$。 <strong>优化</strong> :取首位、中位、尾位的中位数作为比较位。</p>
<h3 id="擂台法"><a href="#擂台法" class="headerlink" title="擂台法"></a>擂台法</h3><ul>
<li>适用于找最值</li>
</ul>
<h3 id="归并法"><a href="#归并法" class="headerlink" title="归并法"></a>归并法</h3><ul>
<li>把两个有序的序列合并</li>
<li>法1.递归的进行下去(有点类似快速排序)</li>
<li>法2.每个元素看成一段序列,合并合并…</li>
<li>$T=N\log{N}$</li>
<li>缺点:需要开额外一份空间</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="AOV-activity-on-vertex"><a href="#AOV-activity-on-vertex" class="headerlink" title="AOV(activity on vertex)"></a>AOV(activity on vertex)</h3><p>节点代表事件，若v到w连通,则v一定在w的前面  </p>
<ul>
<li>有向图</li>
<li>有优先级限制</li>
</ul>
<p>按照此法输出就是拓扑排序  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Queuezero Q;   <span class="comment">// 储存入度为零的,即前头没有限制了的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;|V|;i++)&#123;    <span class="comment">// 记录最先的入度为0的节点</span></span><br><span class="line">    <span class="keyword">if</span>(indegree[V]==<span class="number">0</span>)&#123;</span><br><span class="line">        Enqueue(V,Q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">    V = Dequeue(Q);  <span class="comment">//cnt++,记录或者输出什么的(拓扑排序)</span></span><br><span class="line">    <span class="keyword">for</span>(V的每个邻接点W)&#123;</span><br><span class="line">        indegree(W)--;</span><br><span class="line">        <span class="keyword">if</span>(degree(w)==<span class="number">0</span>)&#123;</span><br><span class="line">            Enqueue(W,Q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt!=|V|)</span><br><span class="line">    图有回路,无法拓扑排序</span><br></pre></td></tr></table></figure>


<h3 id="AOE-activity-on-edge"><a href="#AOE-activity-on-edge" class="headerlink" title="AOE(activity on edge)"></a>AOE(activity on edge)</h3><p>用边表示活动的带权无环网络；顶点表示事件，<strong>它之前的活动已经完成，它之后的活动才能开始</strong>。</p>
<ul>
<li>应用<ul>
<li>解决关键路径问题</li>
<li>推算工程需要的时间</li>
</ul>
</li>
</ul>
<h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><p>完成工程所需的时间取决于开始到结束的最长路径。因此要节省时间就要减小最长路径，这个最长路径就是 <strong>关键路径</strong> ，关键路径上的活动就是 <strong>关键活动</strong>。</p>
<ul>
<li>事件Vj的最早发生时间Ve(j)<ul>
<li>顶点表示事件，V0到Vj的最长路径</li>
</ul>
</li>
<li>事件Vj的最迟发生时间Vl(j)<ul>
<li>保证终点在最早发生时间完成的前提下，表示能拖延多久</li>
<li>即从终止时间-终点倒推到j点的最长路径(时间)</li>
</ul>
</li>
<li>活动Ai最早开始时间e(i)<ul>
<li>边表示获得，即边起点最早开始时间Ve(j)</li>
</ul>
</li>
<li>活动Ai最晚开始时间l(i)<ul>
<li>在不引起延误的前提下，最迟开始时间</li>
<li>即边的权值(活动持续时间dur)因此可以变动</li>
<li>l(i) = Vl(k)-dur</li>
</ul>
</li>
<li>时间余量<ul>
<li>l(i)-e(i)</li>
</ul>
</li>
</ul>
<p>求解关键路径问题的步骤</p>
<ul>
<li><ol>
<li>从起点开始找最早开始时间Ve(j)</li>
</ol>
</li>
<li><ol start="2">
<li>从终点倒推，求最晚开始时间Vl(j)</li>
</ol>
</li>
<li><ol start="3">
<li>此时得到活动的两点(即边的两点)，找出e(i)==l(i)，即时间余量为0的活动即为关键活动</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    2    3    1</span><br><span class="line"> a -- b -- d -- f</span><br><span class="line">       \1      &#x2F;1</span><br><span class="line">        c -- e</span><br><span class="line">           1</span><br><span class="line"></span><br><span class="line">| event | a | b | c | d | e | f |</span><br><span class="line">|-------|---|---|---|---|---|---|</span><br><span class="line">| Ve    | 0 | 2 | 3 | 5 | 4 | 6 |</span><br><span class="line">| Vl    | 0 | 2 | 4 | 5 | 5 | 6 |</span><br></pre></td></tr></table></figure>


<h3 id="表排序"><a href="#表排序" class="headerlink" title="表排序"></a>表排序</h3><p>当移动的成本很高时(如移动一部电影)就用表来储存他的顺序</p>
<ul>
<li>table[N]指向N,故用table[N]进行访问\排序</li>
</ul>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>基本原理:假如有10个数分别是0<del>9让你排序,那建立10个桶ar[10],根据情况0</del>9放到对应的桶了,最后顺序输出桶就是有序的了</p>
<h4 id="LSD-Least-Significant-Digit-次位优先"><a href="#LSD-Least-Significant-Digit-次位优先" class="headerlink" title="LSD(Least Significant Digit)次位优先"></a>LSD(Least Significant Digit)次位优先</h4><p>排10个在0~999的整数难道要建1000个桶吗？</p>
<ul>
<li>根据低位到高位建通(实际情况肯更抽象)<ul>
<li>这里是从个位到百位,没位置建10桶</li>
<li>个位桶建装好后再遍历桶,装十位的桶,以此类推</li>
<li>因为是遍历有序桶来填入新桶的,所以最后的桶只需按顺序输出就是有序了</li>
</ul>
</li>
</ul>
<h2 id="BFPRT算法：求无序数组低k小-大的数"><a href="#BFPRT算法：求无序数组低k小-大的数" class="headerlink" title="BFPRT算法：求无序数组低k小/大的数"></a>BFPRT算法：求无序数组低k小/大的数</h2><p>思路类似于partition快速排序，下标就能说明范围是第几，小于放左边大于放右边，然后范围只需要关注左边或者右边。</p>
<p>但是如果是简单的基于快速排序，随机选一个划分值，复杂度的变数就比较大，即如果每次选中的划分值都是最小或最大，那么剩下还得关注len-1的数。效率不高。</p>
<ul>
<li><code>bfprt(vector&lt;int&gt; arr, int kf)</code><ul>
<li><ol>
<li>整个数组先分组<ul>
<li>BFPRT发明者是5个人，所以一般5个一组，不足5个就是单独一组</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>每个小组中排序</li>
</ol>
</li>
<li><ol start="3">
<li>取出每个组的中位数，构成一个新的组，偶数个就取上中数或下中数，得到一个N/5长度的新数组</li>
</ol>
</li>
<li><ol start="4">
<li>递归调用<code>num = bfprt(arr, k)</code>拿到中位数，把上面得到的数组和<code>new_arr.size()/2</code>传入</li>
</ol>
</li>
<li><ol start="5">
<li>用上一步拿到的中位数进行划分</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h3 id="散列-hash-查找"><a href="#散列-hash-查找" class="headerlink" title="散列(hash)查找"></a>散列(hash)查找</h3><p>把关键词看成变量,通过哈希函数运算赋予地址</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>关键词是数字时的常见方法</p>
<ul>
<li>折叠法</li>
<li>平方取中法</li>
<li>数字分析法</li>
<li>除留余数法</li>
</ul>
<p>关键词是字符时的常见方法</p>
<ul>
<li>位移法(变成整数移位&lt;&lt;求余)</li>
</ul>
<p><strong>核心思想就是当一位改变时尽可能多的影响位数,避免浪费</strong></p>
<h4 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h4><p>产生冲突就添加偏移量到别的位置  </p>
<ul>
<li>线性探测<ul>
<li>偏移量是一增量序列: 1.2.3.4…</li>
<li>容易产生聚集</li>
</ul>
</li>
<li>平方探测<ul>
<li>偏移量是一增量序列: 1^2.2^2.3^2.4^2…</li>
<li>容易产生死循环<ul>
<li>定理:散列表长是某个4k+3的素数时,一定能探测整个表</li>
</ul>
</li>
</ul>
</li>
<li>双散列探测<ul>
<li>$d_i = i\times h_2(kay)$</li>
<li>$h_2(key)=p-(key mod p)$ 效果最好</li>
</ul>
</li>
<li>再散列<ul>
<li>装填因子太大是查找效率下降</li>
<li>那就扩大散列表,在把原来的元素搬进去</li>
</ul>
</li>
<li>分离链接法<ul>
<li>有冲突的关键字都放在(同一个关键字的)一个链表中</li>
</ul>
</li>
</ul>
<p><strong>删除时不能直接删除,会影响后续的查找。正确的删除是标记为删除,新的元素来时再替换</strong></p>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><strong>要点：</strong> </p>
<ul>
<li>前缀表next(或者说match)函数的创建</li>
<li>动态规划</li>
</ul>
<p>利用前缀表的原理：对于一个子串(如：ababc)，所有可能的前缀:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">a b</span><br><span class="line">a b a</span><br><span class="line">a b a b</span><br><span class="line">a b a b c</span><br></pre></td></tr></table></figure>

<p>我们需要找出每种可能中最长的、<strong>非本身的</strong>公共前后缀，因为如果前后缀相同的话，当后缀失去匹配时，可从前缀结束的地方开始匹配，而不是从头开始。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a               null    <span class="number">0</span></span><br><span class="line">a b             null    <span class="number">0</span></span><br><span class="line">a b a           a       <span class="number">1</span></span><br><span class="line">a b a b         ab      <span class="number">2</span></span><br><span class="line">a b a b c       null    <span class="number">0</span>  &lt;一般剔除字符串本身,在开头填<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">这些最长公共前后缀的长度就构成了前缀表</span><br><span class="line"> a b a b c</span><br><span class="line"><span class="number">-1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">这样就表示了当，str[j]失去匹配时，从match[j](前缀结束的地方)尝试匹配</span><br></pre></td></tr></table></figure>

<p><strong>前缀表如何创建</strong></p>
<ul>
<li>可将创建一个子串前缀表的问题划分为一系列子问题：<ul>
<li>创建每种前缀的前缀表</li>
<li>为每种前缀构造前缀表又是一个个子串匹配问题：前1为是否匹配(是否有公共后缀)、前2位是否匹配，…，前n位是否</li>
<li>又因为从最短开始尝试，最短的又为次短的做了铺垫。最短串的KMP创建了次短所需的前缀表</li>
</ul>
</li>
</ul>
<p>对于ababc，可以划分为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">长的<span class="number">1</span>,不需要前缀表辅助匹配。得到前缀表：</span><br><span class="line">[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">a b</span><br><span class="line">对于ab，找最长公共前后缀。找前<span class="number">1</span>位(a)时，相当与在串ab中找匹配的子串a，而子串a的前缀表已经由上一步得出，前<span class="number">2</span>位ab是它本身，结束匹配。得</span><br><span class="line">[<span class="number">-1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">a b a</span><br><span class="line">对于aba，找最长公共前后缀。找前<span class="number">1</span>位(a)时，相当与在串aba中找匹配的子串a，而子串a的前缀表已经由上一步得出，前<span class="number">2</span>位同理。得</span><br><span class="line">[<span class="number">-1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">a b a b</span><br><span class="line">a b a b c</span><br></pre></td></tr></table></figure>

<p><strong>next</strong>数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">-1</span>;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">-1</span>||str[i]==str[j])&#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>nextVal</strong>数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">-1</span>;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">-1</span>||str[i]==str[j])&#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(str[i]!=str[j]) next[i] = j;</span><br><span class="line">        <span class="keyword">else</span> next[i] = next[j];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="实战1：一颗树A是否是另一个树的子树B"><a href="#实战1：一颗树A是否是另一个树的子树B" class="headerlink" title="实战1：一颗树A是否是另一个树的子树B"></a>实战1：一颗树A是否是另一个树的子树B</h4><p>序列化A和B树，然后就变成了用KMP找子串的问题了。</p>
<p>关于序列化和反序列化，如何序列化就如何反序列化。如使用先序遍历序列化，得到<code>1 2 3 # #</code>，那么也使用先序遍历反序列化得到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">  <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span></span><br><span class="line"># #</span><br></pre></td></tr></table></figure>

<p>需要注意的是，一个节点的value表示完毕时，要给出特殊的字符序列化，否则序列化的结果可能会有歧义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">12</span>     <span class="number">1</span></span><br><span class="line">  <span class="number">3</span>      <span class="number">23</span></span><br><span class="line">如果value表示完不给出特殊字符，那都是</span><br><span class="line"><span class="number">123</span>###</span><br><span class="line"></span><br><span class="line">改进：</span><br><span class="line"><span class="number">12</span>!<span class="number">3</span>!#!#!#!</span><br><span class="line"><span class="number">1</span>!<span class="number">23</span>!#!#!#!</span><br></pre></td></tr></table></figure>


<h3 id="Manacher算法：最长回文子串"><a href="#Manacher算法：最长回文子串" class="headerlink" title="Manacher算法：最长回文子串"></a>Manacher算法：最长回文子串</h3><p>在中心扩展的基础上， <strong>为了解决字符串长度奇偶的问题，在字符间插入<code>#</code></strong>，这样一来保证找到的所有回文串都是奇数长度。</p>
<p>用<code>f(i)</code>来表示第i位为中心，可以拓展出的最大回文半径，那么<code>f(i)-1</code>就是以i为中心的最大回文串长度(有一半是<code>#</code>)。</p>
<p>Manacher依旧是穷举每一个位置，但是它会动态规划<code>f(i)</code>。遍历每个位置算出最右回文右边界，如<code>01232101</code>，最右回文右边界就是0处。当最右回文右边界发生变化时，记录回文中心，然后比较是否是新最大回文子串。</p>
<ul>
<li>三种情况的处理方法<ul>
<li><ol>
<li>当回文中心不在最右回文右边界中时，就暴力扩。</li>
</ol>
</li>
<li><ol start="2">
<li>当回文子串，中心在最大回文右边界内，且对称点的回文左右半径在最右回文边界对应的回文左右半径内<ul>
<li>那就可以通过对称点直接得出改点的回文半径<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ ( o ) a ( o ) ]</span><br><span class="line">L   i   c   i   R</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>当回文子串，中心在最大回文右边界内，且对称点的回文左右半径不在最右回文边界对应的回文左右半径内<ul>
<li>那到R回文，因为y!=Y，不然最大回文半径还会扩大<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( y[ o   ) a     o ]Y</span><br><span class="line">   L i     c     i R</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>如果3的情况刚好压线，那就在半径到R的基础上在扩试试</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="Manacher模板"><a href="#Manacher模板" class="headerlink" title="Manacher模板"></a>Manacher模板</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用#预处理好字符串m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用rs储存回文半径</span></span><br><span class="line"><span class="comment">// mr为最大回文半径的位置</span></span><br><span class="line"><span class="comment">// c为最大回文半径对应的回文中心</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在最大回文半径内则取较小值，后面再调整</span></span><br><span class="line">    <span class="comment">// 当前点能到的最大回文半径：rm-i+1</span></span><br><span class="line">    <span class="comment">// 通过对称点得到的回文半径：rs[2*c - i]</span></span><br><span class="line">    rs[i] = (i&lt;=mr)? <span class="built_in">min</span>(mr-i+<span class="number">1</span> , rs[<span class="number">2</span>*c - i]):<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中心扩展试着找更大半径</span></span><br><span class="line">    <span class="keyword">while</span>(m[rs[i]+i] == m[i-rs[i]]) rs[i]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新最大边界及对应回文中心</span></span><br><span class="line">    <span class="keyword">if</span>(rs[i]+i<span class="number">-1</span> &gt; mr)&#123;</span><br><span class="line">        mr = rs[i] + i<span class="number">-1</span>;</span><br><span class="line">        c = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="窗口内最大值"><a href="#窗口内最大值" class="headerlink" title="窗口内最大值"></a>窗口内最大值</h3><p>窗口就是用L、R标记窗口的左右边界，而且都只能往右，不能回退。</p>
<ul>
<li>使用一个队列储存下标和值</li>
<li>队列只能从大到小排列<ul>
<li>当窗口右边界向右，在队列后面，如果队列后面的数小于等于待插入的数，则弹出，直到大于等于</li>
<li>当窗口左边界向右，检查队列前面的值的index是否过期，过期则弹出</li>
</ul>
</li>
<li>这么一来，队列顶部的数就是当前窗口中的最大值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    val</span><br><span class="line">    index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>找出最大值减最小值<em>小于</em>num的所有子数组，且要求时间复杂度为O(n)</p>
<ul>
<li>解：<ul>
<li><ol>
<li>性质<ul>
<li>如果一个数组达标，那它里面的任何一个子数组一定达标</li>
<li>如果一个子数组不达标，那它怎么往外扩都不达标</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>利用上面的性质，创建一个最小队列和一个最大队列，让L=0，R外扩，直到下一个r不达标<ul>
<li>那么<strong>以L开头</strong>的所有子数组都达标，R-L+1个</li>
<li>ans += R-L+1</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>然后L右缩小移位，如果R的下一个可以达标，那就外扩，然后回到第2步</li>
</ol>
</li>
<li>这么就得到了所求</li>
</ul>
</li>
</ul>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈：从底到顶是有顺序的，如大到小。</p>
<p>对数组中的每个元素找出它左边最近的大于它的值和右边最近大于它的值。要求时间复杂度O(n)。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line">    左      右</span><br><span class="line"><span class="number">3</span>   null    <span class="number">5</span></span><br><span class="line"><span class="number">5</span>   null    <span class="number">6</span></span><br><span class="line"><span class="number">2</span>   <span class="number">5</span>       <span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><ol>
<li>建立一个单调栈</li>
</ol>
</li>
<li><ol start="2">
<li>如果满足单调的顺序要求，则可栈</li>
</ol>
</li>
<li><ol start="3">
<li>当要入栈的数不满足顺序要求，则开始弹出，并记录数据<ul>
<li>如下一个index的4，不满足顺序，那么index为3的数右边最近的比他大的数就是index4对应的数，那么左边最近的比他大的就是弹出后的栈顶</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>弹出后插入是否有序，不满足则再次进行3的操作</li>
</ol>
</li>
<li><ol start="5">
<li>如果数组遍历完了栈还没空，则依次弹出，无右边最近的大于的数</li>
</ol>
</li>
<li>如果两个相同的数相邻，则在栈中他们共用一个位置</li>
</ul>
<h4 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h4><p>给定一个没有重复元素的数组要求建立一棵树，其中的每一棵子树上，值最大的节点都是树的头部。如果数组长度为n，则时间复杂度要求为O(n)</p>
<ul>
<li>解1. 使用大大根堆</li>
<li>解2. 使用单调栈<ul>
<li>使用单调栈找出左右最近的大于的信息</li>
<li>若左右都找不到大于的节点，则说明该点最大，做根节点</li>
<li>当左右都有大于的节点时让当前节点成为较小的一个子节点</li>
</ul>
</li>
</ul>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>给定一个整形矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域中1的数量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引子题：求组装它所包含的最大的矩形面积<ul>
<li>如柱状图的高度分别为：<code>5 2 3 1 4</code>最大面积就是6(2往左往右)</li>
<li>这个题的解法就是建立从小到大的单调栈，找出每个元素最右最近的小于的值</li>
<li>然后更新面积信息</li>
</ul>
</li>
<li>解<ul>
<li><ol>
<li>从第一行开始，执行上面的操作找出最大的矩形，更新max值</li>
</ol>
</li>
<li><ol start="2">
<li>加上下一行，当以列的元素遇到零时归零<ul>
<li>这里加到最后会得到<code>0 3 0 1</code></li>
<li>然后就成为了引子题的问题</li>
</ul>
</li>
</ol>
</li>
<li>这么一个过程下来就记录的最大值</li>
</ul>
</li>
</ul>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p>给一个数组表示一个环形的山，数组的值表示山的高度。每座山顶放烽火，相邻的山可以相互看见，高的山会挡住低的山的视线。求能互相看见的对数。</p>
<p>思路类似例2，中的柱状图，小的山峰找大的山峰，使用最大值打底作出单调栈，找出两边最近的大于的数，弹出时结算对数，一般情况下是2对。需要注意的是：</p>
<p>如果入栈的数和栈顶的数一样大，那就压在一起计数加一，如<code>4, 4</code>4个4，当来了的大的值如5</p>
<ul>
<li>结算4个4，则得到的对数为$C_4^2 + 4*2$，C42表示这4个4之间的对数，4x2表示每个4左右都能看到</li>
</ul>
<p>如果遍历完了栈还非空</p>
<ul>
<li>栈剩余2条以上的记录时，还是公式$C_k^2 + k*2$</li>
<li>栈剩2条记录时<ul>
<li>如果最后一条记录的个数是大于1，则还是公式</li>
<li>如果最后一条记录的个数是1，则公式把<code>k*2改为k*1</code></li>
</ul>
</li>
<li>只剩一条记录是时$C^2_k$</li>
</ul>
<h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><ul>
<li><p>递归</p>
<ul>
<li><code>f(int i, int j)</code>，表示str[i]之后的整个能不能被exp[j]之后的整个匹配<ul>
<li>j+1是*<ul>
<li>如果i，j匹配</li>
<li>如果i，j不匹配</li>
</ul>
</li>
<li>j+1不是*<ul>
<li>如果i，j匹配</li>
<li>如果i，j不匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>暴力递归</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="built_in">string</span>&amp; <span class="built_in">exp</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="built_in">exp</span>.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> i == str.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j上面还有字符，考察j+1的情况</span></span><br><span class="line">    <span class="keyword">if</span>(j + <span class="number">1</span> == <span class="built_in">exp</span>.<span class="built_in">size</span>() || <span class="built_in">exp</span>[j+<span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i != str.<span class="built_in">size</span>() &amp;&amp; (<span class="built_in">exp</span>[j] == str[i] || <span class="built_in">exp</span>[j] == <span class="string">'.'</span>)</span><br><span class="line">            &amp;&amp; <span class="built_in">process</span>(str, <span class="built_in">exp</span>, i+<span class="number">1</span>, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exp的j+1位置不仅有字符，而且字符是*</span></span><br><span class="line">    <span class="keyword">while</span>(i != str.<span class="built_in">size</span>() &amp;&amp; (<span class="built_in">exp</span>[j] == str[i] || <span class="built_in">exp</span>[j] == <span class="string">'.'</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">process</span>(str, <span class="built_in">exp</span>, i, j+<span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(str, <span class="built_in">exp</span>, i, j+<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态规划</li>
</ul>
<p>building…</p>
<hr>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p>一般方法的遍历树，空间复杂读是O(h)，h是树的高度，因为需要用栈来储存父节点来实现回退。</p>
<p>Morris遍历是在空间复杂度为O(1)的情况下遍历树的方法。它利用了树上的空闲空间</p>
<ul>
<li><ol>
<li>当前节点记位Cur，如果Cur无左孩子，Cur向右移动<code>Cur = Cur.right</code></li>
</ol>
</li>
<li><ol start="2">
<li>如果Cur有左孩子，找到Cur左子树上最右的节点，记做<code>mostright</code><ul>
<li><ol>
<li>如果<code>mostright</code>的右指针是空，让其指向Cur，然后cur向左移动</li>
</ol>
</li>
<li><ol start="2">
<li>如果<code>mostright</code>的右指针指向cur，让cur右移，然后让其指向空</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>没有右孩子遍历结束</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = null;</span><br><span class="line">    <span class="keyword">while</span>(cur!=null)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="literal">nullptr</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 第二次来此节点</span></span><br><span class="line">                mostRight.right = <span class="literal">nullptr</span></span><br><span class="line">                <span class="comment">// cur = cur.right; //跳过or not</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Morris后序遍历"><a href="#Morris后序遍历" class="headerlink" title="Morris后序遍历"></a>Morris后序遍历</h4><p>Morris遍历在遍历右子树时无法一步一步后退，这会导致需要回溯时不是全部都能单步回溯。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">  \</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">  /   \</span><br><span class="line"> <span class="number">5</span>      <span class="number">3</span></span><br><span class="line">          \</span><br><span class="line">            <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>后序遍历获得左字节点后就可输出，但是要在根节点前输出右子节点，需要外的操作。可以将整个”右斜”的树记录然后逆序输出，就是后序的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    TreeNode* mostRight;</span><br><span class="line">    TreeNode* head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    head-&gt;left = root;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        mostRight = head-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight)&#123;</span><br><span class="line">            <span class="keyword">while</span>(mostRight-&gt;right &amp;&amp; mostRight-&gt;right!=head)&#123;</span><br><span class="line">                mostRight = mostRight-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                mostRight-&gt;right = head;</span><br><span class="line">                head = head-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* temp = head-&gt;left;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rtree;</span><br><span class="line">                <span class="comment">// 第二次访问节点时，其"孤立左节点"一定都已输出，且正是后序需要的在右节点前输出</span></span><br><span class="line">                <span class="comment">// 遍历整个右长树，然后reverse就是后序的右节点和根节点的输出</span></span><br><span class="line">                <span class="keyword">while</span>(temp!=mostRight)&#123;</span><br><span class="line">                    rtree.push_back(temp-&gt;val);</span><br><span class="line">                    temp = temp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                rtree.push_back(temp-&gt;val);</span><br><span class="line">                reverse(rtree.begin(), rtree.end());</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i: rtree)&#123;</span><br><span class="line">                    ans.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul>
<li>左边孩子比根节点小</li>
<li>右边孩子比根节点大</li>
</ul>
<p><strong>查找</strong>  </p>
<ul>
<li>左小右大，递归或循环  </li>
</ul>
<p><strong>插入</strong></p>
<ul>
<li>左小右大，递归或循环  </li>
</ul>
<p><strong>删除</strong></p>
<ul>
<li>没有孩子<ul>
<li>直接插入</li>
</ul>
</li>
<li>只有一个孩子<ul>
<li>子承父业</li>
</ul>
</li>
<li>有两个孩子<ul>
<li>找到左子树的最大或右子树的最小(记为S)替换被删除节点，然后安顿好S的孩子。这里又相当于删除了S，可以递归一下。…有效降低树的高度</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Position Tmp; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( !BST ) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"要删除的元素未找到"</span>); </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class="comment">/* 从左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class="comment">/* 从右子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">/* BST就是要删除的结点 */</span></span><br><span class="line">            <span class="comment">/* 如果被删除结点有左右两个子结点 */</span> </span><br><span class="line">            <span class="keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;</span><br><span class="line">                <span class="comment">/* 从右子树中找最小的元素填充删除结点 */</span></span><br><span class="line">                Tmp = FindMin( BST-&gt;Right );</span><br><span class="line">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">                <span class="comment">/* 从右子树中删除最小元素 */</span></span><br><span class="line">                BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">/* 被删除结点有一个或无子结点 */</span></span><br><span class="line">                Tmp = BST; </span><br><span class="line">                <span class="keyword">if</span>( !BST-&gt;Left )       <span class="comment">/* 只有右孩子或无子结点 */</span></span><br><span class="line">                    BST = BST-&gt;Right; </span><br><span class="line">                <span class="keyword">else</span>                   <span class="comment">/* 只有左孩子 */</span></span><br><span class="line">                    BST = BST-&gt;Left;</span><br><span class="line">                <span class="built_in">free</span>( Tmp );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BST的性质"><a href="#BST的性质" class="headerlink" title="BST的性质"></a>BST的性质</h4><ul>
<li><ol>
<li><strong>BST的中序遍历是一个非递减的有序序列</strong></li>
</ol>
</li>
</ul>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>节点左边都比该节点小，右边都比该节点大</p>
<p>不考虑平衡性的情况下</p>
<ul>
<li><p>插入</p>
<ul>
<li>左小右大，找到自己的位置</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li>当左右子树都非空时，用右子树的最左节点顶替，该节点的右子树交给它的父节点<ul>
<li>因为右子树最左节点是最小的比它大的数</li>
<li>同理，也可选左子树的最右节点</li>
</ul>
</li>
</ul>
</li>
<li><p>如果考虑平衡性不同的平衡二差数动作的组合不同，但基本思想(动作)都是<strong>通过旋转来改变局部的平衡性</strong></p>
<ul>
<li>左旋：头节点变成了新头节点的左节点<ul>
<li>如果新头节点存在左孩子，则成为旧头节点的右孩子。因为对于左旋，新头节点本来是旧头节点的右孩子</li>
</ul>
</li>
<li>右旋：头节点变成了新头节点的右节点<ul>
<li>如果新头节点存在右孩子，则成为旧头节点的左孩子。因为对于右旋，新头节点本来是旧头节点的左孩子</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><blockquote>
<p>AVL三个发明者名字的简写</p>
</blockquote>
<ul>
<li>发现不平衡<ul>
<li>把左树高度和右树高度记录在节点中，当插入新节点时回溯，修改沿途的值，修改过程中将发现不平衡。删除节点同理</li>
</ul>
</li>
<li>当发现不平衡时，找到<strong>最小不平衡子树</strong> 的根A，进行旋转，<strong>4种调整的组合</strong>(这插入节点为R)<ul>
<li>LL：左子树的左子树导致的不平衡<ul>
<li>单纯的右旋</li>
<li>A做B的右子，B的右子成A的左子  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">右旋</span><br><span class="line">        A          B</span><br><span class="line">       &#x2F;          &#x2F; \</span><br><span class="line">      B          R   A</span><br><span class="line">     &#x2F;</span><br><span class="line">    R</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>RR：右子树的右子树导致的不平衡<ul>
<li>单纯的左旋</li>
<li>A做B的左子，B的左子做A的右子  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">左旋</span><br><span class="line">     A            B</span><br><span class="line">      \          &#x2F; \</span><br><span class="line">       B        A   R</span><br><span class="line">        \</span><br><span class="line">         R</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>LR：左子树的右子树导致的不平衡<ul>
<li>先左旋再右旋：<ul>
<li>先以头节点的左子节点为新头节点左旋</li>
<li>然后就转化成了LL型的操作</li>
</ul>
</li>
<li>左旋：B做R的左子</li>
<li>右旋：A做R的右子，R的左子做A的左子  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      A</span><br><span class="line">     &#x2F; </span><br><span class="line">    B  </span><br><span class="line">     \</span><br><span class="line">      R</span><br><span class="line">左旋:</span><br><span class="line">   B        R</span><br><span class="line">    \      &#x2F;</span><br><span class="line">     R    B</span><br><span class="line">右旋:</span><br><span class="line">      A      R</span><br><span class="line">     &#x2F;      &#x2F; \</span><br><span class="line">    R      B   A</span><br><span class="line">   &#x2F;</span><br><span class="line">  B</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>RL：右子树的左子树导致的不平衡<ul>
<li>同理LR型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>为表述方便：C(current)表示针对的节点，P(parent), G(grandparent)，U(uncle)</p>
<ul>
<li>特征<ul>
<li><ol>
<li>根节点是黑色</li>
</ol>
</li>
<li><ol start="2">
<li>所有叶子(nil节点)都是黑色</li>
</ol>
</li>
<li><ol start="3">
<li>每个红色节点的两个字节点都是黑色(不存在两个连续的红色节点)</li>
</ol>
</li>
<li><ol start="4">
<li>从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点<ul>
<li>黑色完美平衡</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>旋转：为例减小树的高度<ul>
<li>红黑树最大高度$O(\log n)$</li>
<li>左旋：<ul>
<li>C和它的右子节点交换</li>
<li>C右子节点的左子树成为C的右子树</li>
<li>右子变新爹，右子的左子变老爹的右子，老爹变新爹左子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># LEFT-ROTATE(T, x)</span><br><span class="line">y &#x3D; x.right</span><br><span class="line">x.right &#x3D; y.left</span><br><span class="line">if y.left !&#x3D; nil</span><br><span class="line">    y.left.p &#x3D; x</span><br><span class="line">y.p &#x3D; x.p</span><br><span class="line">if x.p &#x3D;&#x3D; nil</span><br><span class="line">    T.root &#x3D;&#x3D; y</span><br><span class="line">elseif x &#x3D;&#x3D; x.p.left</span><br><span class="line">    x.p.left &#x3D; y</span><br><span class="line">else x.p.right &#x3D; y</span><br><span class="line">y.left &#x3D; x</span><br><span class="line">x.p &#x3D; y</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>右旋：<ul>
<li>C和它的左子节点交换</li>
<li>C左子节点的右子树成为C的左子树</li>
<li>左子变新爹，左子的右子变老爹的左子，老爹变新爹右子</li>
</ul>
</li>
</ul>
</li>
<li>搜索<ul>
<li>比节点小就找左子树，否则右子树</li>
</ul>
</li>
<li>插入<ul>
<li>每个新节点都是红色的，违规修复代价比较小</li>
<li><ol>
<li>C=root，则把C变为黑色</li>
</ol>
</li>
<li><ol start="2">
<li>P是黑色，直接插入</li>
</ol>
</li>
<li><ol start="3">
<li>P是红色<ul>
<li>I. U是红，则P和U都变黑，G变后，向上递归</li>
<li>II. U是黑<ul>
<li>三角型：GPC呈三角形<ul>
<li>对P旋转使得GPC一条直线，然后做直线型操作</li>
</ul>
</li>
<li>直线型：GPC一条直线<ul>
<li>对G旋转，然后交换G和P的颜色</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>删除<ul>
<li><strong>building</strong> </li>
</ul>
</li>
</ul>
<h3 id="哈夫曼树-Huffman"><a href="#哈夫曼树-Huffman" class="headerlink" title="哈夫曼树(Huffman)"></a>哈夫曼树(Huffman)</h3><p>两种编码方式</p>
<ul>
<li>等长编码<ul>
<li>使用固定长度的位来对所有信号进行编码</li>
<li>简单但并不是每个信号出现的频率是一样的，所有对于对于经常出现的信号，需要使用很多的资源</li>
</ul>
</li>
<li>不等长编码<ul>
<li>对于出现频率不同的信号可以采用不同长度的位进行编码</li>
<li>节省资源，但为保证译码唯一性需要进行复杂的操作</li>
</ul>
</li>
</ul>
<p>我们可以使用二叉树来进行01编码，为了保证译码唯一性，则需要每个编码不能是其他任意一个编码的前缀。所以编码的结果必须都是出现在叶子节点。</p>
<p>对于最优的编码，我们需要使得树的权值最小，那么权值大的节点应尽量靠近根节点，哈夫曼树就是为了解决最优编码问题产生的。</p>
<p><strong>算法</strong> :对于一组带权节点，每次选取最小和次小的的节点从原数组中删除，然后它们权值的和组成新的节点加入到原数组中，它们成为这个新节点的孩子。如此循环</p>
<p><strong>数据结构</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">    <span class="keyword">int</span> Lchild;</span><br><span class="line">    <span class="keyword">int</span> Rchild;</span><br><span class="line">&#125; HNode;</span><br></pre></td></tr></table></figure>

<p>由于哈夫曼树的两两节点合并组成的树，所以不会存在出度为1的节点，故共有2n-1个节点。开辟一个2n-1的数组，然后根据算法填充。</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>weight</th>
<th>parent</th>
<th>Lchild</th>
<th>Rchild</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2n-2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>从没有标记父节点的节点中选择最小和次小的节点，组成新的节点，放入队尾</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化等操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=rear; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++)&#123; </span><br><span class="line">    findNodes(nodes, <span class="built_in">min</span>, cmin); <span class="comment">// 从没有parent的节点中找出最小和次小的节点</span></span><br><span class="line">    nodes[<span class="built_in">min</span>].parent = i;</span><br><span class="line">    nodes[cmin].parent = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入尾部</span></span><br><span class="line">    nodes[i].weight = nodes[<span class="built_in">min</span>].weight + nodes[cmin].weight;</span><br><span class="line">    nodes[i].Lchild = <span class="built_in">min</span>;</span><br><span class="line">    nodes[i].Rchild = cmin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findNodes</span><span class="params">(HNode* arr, <span class="keyword">int</span>&amp; <span class="built_in">min</span>, <span class="keyword">int</span>&amp; cmin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span>=MAXINT;</span><br><span class="line">    <span class="keyword">int</span> cmin=MAXINT;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.<span class="built_in">size</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].parent == EMPTY)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i].weight &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">                cmin = <span class="built_in">min</span>;</span><br><span class="line">                <span class="built_in">min</span> = arr[i].weight;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i].weight &lt; cmin)&#123;</span><br><span class="line">                cmin = arr[i].weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造好哈夫曼树后，译码和编码操作就简单了。</p>
<ul>
<li>译码: <ul>
<li>从根节点开始，0找左节点，1找右节点(与具体怎么建立的哈夫曼树有关)</li>
<li>遇到叶子节点则得到译码结果</li>
</ul>
</li>
<li>编码：<ul>
<li>从叶子节点开始，向上寻找其父节点，如果节点是父节点的左孩子，则编码0，否则编码1，从尾向前填充</li>
<li>如<code>***010\0</code></li>
<li>找到根节点则将编码传出即可</li>
</ul>
</li>
</ul>
<hr>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="DFS深度优先搜索"><a href="#DFS深度优先搜索" class="headerlink" title="DFS深度优先搜索"></a>DFS深度优先搜索</h2><ul>
<li>从一节点出发<ul>
<li>非连通图分而治之</li>
</ul>
</li>
<li>依次从访问邻接点,直至所有邻接点都被访问<ul>
<li>例:迷宫  </li>
</ul>
</li>
</ul>
<h2 id="BFS广度优先搜索"><a href="#BFS广度优先搜索" class="headerlink" title="BFS广度优先搜索"></a>BFS广度优先搜索</h2><ul>
<li>从一节点出发</li>
<li>把他所有的邻接点入队列,并检测目标节点</li>
<li>依次把节点出队列,并递归的把他的邻接点入队列,直到访问所有点<ul>
<li>例:树的层序遍历  </li>
</ul>
</li>
</ul>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>若存在两点在同一个连通集合中，则这两点存在回路</p>
<ul>
<li>Find() 找根节点</li>
<li>Union() 合并成集合</li>
</ul>
<h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>解决单源路非递减顺序(没有负)最短路径问题</p>
<ul>
<li>初始化<ul>
<li>对所有未检索的点进行标记:collected[v] = false</li>
<li>使用<code>dist[i]=INF</code>记录源点到节点i的最短距离<ul>
<li><code>dist[src]=0</code></li>
</ul>
</li>
<li>使用<code>path[i]</code>记录节点i的前驱节点，则从终点开始查找则得到最短路径</li>
</ul>
</li>
<li><strong>从未收录的顶点中选择最dist最小者V</strong>(贪心),对于V的所有未收录的邻接点W,若以V为中间节点到W的路径更短，则更新dist[W]<ul>
<li>可用 <strong>最小堆优化</strong> 选择dist最小者的过程。cpp中可以使用<code>priority_queue&lt;T&gt;</code></li>
</ul>
</li>
<li>所有邻接点访问完后collected[v]=true,重复第2步，直到所有节点都访问</li>
<li><strong>原理</strong> <ul>
<li>TODO:为何要选dist最小者加入</li>
</ul>
</li>
</ul>
<p>如此一来这条路径也一定是源点到这些中途节点的最短路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Vertex s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        V = 未收录顶点中dist最小者;   <span class="comment">// 非常重要的一步</span></span><br><span class="line">        <span class="keyword">if</span>(V未找到)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        collected[V] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(V的每个邻接点 W)&#123;</span><br><span class="line">            <span class="keyword">if</span>(collected[W] == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[V]+E&lt;V,W&gt; &lt; dist[W])&#123;</span><br><span class="line">                    dist[W] = dist[V] + E&lt;V,W&gt;;</span><br><span class="line">                    path[W] = V;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>解决多源路非递减顺序最短路径问题   </p>
<p>稠密图有优势  </p>
<p>$T=O(V^3)$  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心</span></span><br><span class="line"><span class="comment">// 顶点i到顶点j,顶点间的最短路就在矩阵显示出来了</span></span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>;k&lt;N;k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(D[i][k]+D[k][j]&lt;D[i][j])&#123;</span><br><span class="line">                D[i][j] = D[i][k]+D[k][j];</span><br><span class="line">                path[i][j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>解决稠密图的最小生成树问题  </p>
<ul>
<li>从任意点出发</li>
<li>寻找与这个整体相邻,且不构成回路的权最小点</li>
<li>加入该整体,继续搜索,直至所有点都收录(生成树必须包含所有点)</li>
</ul>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>解决稀疏图的最小生成树问题  </p>
<p>$T=E\log{E}$  </p>
<ul>
<li>核心思想,每个顶点都是一棵树,把森林连成树</li>
<li>找最短且不构成回路的边,又因为每个顶点都是一棵树,每个边都把森林连成树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MST=&#123;&#125;;  <span class="comment">// 最小生成树</span></span><br><span class="line">E;   <span class="comment">// 边集</span></span><br><span class="line"><span class="keyword">while</span>(没够V<span class="number">-1</span>条边&amp;&amp;E没空)&#123;</span><br><span class="line">    findmin();  <span class="comment">// 找最小边  用最小堆</span></span><br><span class="line">    delet(E(v,w));  <span class="comment">// 把该边移除边集E</span></span><br><span class="line">    <span class="keyword">if</span>(E(v,w)加入MST不构成回路)   <span class="comment">// 并查集</span></span><br><span class="line">        join(E(v,w));  <span class="comment">// 加入并查集</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        单纯的删除</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(MST中边不够V<span class="number">-1</span>条)</span><br><span class="line">    生成树不存在</span><br></pre></td></tr></table></figure>


<h3 id="A星寻路算法"><a href="#A星寻路算法" class="headerlink" title="A星寻路算法"></a>A星寻路算法</h3><ul>
<li>启发性搜索：f = g + h<ul>
<li>f：当前点到终点的代价</li>
<li>g：起点到当前点的代价</li>
<li>h：当前点到终点的 <strong>预估代价</strong><ul>
<li>忽略障碍，只算直线距离，但是移动时只走无障碍的路</li>
</ul>
</li>
</ul>
</li>
<li>过程<ul>
<li>使用一个OPEN列表保存能走且未走过的路</li>
<li>使用一个CLOSED列表保存走过的路</li>
<li>将起点放入OPEN列表</li>
<li>循环<ul>
<li><ol>
<li><strong>current=OPEN列表中f最小的点</strong></li>
</ol>
</li>
<li><ol start="2">
<li>OPEN中移出current放入CLOSED</li>
</ol>
</li>
<li><ol start="3">
<li>如果current是终点，则循环结束</li>
</ol>
</li>
<li><ol start="3">
<li>遍历current的所有邻居(其中的邻居不能是CLOSED中、不能是障碍物)</li>
</ol>
</li>
<li><ol start="4">
<li>计算邻居的f</li>
</ol>
</li>
<li><ol start="5">
<li>将邻居的parent设为current</li>
</ol>
</li>
<li><ol start="6">
<li>将邻居放入OPEN列表</li>
</ol>
</li>
</ul>
</li>
<li>最后从终点一直沿着父节点走就找到了最短路径</li>
</ul>
</li>
</ul>
<hr>
<h1 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h1><h3 id="联机算法"><a href="#联机算法" class="headerlink" title="联机算法"></a>联机算法</h3><p>在任意时刻，算法对要操作的数据只读入（扫描）一次，一旦被读入并处理，它就不需要在被记忆了。而在此处理过程中算法能对它已经读入的数据立即给出相应子序列问题的正确答案。具有这种特性的算法叫做联机算法（on-line algorithm。</p>
<h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<ul>
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题</li>
</ul>
<hr>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>思路，可以模拟全排列的过程，一个一个插入。只是不同的方法优劣程度不同<ul>
<li>妙：通过交换位置维护已选数，回溯时再换回来<ul>
<li><ol>
<li>优化空间，不需要而外空间保存已选</li>
</ol>
</li>
<li><ol start="2">
<li>优化未选数查询，交换后已选的数都排在了前头，未选的数从剩余长度开始就是</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; output, <span class="keyword">int</span> first, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 所有数都填完了</span></span><br><span class="line">    <span class="keyword">if</span> (first == len) &#123;</span><br><span class="line">        res.emplace_back(output);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; len; ++i) &#123;  <span class="comment">// first表示要插入的位置，i表示要选择插入的对象</span></span><br><span class="line">        <span class="comment">// 使用交换来维护已选数组</span></span><br><span class="line">        swap(output[i], output[first]);</span><br><span class="line">        <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">        backtrack(res, output, first + <span class="number">1</span>, len);</span><br><span class="line">        <span class="comment">// 撤销操作</span></span><br><span class="line">        swap(output[i], output[first]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>设有100亿个黑名单网页，每个网页URL占用64字节，想要实现一种网页过滤系统，过滤黑名单，允许有万分之一的判断失误，且而外空间不超过30G。</p>
<p>如果用哈希表存入数据库，但是至少需要640G空间。这样对空间要求比较严格，但允许一定失误的过滤系统，往往是  <strong>布隆过滤器：使用很少的空间就能把正确率做到很高的程度</strong> </p>
<p>布隆过滤器可以精确的代表一个集合，可精确到判断某一元素是否在集合中，但100%的精确是不可能的。</p>
<ul>
<li>加入布隆过滤器<ul>
<li>一个长度为m的bit类型的数组<code>bitarray</code>，每个位置只有0(白)和1(黑)</li>
<li>有k个哈希函数，这些哈希函数都足够优秀，且输出域都大于等于m</li>
<li>对于一个对象，如64字节的URL通过k个哈希函数<ul>
<li>哈希的结果对m取余，取余的结果在bitarray上将相应的位置设为1(涂黑)</li>
</ul>
</li>
<li>使用该方法处理所有的对象，如果遇到已经涂黑的位置，则让其保持黑</li>
</ul>
</li>
<li>检查<ul>
<li>将对象通过这k个哈希函数，取余等操作，找到bitarray上对应的位置</li>
<li>如果得到的位置都为黑色，则就是黑名单中，否则不是</li>
<li>但是也有可能误判，将白的判为黑的</li>
</ul>
</li>
</ul>
<h3 id="bitarray和k大小的确定"><a href="#bitarray和k大小的确定" class="headerlink" title="bitarray和k大小的确定"></a>bitarray和k大小的确定</h3><p>bitarray大小m由样本数量n和能容忍的驶入率p决定。上题中$m=100亿，p=0.01%$</p>
<p>$$<br>m = - \frac{n \times lnp}{(ln2)^2} \<br>k = ln2 \times \frac mn = 0.7 \times \frac mn<br>$$</p>
<h2 id="不用额外空间交换量整数的值"><a href="#不用额外空间交换量整数的值" class="headerlink" title="不用额外空间交换量整数的值"></a>不用额外空间交换量整数的值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = a0;</span><br><span class="line">b = b0;</span><br><span class="line">a = a^b;  <span class="comment">// a=a0^b0, b=b0</span></span><br><span class="line">b = a^b;  <span class="comment">// a=a0^b0, b=a0^b0^b0=a0</span></span><br><span class="line">a = a^b;  <span class="comment">// a=a0^b0^a0=b0, b=a0</span></span><br></pre></td></tr></table></figure>


<h2 id="奇数次偶数次"><a href="#奇数次偶数次" class="headerlink" title="奇数次偶数次"></a>奇数次偶数次</h2><ul>
<li><ol>
<li>假设一个数组中只有一个数出现了奇数次，其他数都出现了偶数次，要求在时间复杂度0(1)的情况下找出这个数。<ul>
<li>使用一个数a=0，与arr中的每一个数[c, b, a, c, b, a, d]异或，结果就是这个数</li>
<li>因为异或运算满足交换率和结合率，异或的次序就可以是[aabbccd]，所以得到d</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>第一题小小改进，有两个数出现奇数次<ul>
<li>先与每个数异或最后剩下<code>a=b^c</code></li>
<li>因为b和c是不同的数，所以a不为0，找到为1的一位，假设是第k位</li>
<li>因为低k位为1，说明a和b的第k位一定不一样</li>
<li>第二次遍历让a2=0只与与第k位为1的数异或，则异或的结果就是a和b中的一个</li>
<li><code>a^a2</code>的结果就是a和b中的另一个</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>从暴力搜索 推导出 动态规划，然后优化</p>
<h2 id="动态规划与记忆搜索的关系"><a href="#动态规划与记忆搜索的关系" class="headerlink" title="动态规划与记忆搜索的关系"></a>动态规划与记忆搜索的关系</h2><p>给定一个集合，{1, 5, 10, 15, 25}，求组合得到一个数target是所有组合数。</p>
<ul>
<li>递归<ul>
<li>遍历数组，取一个值后，用剩下target继续递归执行</li>
<li><strong>大量重复计算</strong>，对于一个target值，组合数是相同的，不需要每次都从头计算</li>
</ul>
</li>
<li>记忆搜索<ul>
<li>使用一个map记录某个状态下target对应的组合数，如果没计算过才算，否则直接取值</li>
<li><strong>区别于动态规划</strong> ，记忆搜索”不规定计算顺序”，遇到无记忆的就算</li>
</ul>
</li>
<li>动态规划<ul>
<li>生成行数为N，列数位aim+1的矩阵dp(dynamic programming)，<code>dp[i][j]</code>表示使用<code>arr[0...i]</code>货币的情况下，组成钱数j有多少种方法</li>
<li>动态规划规定每一种递归状态下的计算顺序，依次进行计算</li>
<li>动态规划严格规定计算顺序，存在进一步优化的可能</li>
</ul>
</li>
</ul>
<p>building…</p>
<h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h2><ul>
<li>Map<ul>
<li>通过哈希函数把大任务分成子任务</li>
</ul>
</li>
<li>Reduce<ul>
<li>把子任务并发处理，然后合并结果</li>
</ul>
</li>
<li>注意点<ul>
<li>备份的考虑，分布式存储的设计细节(多少备份合适)</li>
<li>任务分配策略与任务进度跟踪</li>
<li>多用户权限控制</li>
</ul>
</li>
</ul>
<p>以下的经典用map-reduce解决问题的方案</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>统计一篇文章中每个单词出现次数</p>
<ul>
<li>文章预处理，抓取有效单词<ul>
<li>去除标点，去除连字符，处理缩写等</li>
</ul>
</li>
<li>map阶段<ul>
<li>对每个单词生成词频为一的记录，如(dog, 1), (cat, 1)</li>
<li>通过哈希函数将所有单词分成若干个子任务<ul>
<li>每个子任务会包含若干种单词，但同一种单词不会被分配到不同子任务中</li>
<li>这样一来相同的都能被统计到</li>
</ul>
</li>
</ul>
</li>
<li>reduce阶段<ul>
<li>所有子任务记录合并</li>
</ul>
</li>
</ul>
<h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><ul>
<li><ol>
<li>分治，通过哈希函数将大任务分流<ul>
<li>难点在于通讯、时间和空间的估算</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>分流，通过哈希函数将大文件文流到小文件<ul>
<li>解决局部问题从而解决整体问题</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="例题1-2"><a href="#例题1-2" class="headerlink" title="例题1"></a>例题1</h3><p>对10亿个ip地址排序，已知每个ip地址只会出现一次</p>
<ul>
<li>普通方法<ul>
<li>每个ip转换成无符号整数</li>
<li>10亿个整数约占4G空间</li>
</ul>
</li>
<li>bitmap<ul>
<li>每个ip转换成无符号整数</li>
<li>申请一个$2^32$的bit类型的数组，空间约128m</li>
<li>如果整数k出现则把第k-1位bit描黑</li>
<li>从0位置遍历，把ip通过位置还原即可</li>
</ul>
</li>
</ul>
<h3 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h3><p>一个包含20亿个全是整数的大文件，在其中找出出现次数最多的数。但是内存只有2G</p>
<ul>
<li>普通方法：HashMap<ul>
<li>key：具体一种数，整型4字节</li>
<li>value：出现次数，整型4字节</li>
<li>一条记录8字节，如果产生20亿条记录将会溢出，但是如果记录条数比较少可能也不会溢出</li>
</ul>
</li>
<li>哈希函数 <strong>分流</strong><ul>
<li>将大文件的数分配到小文件中<ul>
<li>同一个数肯定在同一个文件</li>
<li>而且分配均匀，每个文件用到的内存相当</li>
</ul>
</li>
<li>找出小文件中各自最高，比较即可</li>
</ul>
</li>
</ul>
<h2 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h2><p>一般使用集群来实现数据缓存，因此需要优秀的哈希函数在做负载均衡。如果使用简单是哈希函数，如取余哈希，将会面临以下问题。</p>
<ul>
<li>问题<ul>
<li>增加或删除机器时代价很高，机器数改变所有数据需要重新哈希</li>
<li>因此还需要大规模的数据迁移</li>
</ul>
</li>
<li>改进方案<ul>
<li><strong>一致性哈希算法</strong><ul>
<li>数据id哈希计算的结果范围是 0～2^32</li>
<li>将id组哈希组织成首尾相连的环形结构</li>
<li>机器均匀的分配在其中的机器点</li>
<li>数据计算哈希后，找到距离最近(规定只能一个方向找)的机器，则这个数据由该机器管理</li>
<li>添加删除机器只会改变环的一部分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串拷贝和替换"><a href="#字符串拷贝和替换" class="headerlink" title="字符串拷贝和替换"></a>字符串拷贝和替换</h2><p>给定一个字符串str，将其中空格替换成”%20”，假设str后面有足够的空间</p>
<ul>
<li>算出替换后的长度</li>
<li><strong>从后向前拷贝</strong>，经常是这种操作</li>
</ul>
<h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><p>给定一个字符串str，判断是不是整体有效的括号字符串，最优解时间复杂度O(n), 空间复杂度O(1)</p>
<ul>
<li>用一个num记录一种括号，以下假设只有一种括号出现</li>
<li>左括号num++，右括号num–</li>
<li>如果num&lt;0，return false</li>
<li>如果遍历完后num==0,return true</li>
</ul>
<h2 id="最长无重复子字符串"><a href="#最长无重复子字符串" class="headerlink" title="最长无重复子字符串"></a>最长无重复子字符串</h2><p>给定一个字符串str找出它的最长无重复子字符串，最优解O(n), O(n)</p>
<ul>
<li>假设s[i]表示i位置为结尾，能到达(符合不重复字符)的最左的位置</li>
<li>map，统计每种字符最后一次出现的位置</li>
<li><code>int pre</code>，s[i-1]结尾的情况下，能到达的最左位置</li>
<li><ol>
<li><code>map[str[i]]</code>找到之前<code>str[i]</code>结尾的位置，记为A</li>
</ol>
</li>
<li><ol start="2">
<li>使用pre，找到<code>str[i-1]</code>最左位置，记为B</li>
</ol>
</li>
<li><ol start="3">
<li>比较A和B，选择当前位置间A或B较短的一方，更新最大无重复字符字串长度</li>
</ol>
</li>
<li><ol start="4">
<li>更新，map和pre</li>
</ol>
</li>
<li>原理:<ul>
<li>从左到右都是取最长无重复，再多一个就重复的操作</li>
</ul>
</li>
</ul>
<h2 id="字符串旋转-逆序的妙用"><a href="#字符串旋转-逆序的妙用" class="headerlink" title="字符串旋转/逆序的妙用"></a>字符串旋转/逆序的妙用</h2><h3 id="旋转题"><a href="#旋转题" class="headerlink" title="旋转题"></a>旋转题</h3><p>给定两个字符串str1，str2，判断是否互为旋转词，要求时间复杂度O(N)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &quot;cdab&quot;, b &#x3D; &quot;abcd&quot;, true</span><br><span class="line">a &#x3D; &quot;1ab2&quot;, b &#x3D; &quot;ab12&quot;, false</span><br><span class="line">a &#x3D; &quot;2ab1&quot;, b &#x3D; &quot;ab12&quot;, true</span><br></pre></td></tr></table></figure>

<ul>
<li>KMP(str1+str1, str2)<ul>
<li>str和str拼接后，以长度为4的字符串为例，则[0<del>3]，[1-4], [2</del>5]…各是一种旋转次，因此拼接后的字符串包含所有可能的旋转词</li>
</ul>
</li>
</ul>
<h3 id="逆序妙用"><a href="#逆序妙用" class="headerlink" title="逆序妙用"></a>逆序妙用</h3><ul>
<li>给定一个字符串，在单词间做逆序调整，如: I’m a student.  =&gt;  student. a I’m<ul>
<li>全局逆序，再每个单词每个单词的逆序</li>
</ul>
</li>
<li>给定一个字符串str，和一个整数i，i将str[0:i]移到右侧，str[i+1:n-1]移到左侧。如：str = “abcde”, i=2 =&gt; “deabc”，要求:时O(N)，空O(1)<ul>
<li>整体逆序，再每段逆序([0,2]逆序，[3,n-1]逆序)</li>
</ul>
</li>
</ul>
<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><h2 id="卡特兰数公式"><a href="#卡特兰数公式" class="headerlink" title="卡特兰数公式"></a>卡特兰数公式</h2><h3 id="公式之一"><a href="#公式之一" class="headerlink" title="公式之一"></a>公式之一</h3><p>假设有n对左右括号，求合法的排列组合有多少种？</p>
<ul>
<li>n对括号，则总排列数为 C_{2n}^n 。把左括号记为1，右括号记为-1</li>
<li>当第一次出现-1个数大于1时(即不合法)，把所以1变为-1,所有-1变为1。于是得到一个有n+1个1和n-1个-1的排列</li>
<li>利用证明结论：每一个非法的排列通过如上方式变换，可以得到n+1个1和n-1个-1组成的排列</li>
<li>则所有不合法排列数 = n+1个1和n-1个-1组成的排列数 = $C_{2n}^{n+1}或C_{2n}^{n-1}$</li>
<li>所以合法排列数 = $\frac1{n+1} \times C_{2n}^n $ 。_<ul>
<li>即 <strong>卡特兰数公式</strong> 之一</li>
</ul>
</li>
</ul>
<p>building(数学问题)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/19/universe/python/tensorflow_learning/Tensorflow_learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/19/universe/python/tensorflow_learning/Tensorflow_learning/" class="post-title-link" itemprop="url">Tensorflow</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-19 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-19T00:00:00+08:00">2019-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-10 19:09:31" itemprop="dateModified" datetime="2020-10-10T19:09:31+08:00">2020-10-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h3 id="图片读取展示"><a href="#图片读取展示" class="headerlink" title="图片读取展示"></a>图片读取展示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  <span class="comment"># 引入OpenCV</span></span><br><span class="line">img = cv2.imread(<span class="string">'path'</span>,<span class="number">1</span>)  <span class="comment"># 读取图片，0是灰图，1是彩图</span></span><br><span class="line">cv2.imshow(<span class="string">'image'</span>,img)  <span class="comment"># 'image'打开的窗体的标题，img展示的内容</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  <span class="comment"># 暂停</span></span><br></pre></td></tr></table></figure>
<p>cv.imread 过程：1文件读取 2封装格式解析 3数据解码 4数据加载  </p>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><h4 id="图片读写"><a href="#图片读写" class="headerlink" title="图片读写"></a>图片读写</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">'path'</span>,<span class="number">1</span>)  <span class="comment"># 读取图片，0是灰图，1是彩图</span></span><br><span class="line">cv2.imwrite(<span class="string">"path"</span>,img)  <span class="comment"># 1,图片名 2.图片数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同质量的图片写入</span></span><br><span class="line"><span class="comment"># jpg,有损压缩</span></span><br><span class="line"><span class="comment"># 压缩比参数范围为0~100，越低压缩比越高</span></span><br><span class="line">cv2.imwrite(<span class="string">"path.jpg"</span>,img,[cv2.IMWRITE_JPEG_QUALITY,<span class="number">0</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment"># png是无损压缩，有透明度属性</span></span><br><span class="line"><span class="comment"># 压缩比参数0~9,越低压缩比越低</span></span><br><span class="line">cv2.imwrite(<span class="string">"path.png"</span>,img,[cv2.IMWRITE_PNG_QUALITY,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h4 id="操作像素"><a href="#操作像素" class="headerlink" title="操作像素"></a>操作像素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(<span class="string">"img.jpg"</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># OpenCv读取图片是bgr(rgb倒过来)，左上角开始的坐标轴</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取像素点</span></span><br><span class="line">(b,g,r) = img[x,y]</span><br><span class="line">print(b,g,r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入像素</span></span><br><span class="line">img[x,y] = (b,g,r)</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="OpenCv"><a href="#OpenCv" class="headerlink" title="OpenCv"></a>OpenCv</h1><h3 id="OpenCv模块结构"><a href="#OpenCv模块结构" class="headerlink" title="OpenCv模块结构"></a>OpenCv模块结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to be continued</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Tensotflow"><a href="#Tensotflow" class="headerlink" title="Tensotflow"></a>Tensotflow</h1><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># 定义常量</span></span><br><span class="line">data1 = tf.constant(<span class="number">2.5</span>)  <span class="comment"># 指定数据类型可以加参数(2,dtype=tf.int32)</span></span><br><span class="line"><span class="comment"># 定义变量</span></span><br><span class="line">data2 = tf.Variable(b,name=<span class="string">"name"</span>)</span><br><span class="line"><span class="comment"># 打印出来的是描述信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有操作要session会话进行</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(data1))  <span class="comment"># 通过会话进行的就可以打印了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有变量都要用session进行初始化</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">sess.run(init)  <span class="comment"># 初始化</span></span><br><span class="line"><span class="comment"># session打印多个内容</span></span><br><span class="line">sess.run([x1,x2,x3])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭session</span></span><br><span class="line"><span class="comment"># 法一</span></span><br><span class="line">sess.close()</span><br><span class="line"><span class="comment"># 法二  with</span></span><br><span class="line"><span class="keyword">with</span> sees:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tensorflow运算的每个类型都要是tensor</span></span><br><span class="line"><span class="comment"># 转换为tensor,如 a=np.arange(1)</span></span><br><span class="line">aa = tf.convert_to_tensor(a,dtye=tf.int32) <span class="comment">#dtype=数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor类型间转换</span></span><br><span class="line">tf.cast(aa,dtype=tf.double)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Variable</span></span><br><span class="line"><span class="comment"># Variable包装过的变量会具有一些特殊的属性,如可导</span></span><br><span class="line">b=tf.Variable(b,name=<span class="string">"name"</span>)</span><br><span class="line">b.name</span><br><span class="line">b.trainable</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor变numpy</span></span><br><span class="line"><span class="comment"># tensor一般在GPU,当有时我们要在CPU上处理默写逻辑时就要转成numpy</span></span><br><span class="line">a.numpy()  <span class="comment"># tensor:a 就变成了numpy</span></span><br></pre></td></tr></table></figure>

<h5 id="创建tensor"><a href="#创建tensor" class="headerlink" title="创建tensor"></a>创建tensor</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a.convert_to_tensor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">tf.zeros(shape)  <span class="comment"># tf.zeros_like(a) 初始化一个和a一样维度的(shape)</span></span><br><span class="line">tf,ones(shape)</span><br><span class="line">tf.fill(shape,elem)</span><br><span class="line">tf.random.normal(shape,mean=<span class="number">1</span>,stddev=<span class="number">1</span>)  <span class="comment"># 用正态分布采样(normal,其他分部同理)初始化一个,其中mean,stddev正太分部的参数,其他分部同理</span></span><br><span class="line">tf.random.truncated_normal(...)  <span class="comment"># 截断的正态分布</span></span><br><span class="line">tf.random.uniform(shape,minval=<span class="number">0</span>,maxval=<span class="number">1</span>)  <span class="comment"># 均匀分布采样</span></span><br><span class="line"><span class="comment"># shape表示维度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打散</span></span><br><span class="line"><span class="comment"># 就是random了,但是如果是两组有一一对应关系的东西,怎么打散才不会破坏那个一一对应关系?</span></span><br><span class="line">idx = tf.range(<span class="number">10</span>)  <span class="comment"># 假设有10组数据</span></span><br><span class="line">idx = rf.random.shuffle(idx)  <span class="comment"># (就好比生成了10组随机的通道(每个通道代表一种一一对应关系)通道两边绑定了,所以对应关系不变)</span></span><br></pre></td></tr></table></figure>

<h5 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引</span></span><br><span class="line"><span class="comment"># numpy风格的索引，如：</span></span><br><span class="line">a.shape() = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a[<span class="number">1</span>,<span class="number">2</span>].shape = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 索引写在一个[]内，用逗号隔开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line"><span class="comment"># 对于某个维度</span></span><br><span class="line">a[<span class="number">-1</span>:]  <span class="comment"># 到数第一个到最后一个,就是python的切片</span></span><br><span class="line"><span class="comment"># 对多个维度的切片</span></span><br><span class="line">a[<span class="number">0</span>,<span class="number">1</span>,:,<span class="number">1</span>:<span class="number">3</span>,:]  <span class="comment"># (取a01的全部的1到3的全部。。。很灵活)</span></span><br><span class="line"><span class="comment"># step,步长.... [::] 同理, 步长为负，实现倒叙</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略号:省略多个:(自动识别)</span></span><br><span class="line">a[<span class="number">1</span>,<span class="number">2</span>,...,<span class="number">0</span>,:]  <span class="comment"># 中间的没有切片操作,但是倒数第二有切片操作,用...就不用人为的把中间的:不上了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Selective Indexing </span></span><br><span class="line"><span class="comment"># 可以乱序取样</span></span><br><span class="line"><span class="comment"># 假设a.shape = [4,32,8] ,a[4个班,35个学生,8门科目成绩]</span></span><br><span class="line">a = tf.gather(a,axis=<span class="number">0</span>,indices=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 1.取样的样本 2.抽取的维度,上面就是从第一个维度中乱序的抽取,随机抽取一个班查看 3.抽取的顺序,抽2班1班3班0班</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还是上面的例子,如果想要取n个学生的m门成绩呢？</span></span><br><span class="line">aa = tf.gather(a,axis=<span class="number">1</span>,indices=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>])  <span class="comment"># 取4个班2，1，3，0号学生</span></span><br><span class="line">aaa = tf.gather(aa,axis=<span class="number">2</span>,indices=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>])  <span class="comment"># 取这4个班2，1，3，0号学生,的2，1，3，0号成绩</span></span><br><span class="line"><span class="comment"># 多个gather嵌套</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tf.gather_nd !!!比较难理解</span></span><br><span class="line">gather_nd(a,[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])  <span class="comment"># 1班1号同学的1号成绩,标量</span></span><br><span class="line">gather_nd(a,[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>]])  <span class="comment"># 0班0号同学的8门成绩,和1班1号同学的8门成绩,组成的矩阵,shape = [2,8] 2个同学,8门成绩</span></span><br><span class="line">gather_nd(a,[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]])  <span class="comment"># shape = [2]</span></span><br><span class="line">gather_nd(a,[[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]]])  <span class="comment"># shape = [1,2]</span></span><br><span class="line"><span class="comment"># 体会标量放[]里和矩阵放[]里的区别,差不多就是这个意思</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tf.boolean_mask</span></span><br><span class="line"><span class="comment"># 通过boolean来取样 假设a.shape = [4,28,28,3]</span></span><br><span class="line">tf.boolean_mask(a,mask=[<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>])  <span class="comment"># 默认从最外层(mask嘛)</span></span><br><span class="line"><span class="comment"># 结果shape = [2,28,28,3]</span></span><br><span class="line"><span class="comment"># 多维遮罩 例:a.shape = [2,3,4]</span></span><br><span class="line">tf.boolean_mask(a,mask=[[<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>],[<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>]])  <span class="comment"># mask.shape=[2,3] 采样的元素取对应关系,根据mask,第0行第一个元素是True，所以要...</span></span><br><span class="line"><span class="comment"># 结果shape = [3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然也可以指定,遮罩哪个维度 </span></span><br><span class="line">tf.boolean_mask(a,mask=[<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>],axis = <span class="number">3</span>)  <span class="comment"># shape = [4,28,28,2]</span></span><br></pre></td></tr></table></figure>

<h5 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.shape = [4,28,28,3]</span></span><br><span class="line">tf.reshape(a,[<span class="number">4</span>,<span class="number">784</span>,<span class="number">3</span>])  <span class="comment"># 4*28*28*3  ==  4*784*3 才能保证所有数据充分利用</span></span><br><span class="line"><span class="comment"># 如果先偷懒的话可以用-1</span></span><br><span class="line">tf.reshape(a,[<span class="number">4</span>,<span class="number">-1</span>,<span class="number">3</span>])  <span class="comment"># 一个式子只能有一个-1,-1就相当于x,保证4*28*28*3 == 4*x*3</span></span><br><span class="line"><span class="comment"># 变换前要理清楚物理含义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵变换,改变格式</span></span><br><span class="line"><span class="comment"># a.shape = [4,3,2,1] </span></span><br><span class="line">tf.transpose(a)  <span class="comment"># 矩阵转置</span></span><br><span class="line">tf.transpose(a,perm=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])  <span class="comment"># 原来的0维放在新的0维...原来的3维放在新的2维...</span></span><br><span class="line"><span class="comment"># 结果 shape = [4,3,1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 维度的增加</span></span><br><span class="line"><span class="comment"># a.shape=[4,35,8]</span></span><br><span class="line">tf.expand_dims(a,axis=<span class="number">0</span>)  <span class="comment"># 插入的(一个)维度相当于插入后维度的第0维,a.shape=[1,4,35,8]</span></span><br><span class="line">tf.expand_dims(a,axis=<span class="number">3</span>)  <span class="comment"># 插入的维度相当于插入后维度的第3维,a.shape=[4,35,8,1]</span></span><br><span class="line"><span class="comment"># 负数同理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 维度减少</span></span><br><span class="line"><span class="comment"># 元素个数为1的维度是可以去掉的,a.shape=[1,2,1,1,3]</span></span><br><span class="line">tf.squeeze(a)  <span class="comment"># 不加axis参数就是把所有1去掉</span></span><br><span class="line">tf.squeeze(a,axis=<span class="number">2</span>)  <span class="comment"># 把第二维度去掉</span></span><br></pre></td></tr></table></figure>

<h5 id="Broadcasting"><a href="#Broadcasting" class="headerlink" title="Broadcasting"></a>Broadcasting</h5><ul>
<li>expand without copying data:扩张了一个数据,但实际上并没有复制出来多份<img src="./static/broadcasting.png" style="zoom:50%">

</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tf.broadcast_to</span><br><span class="line"><span class="comment"># ape=[3,5]</span></span><br><span class="line">aa = broadcast_to(a,[<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line">aa.shape = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如前面的 x@w+b,b是一个一维的，但却能加上去,就是broadcast的功劳</span></span><br><span class="line"><span class="comment"># 如a.shape=[4,16,16,32] b.shape=[32]</span></span><br><span class="line"><span class="comment"># 如果a+b 那么b就会相当于自动变成[4,16,16,32],以满足相应的运算(包括加减乘除</span></span><br><span class="line"><span class="comment"># 先从小维度开始匹配,自动扩张是满足运算</span></span><br><span class="line"><span class="comment"># 但却不会生成4*16*16个b</span></span><br><span class="line"><span class="comment"># 判断方法:右对其,用1把维度补相同,然后把1是维度变成和另一个匹配的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># a.shape=[1,3,4]</span></span><br><span class="line"><span class="comment"># tf.tile(a,[2,1,3]) 第一个维度复制2ci，第二个1次，第三个4次</span></span><br><span class="line"><span class="comment"># a.shape = [2,3,12]</span></span><br></pre></td></tr></table></figure>

<h5 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># element-wise: +-*/</span></span><br><span class="line"><span class="comment"># shape一样，对应元素运算</span></span><br><span class="line"><span class="comment"># (一般的运算,非矩阵...吧)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># matrix-wise: @,matmul</span></span><br><span class="line"><span class="comment"># 如 [b,3,4]@[b,4,5]</span></span><br><span class="line"><span class="comment"># 相当于把后两个当成矩阵然后来运算[3,4]*[4,5] = [3,5]</span></span><br><span class="line"><span class="comment"># 相当于一下子b个矩阵相乘</span></span><br><span class="line"><span class="comment"># (矩阵运算...)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># dim-wise: reduce_mean/max/min/sum</span></span><br></pre></td></tr></table></figure>

<h5 id="手写数字识别-你可能用到"><a href="#手写数字识别-你可能用到" class="headerlink" title="手写数字识别,你可能用到"></a>手写数字识别,你可能用到</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">(xs, ys),_ = datasets.mnist.load_data()</span><br><span class="line">xs = tf.convert_to_tensor(xs, dtype=tf.float32) / <span class="number">255.</span>    <span class="comment"># 除以255是为了优化,这样0&lt;x&lt;1</span></span><br><span class="line">ys = ....  <span class="comment"># 变成tensor</span></span><br><span class="line"></span><br><span class="line">train_db = tf.data.Dataset.from_tenfor_slices((x,y)).batch(<span class="number">128</span>)</span><br><span class="line">train_iter = iter(train_db)</span><br><span class="line">sample = next(train_iter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([<span class="number">784</span>,<span class="number">256</span>]),stddev=<span class="number">0.1</span>)  <span class="comment"># stddev=0.1是为了......</span></span><br><span class="line">b1 = tf.Variable(tf.zeros([<span class="number">256</span>]))   <span class="comment"># 变成tf.Variable才能被Gradient跟踪</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>):   <span class="comment"># 对整个数据集循环,反复使用用一个数据集不断优化</span></span><br><span class="line">	<span class="keyword">for</span> step,(x, y) <span class="keyword">in</span> enumerate(train_db):  <span class="comment"># step,方便记录,查enumerate用法</span></span><br><span class="line">		x = tf.reshape(x,[<span class="number">-1</span>,<span class="number">28</span>*<span class="number">28</span>])</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># 默认只会跟踪tf.Variable的类型</span></span><br><span class="line">			h1 = x@w1 + b1</span><br><span class="line">			h1 = tf.nn.relu(h1)</span><br><span class="line">			...</span><br><span class="line">			out = ...</span><br><span class="line">			</span><br><span class="line">			y_onehot = tf.one_hot(y, depth=<span class="number">10</span>)  <span class="comment"># y:[b] =&gt; [b,10]</span></span><br><span class="line">		</span><br><span class="line">			loss = tf.square(y_onehot - out)</span><br><span class="line">			loss = tf.reduce_mean(loss)</span><br><span class="line">			</span><br><span class="line">		grads = tape.gradient(loss,[w1,b1,w2,b2,w3,b3])</span><br><span class="line">		<span class="comment"># 更新w,b</span></span><br><span class="line">		w1.assign_sub(lr*grads[<span class="number">0</span>])  <span class="comment"># 原地更新,引用不变,类型不变</span></span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> step % <span class="number">100</span> ==<span class="number">0</span>:</span><br><span class="line">			print(float(loss))</span><br></pre></td></tr></table></figure>

<h5 id="合并与拼接"><a href="#合并与拼接" class="headerlink" title="合并与拼接"></a>合并与拼接</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c =tf.concat([a,b],axis=<span class="number">0</span>)   <span class="comment"># a和b第0维度合并</span></span><br><span class="line"><span class="comment"># 在原有维度上累加,不能生成新的维度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要创造新的维度</span></span><br><span class="line"><span class="comment"># a.shape = [4,3,5] b.shape = [4,3,5]</span></span><br><span class="line">c = tf.stack([a,b]axis = <span class="number">1</span>)</span><br><span class="line"><span class="comment"># c.shape = [4,2,3,5]  </span></span><br><span class="line"><span class="comment"># 根据表示意义理解 如[chool,class,student,scores]</span></span><br><span class="line"><span class="comment">### 以上对维度都有要求,有一定的局限性</span></span><br><span class="line"><span class="comment"># 同样用[class,student,scores] 模型举例</span></span><br><span class="line"><span class="comment"># 每个学校，班等都可能不同,stack就操作不了</span></span><br><span class="line"></span><br><span class="line">tf.unstack(a,axis=<span class="number">0</span>)   <span class="comment"># 全部拆开,返回几个tensor取决于有几个</span></span><br><span class="line">tf.unstack(a,axis=<span class="number">3</span>,num_or_size_splits=<span class="number">2</span>)   <span class="comment"># 在指定维度拆开拆开,参数是2所以拆成两个</span></span><br><span class="line">tf.unstack(a,axis=<span class="number">3</span>,num_or_size_splits=[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>])   <span class="comment"># 指定拆开,拆开的低0个有2份,地2个有3份...</span></span><br></pre></td></tr></table></figure>

<h5 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h5><ul>
<li>范数<ul>
<li>二范数<br>$${||x||}_2 = [\sum_k{x^2_k}]^\frac{1}{2}$$  </li>
<li>无穷范数  </li>
<li>一范数..等等<br>$${||x||}_1 = \sum_k{|x_k|}$$  </li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###  这里讨论的都是向量的范数(非矩阵)</span></span><br><span class="line">tf.norm(a)  <span class="comment"># 二范数</span></span><br><span class="line">tf.norm(a,ord=<span class="number">1</span>,axis=<span class="number">1</span>)  <span class="comment"># 一范数,同时把某维度看做整体来做范数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># reduce_mean/min/max</span></span><br><span class="line"><span class="comment"># reduce说明,这操作会有个减维的过程:相当于每组选出了指定的数,那组的大小就成了1</span></span><br><span class="line">tf.reduce_mean(a,axis=<span class="number">1</span>)  <span class="comment"># 2.不指定维度的话会打平成以维度</span></span><br><span class="line"><span class="comment"># 指定了维度就会在指定维度取  $注意,这里讨论的都是向量,不用矩阵来理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 就最大最小值的位置</span></span><br><span class="line"><span class="comment"># a.shape = [4,10]</span></span><br><span class="line">tf.argmax(a)  <span class="comment"># 默认第0维比较,a有10组,所以会返回10个结果[2,3,4..]</span></span><br><span class="line">tf.argmin(a,axis=<span class="number">1</span>)  <span class="comment"># 指定维度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较</span></span><br><span class="line">tf.equal(a,b) <span class="comment"># 返回[True,False,True,...]</span></span><br><span class="line"><span class="comment"># 准确度:把上面的返回结果dtype成0,1然后累加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tf.unique</span></span><br><span class="line">tf,unique(a)</span><br><span class="line"><span class="comment"># 返回两个值,第一个是无重复值的tensor,第二个是tensor是值表示原tensor的元素在新tensor中的位置</span></span><br><span class="line"><span class="comment"># 这么一来可以用tf.gather来吧原tensor还原出来</span></span><br></pre></td></tr></table></figure>

<h5 id="张量排序"><a href="#张量排序" class="headerlink" title="张量排序"></a>张量排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tf.sort(a,direction=<span class="string">'DESCENDING'</span>)  <span class="comment"># 降序,  direction='ASCENDING'就能升序</span></span><br><span class="line">tf.argsort(a,direction=<span class="string">'DESCENDING'</span>)  <span class="comment"># 降序,返回的是位置:如[最大值位置，次大..]</span></span><br><span class="line"><span class="comment"># 同理可与gather配合</span></span><br><span class="line"><span class="comment"># 高维的话就按每维排列完全排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但有时候我们只需要最大最小(不用完全排序,耗时)</span></span><br><span class="line">res = tf.max.top_k(a,<span class="number">2</span>)  <span class="comment"># 返回最大的两个</span></span><br><span class="line">res.indices   <span class="comment"># 返回索引值,像argsort</span></span><br><span class="line">res.values  <span class="comment"># 返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用</span></span><br><span class="line"><span class="comment"># 预测问题:0,1,2,3的预测分别是 prob[0.1,0.2,0.3,0.4]</span></span><br><span class="line"><span class="comment"># 真实值是2</span></span><br><span class="line"><span class="comment"># top-1 prediction(正确答案在前1个的概率):0%   (预测对的样本个数/总样本数(这了只用应该样本)) </span></span><br><span class="line"><span class="comment"># top-2 prediction(正确答案在前2个的概率):100% </span></span><br><span class="line"><span class="comment"># top-3 prediction(正确答案在前3个的概率):100% </span></span><br><span class="line"><span class="comment"># 举例</span></span><br><span class="line"><span class="comment"># prob = tf.constant([[0.1,0.2,0.7],[0.2,0.7,0.1]]) #样本1最可能是2,样本2最可能是1</span></span><br><span class="line"><span class="comment"># target = tf.constant([2,0])  # 样本1正式值应该是2，样本2真实值应该是0</span></span><br><span class="line"><span class="comment"># 所以: top-1 prediction=1/2  = 50%</span></span><br><span class="line"><span class="comment"># top-2 prediction = 2/2 = 100%</span></span><br><span class="line"><span class="comment"># top-3 prediction = 2/2 = 100%</span></span><br></pre></td></tr></table></figure>

<h5 id="填充与复制"><a href="#填充与复制" class="headerlink" title="填充与复制"></a>填充与复制</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 填充 pad</span></span><br><span class="line">tf.pad(a,[[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]])  <span class="comment"># 行上边边填充2行下边0行;列左0右1</span></span><br><span class="line"><span class="comment">#          ^行  ^列  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 tile</span></span><br><span class="line"><span class="comment"># a.shape = [3,3]</span></span><br><span class="line">tf.tile(a,[<span class="number">1</span>,<span class="number">2</span>])  <span class="comment"># 第一维复制一次(不变),第二维复制2次 </span></span><br><span class="line"><span class="comment"># res.shape = [3,6]</span></span><br><span class="line"><span class="comment"># 会真实的复制到内存</span></span><br></pre></td></tr></table></figure>

<h5 id="张量的限幅"><a href="#张量的限幅" class="headerlink" title="张量的限幅"></a>张量的限幅</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制最小值</span></span><br><span class="line">tf.maximum(a,<span class="number">2</span>)  <span class="comment"># 返回a,2间的最大值,故a不会小于2,限制的最小值</span></span><br><span class="line"><span class="comment"># 限制最大值</span></span><br><span class="line">tf.minimum(a,<span class="number">8</span>)  <span class="comment"># 返回a,8间的最小值 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制范围</span></span><br><span class="line">tf.clip_by_value(a,<span class="number">2</span>,<span class="number">8</span>)  <span class="comment"># 2&lt;x&lt;8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># relu函数,x小于0时取0，大于0是取本身</span></span><br><span class="line"><span class="comment"># 可用maximum(a,0)实现</span></span><br><span class="line"><span class="comment"># 也可用封装好的relu函数</span></span><br><span class="line">tf.relu(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等比例放缩,希望把grad缩小方便学习,但又不希望改变gred值</span></span><br><span class="line"><span class="comment"># 可用除以模再乘以一个值来控制范围来,也可用函数</span></span><br><span class="line">tf.clipe_by_norm(a,<span class="number">15</span>)  <span class="comment"># 相当于除模后乘15,改变了a的模</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gradient Exploding 梯度太大,一步学习跨越太大,来回震荡</span></span><br><span class="line"><span class="comment"># Gradient Vanishing 梯度太小,学习太慢，长时间没有变化</span></span><br><span class="line"><span class="comment"># tf.clipe_by_global_norm(grads,25)  # 整体缩放,避免方向改变</span></span><br><span class="line"><span class="comment"># 梯度向量表示[2,5,3],那么整体缩小就不会改变方向</span></span><br></pre></td></tr></table></figure>

<h5 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选 mask = [True,False,True]</span></span><br><span class="line">tf.where(mask)  <span class="comment"># 没有参数,返回tensor中值是True的值的对应坐标tensor</span></span><br><span class="line">tf.where(mask,A,B)  <span class="comment"># True时对A采样,False时对B采样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有目的性的更新</span></span><br><span class="line">tf.scatter_nd(indices,updates,shape) </span><br><span class="line"><span class="comment"># 1.只能在全0的底板上更新,就是上面的shape</span></span><br><span class="line"><span class="comment"># 2.indices表示要更新的位置,把对应位置上updates的值更新过去</span></span><br><span class="line"><span class="comment"># 一般用作给指定位置加减(因为只能全0为底板)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速生成坐标轴系(GPU加速的,区别于传统for循环的)</span></span><br><span class="line">point_x,point_y = tf.meshgrid(x,y)</span><br><span class="line"><span class="comment"># 返回两个值,个存取x的所有值和y的所有值</span></span><br><span class="line"><span class="comment"># 对应位置的祝贺就是(x,y) </span></span><br><span class="line"><span class="comment"># 重新组合: tf.stack([point_x,point_y],axis=2)</span></span><br></pre></td></tr></table></figure>

<h4 id="神经网络与全连接层"><a href="#神经网络与全连接层" class="headerlink" title="神经网络与全连接层"></a>神经网络与全连接层</h4><h5 id="数据集的加载-小型"><a href="#数据集的加载-小型" class="headerlink" title="数据集的加载(小型)"></a>数据集的加载(小型)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据集准备</span></span><br><span class="line">(x,y),(x_test,y_test) = keras.datasets.mnist.load_data()  <span class="comment"># 获取mninst数据集,返回各有不同</span></span><br><span class="line"><span class="comment"># 返回的是numpy的格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将numpy转换成对象</span></span><br><span class="line">db = tf.data.Dataset.from_tenfor_slices(x_test,y_test)</span><br><span class="line">next(iter(db))[<span class="number">0</span>].shape  <span class="comment"># 转换成对象后就可进行的一系列操作,支持多线程等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打散</span></span><br><span class="line">db = db.shuffle(<span class="number">10000</span>)  <span class="comment"># 打散,但x和y的对应关系不打撒(gather),参数?给大点就是了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">db2 = db.map(func)  <span class="comment"># 对db里的每个元素进行func里的操作</span></span><br><span class="line"><span class="comment"># 如每个元素是(x,y),func函数的参数的x,y返回的是处理后的x,y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># batch</span></span><br><span class="line">db3 = db2.batch(<span class="number">42</span>)  <span class="comment"># 不再一次读取一组数据,一次读取指定数量的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复迭代</span></span><br><span class="line">db4 = db3.repeat(<span class="number">2</span>)  <span class="comment"># 重复迭代2次</span></span><br><span class="line">db4 = db3.repeat()  <span class="comment"># 无限重复</span></span><br></pre></td></tr></table></figure>

<h5 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个节点跟每个节点连接——Dense</span></span><br><span class="line">x = tf.random.normal([<span class="number">4</span>,<span class="number">728</span>])  <span class="comment"># 输入</span></span><br><span class="line">net = tf.keras.layers.Dense(<span class="number">512</span>)  <span class="comment"># 创建输出512的层</span></span><br><span class="line">out = net(x)  <span class="comment"># out.shape = [4,512]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多层嵌套——Multi-Layers</span></span><br><span class="line"><span class="comment"># keras.Sequential([layer1,layer2,...])  # layer-&gt;Dense</span></span><br><span class="line">network = keras.Sequential([</span><br><span class="line">        keras.layers.Dense(<span class="number">2</span>,activation=<span class="string">'relu'</span>),</span><br><span class="line">        keras.layers.Dense(<span class="number">2</span>,activation=<span class="string">'relu'</span>),</span><br><span class="line">        keras.layers.Dense(<span class="number">2</span>)</span><br><span class="line">    ])</span><br><span class="line">network.build(input_shape=[<span class="literal">None</span>,<span class="number">3</span>])  <span class="comment"># 创建，给定输入维度3</span></span><br><span class="line">network.summary()   <span class="comment"># 打印信息</span></span><br><span class="line">network.trainable_variables   <span class="comment"># list[],可训练参数</span></span><br></pre></td></tr></table></figure>

<h5 id="输出方式"><a href="#输出方式" class="headerlink" title="输出方式"></a>输出方式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出范围压缩</span></span><br><span class="line"><span class="comment"># sigmod函数(同理relu)</span></span><br><span class="line">y = tf.sigmod(x)   <span class="comment"># x属于R,y属于[0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tanh函数,压缩范围到[-1,1]</span></span><br><span class="line">tf.tanh(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出概率(所有的和为1)</span></span><br><span class="line"><span class="comment"># softmax函数</span></span><br><span class="line">tf.softmax(a)</span><br></pre></td></tr></table></figure>

<h5 id="损失函数的计算"><a href="#损失函数的计算" class="headerlink" title="损失函数的计算"></a>损失函数的计算</h5><ul>
<li>MSE<br>$$loss=\frac{1}{N}\sum(y-out)^2$$<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss1 = tf.reduce_mean(tf.square(y-out))</span><br><span class="line">loss2 = tf.reduce_mean(tf.losses.MSE(y,out))</span><br><span class="line"><span class="comment"># loss1 = loss2 等价</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="标差熵"><a href="#标差熵" class="headerlink" title="标差熵"></a>标差熵</h5><ul>
<li>熵 $Entropy = -\sum P(i)\log_2{P(i)}$<ul>
<li>不确定度 Uncertainty</li>
<li>惊奇度 measure of surprise</li>
<li>lower entropy -&gt; more info</li>
</ul>
</li>
</ul>
<h5 id="交叉熵-Cross-Entropy"><a href="#交叉熵-Cross-Entropy" class="headerlink" title="交叉熵 Cross Entropy"></a>交叉熵 Cross Entropy</h5><ul>
<li><p>描述两个集合p,q的惊奇度</p>
<ul>
<li>$H(p,q) = -\sum{p(x) \log_2{q(x)}}$</li>
<li>$H(p,g) = H(p) + D(p|q)$ <ul>
<li>$D(p|q)$ 表示p和q的离散度</li>
<li>当p=q时$D(p|q)=0$</li>
</ul>
</li>
</ul>
</li>
<li><p>for p:one_hot encoding</p>
<ul>
<li>$h(p:[0,1,0]) = -1\log_2{1}=0$</li>
<li>$H([0,1,0],[q_1,q_2,q_3]) = 0+D(p|q)=-1\log{q_1}$</li>
<li>即要使p逼近与q用交叉熵的方法的可行的  </li>
</ul>
</li>
<li><p>具体解法<br>设一组分类的one_hot encoding是$P_1[1,0,0,0,0]$;<br>一组输出为$Q_1[0.4,0.3,0.05,0.05,0.5]$;<br>则:</p>
</li>
</ul>
<p>$$\begin{aligned}<br>loss &amp;= H(p,q) \<br>&amp;= -\sum{P_1(x) \log_2{Q_1(x)}} \<br>&amp;= -\log_2{0.4}  \<br>&amp;= 0.916<br>\end{aligned}<br>$$</p>
<p>然后lr,w1,b2…,多次学习后发现loss越来越小,即q = p  </p>
<ul>
<li>在tensorflow中的使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tf.losses.categorical_crossentropy(p,q) <span class="comment"># 函数的形式</span></span><br><span class="line">tf.losses.BinaryCrossentropy()(p,q)  <span class="comment"># 类的形式</span></span><br><span class="line">tf.losses.binary_crossentropy(p,q) <span class="comment"># 函数的形式 </span></span><br><span class="line"><span class="comment"># p是真实在的one_hot encodingq是预测值</span></span><br><span class="line"><span class="comment"># 如tf.losses.categorical_crossentropy([1,0,0,0],[0.25,0.25,0.25,0.25])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 通常的用法 ###</span></span><br><span class="line">tf.losses.categorical_crossentropy(one_hot,logits,from_logits=<span class="literal">True</span>)  <span class="comment"># 这样能处理logits转换成prob时的错误</span></span><br><span class="line">tf.losses.categorical_crossentropy(one_hot,prob)  <span class="comment"># 等价但不推荐</span></span><br></pre></td></tr></table></figure>


<h3 id="梯度下降-Gradient-Descent"><a href="#梯度下降-Gradient-Descent" class="headerlink" title="梯度下降 Gradient Descent"></a>梯度下降 Gradient Descent</h3><ul>
<li>梯度:向量grad<ul>
<li>用梯度下降来逼近<br>$$ w_n = w - lr \times \frac{\partial{loss}}{\partial{w}} $$</li>
</ul>
</li>
<li>在tensorflow中的使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:  <span class="comment"># 把计算过程包在里面</span></span><br><span class="line">    tape.watch([w,b])  <span class="comment"># 如果参数不是tf.variable类型话要用这个函数声明</span></span><br><span class="line">    loss = f(x)</span><br><span class="line">[w_grad] = tape.gradient(loss,[w])  <span class="comment"># 自动求解参数的梯度,并返回相应的列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tape.gradient调用一次后会把资源释放掉,可用参数persistent改变</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape(persistent=<span class="literal">True</span>) <span class="keyword">as</span> tape:  <span class="comment"># 用完后会保留资源</span></span><br><span class="line">grad1 = tape.gradient(loss,[w]) </span><br><span class="line">grad2 = tape.gradient(loss,[w])  <span class="comment"># 可调用多次</span></span><br><span class="line"><span class="comment"># 但要记得手动释放资源！！！</span></span><br></pre></td></tr></table></figure>


<h4 id="激活函数-Activation-Function"><a href="#激活函数-Activation-Function" class="headerlink" title="激活函数 Activation Function"></a>激活函数 Activation Function</h4><p>科学家在研究青蛙神经是发现，当刺激到达一定程度是青蛙才会做出相应的反应，是个离散的过程<br>因此在深度学习中就可模仿设点，设计神经网络，因此有了激活函数  </p>
<p>连续的光滑的激活函数</p>
<ul>
<li><strong>sigmoid(logistic)</strong><ul>
<li>$f(x)=\delta(x)=\frac{1}{1+e^{-x}}$</li>
<li><code>y = tf.sigmoid(a)</code></li>
<li>可以将范围压缩到[0,1]</li>
<li>但当x接近无穷时，导数几乎为零，导致梯度离散，使得长期得不到更新</li>
</ul>
</li>
<li><strong>Tanh</strong><ul>
<li>$f(x)=tanh(x)=\frac{(e^x-e^{-x})}{e^x+e^{-x}}=2sigmoid(2x)-1$</li>
<li><code>y = tf.tanh(a)</code></li>
</ul>
</li>
<li><strong>ReLU(Rectified Linear Unit)</strong><ul>
<li>$<br>f(x) = \begin{cases}<br>0, &amp; \text{if } x &lt; 0  \<br>x, &amp; \text{if } x \geq 0<br>\end{cases}<br>$</li>
<li><code>tf.nn.relu()</code></li>
<li>深度学习最常用的<ul>
<li>优势</li>
<li>求导简单</li>
<li>不会放大或缩小梯度(reLU的导数为1)</li>
</ul>
</li>
</ul>
</li>
<li><strong>Softmax</strong><ul>
<li>$S(y_i)=\frac{e^{y_i}}{\sum_j{e^{y_i}}}$</li>
<li>常用于多分类问题，因为它把logits转换为prob</li>
<li>区别于一般的转换成prob的方法，Softmax会把大的放大，小的缩小；拉大差距(sotf version of max)</li>
<li>求导:把先把分子分母看做整体<code>f(x)和g(x)</code>然后相当于$\frac{\partial p_i}{\partial a_j}=\frac{f’(x)g(x)-f(x)g’(x)}{g(x)^2}$;注意i和j不同的情况要分开讨论<ul>
<li>$$<br>  \frac{\partial p_i}{\partial a_j} = \begin{cases}<br>  p_i(1-p_1), &amp; \text{if } i=j  \<br>  -p_jp_i, &amp; \text{if } i\neq j<br>  \end{cases}<br>$$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Loss函数的梯度"><a href="#Loss函数的梯度" class="headerlink" title="Loss函数的梯度"></a>Loss函数的梯度</h4><p>经典的loss函数</p>
<ul>
<li>Mean Squared Error(MSE,均方差)<ul>
<li>$loss=\frac{1}{N}\sum(y-out)^2$</li>
<li><code>loss1 = tf.reduce_mean(tf.square(y-out))</code></li>
<li><code>loss2 = tf.reduce_mean(tf.losses.MSE(y,out))</code></li>
</ul>
</li>
<li>Cross Entropy Loss<ul>
<li>Softmax</li>
</ul>
</li>
</ul>
<h4 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h4><p>$\frac{\partial y}{\partial x} = \frac{\partial y}{\partial u}\frac{\partial u}{\partial x}$</p>
<h4 id="感知机梯度传导"><a href="#感知机梯度传导" class="headerlink" title="感知机梯度传导"></a>感知机梯度传导</h4><p>利用链式法则从输出往输入退就可以知道梯度信息，然后更新  </p>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><ul>
<li>tensorboard<ul>
<li><code>pip install tensorboard</code></li>
<li>在代码中写入<code>summary_writer = tf.summary.create_file_writer(DIR)</code></li>
<li>拿到<code>summary_writer</code>后就可以忘里面喂数据</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1,喂数据点</span></span><br><span class="line"><span class="keyword">with</span> summary_writer.as_default():</span><br><span class="line">    tf.summary.scalar(<span class="string">'NAME1'</span>, float(LOSS), step=STEP)  <span class="comment"># (图的名字,数据,坐标(默认是x轴))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2,喂一个图片</span></span><br><span class="line"><span class="keyword">with</span> summary_writer.as_default():</span><br><span class="line">    tf.summary.image(<span class="string">'NAME1'</span>, IMG, step=STEP)  <span class="comment"># (图的名字,数据,坐标(默认是x轴))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3,给多个图片</span></span><br><span class="line"><span class="comment"># 最好的办法是认为的拼接图片,然后传一张拼接的图片(google)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>visdom </li>
</ul>
<h2 id="Keras高层API"><a href="#Keras高层API" class="headerlink" title="Keras高层API"></a>Keras高层API</h2><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在计算loss,accuracy的时候经常会发现数据忽高忽低,所以可借助keras的api来优化</p>
<ul>
<li>metrics测量<ul>
<li>keras会将数据放在一个list,然后取平均值来优化?</li>
<li>如<code>loss_meter = metrics.Mean()</code>,<code>acc_meter = metrics.Accuracy()</code></li>
</ul>
</li>
<li>update_state更新数据<ul>
<li><code>loss_meter.update_state(loss)</code>,<code>acc_meter.update_state(y, pred)</code></li>
</ul>
</li>
<li>result().numpy()获取结果,转换成numpy输出<ul>
<li><code>loss_meter.result().numpy()</code>result得到tensor，再转换成numpy</li>
</ul>
</li>
<li>reset_states释放数据<ul>
<li>当要废弃旧的数据时<code>loss_meter.reset_states()</code></li>
</ul>
</li>
</ul>
<h4 id="Compile-amp-Fit"><a href="#Compile-amp-Fit" class="headerlink" title="Compile&amp;Fit"></a>Compile&amp;Fit</h4><ul>
<li>Compile,类似装载弹药,可以指定loss,优化器,评估指标</li>
<li>Fix,完成标准创立</li>
<li>Evaluate,测试</li>
<li>Predic,拿创建好的模型来预测</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 一般的流程</span></span><br><span class="line">epoch <span class="keyword">in</span> range(num):</span><br><span class="line">    <span class="keyword">for</span> step, (x, y) <span class="keyword">in</span> enumerate(db):</span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:   <span class="comment"># 循环网络</span></span><br><span class="line">            <span class="comment"># [b, 784] =&gt; [b, 10]</span></span><br><span class="line">            logits = model(x)</span><br><span class="line">            y_onehot = tf.one_hot(y, depth=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            loss_ce = tf.losses.categorical_crossentropy(y_onehot, logits, from_logits=<span class="literal">True</span>)</span><br><span class="line">            loss_ce = tf.reduce_mean(loss_ce)</span><br><span class="line"></span><br><span class="line">        grads = tape.gradient(loss_ce, model.trainable_variables)    <span class="comment"># 更新</span></span><br><span class="line">        optimizer.apply_gradients(zip(grads, model.trainable_variables))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:   </span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> (x_test, y_test) <span class="keyword">in</span> test_db:    <span class="comment"># 测试</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 使用Keras的api快速建立标准化的神经网络</span></span><br><span class="line"><span class="comment"># 称network或model</span></span><br><span class="line">network = Sequential([...])   <span class="comment"># 如果是别的没学到的话...</span></span><br><span class="line">network.compile(</span><br><span class="line">        optimizer=optimizers.Adam(lr=<span class="number">0.01</span>),    <span class="comment"># 指定优化器</span></span><br><span class="line">        loss=tf.loss.CategoricalCrossentropy(from_logits=<span class="literal">True</span>),   <span class="comment"># 指定loss函数</span></span><br><span class="line">        metrics=[<span class="string">'accuracy'</span>]     <span class="comment"># 指定测试标准</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">network.fit(</span><br><span class="line">        db,   <span class="comment"># 要训练的数据集</span></span><br><span class="line">        epochs=<span class="number">10</span>,    <span class="comment"># 训练的周期</span></span><br><span class="line">        validation_data=db_test,    <span class="comment"># 用于做测试的数据集,一般写作ds_val</span></span><br><span class="line">        validation_freq=<span class="number">2</span>    <span class="comment"># 测试的周期,如这里一共10个epochs,每2个epochs就进行一次测试</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">network.evaluate(ds_val)    <span class="comment"># 训练完后对模型的评估,传入一个数据集</span></span><br><span class="line"></span><br><span class="line">pred = network(x)</span><br><span class="line"><span class="comment"># 或 pred = network.predict(x)    预测</span></span><br></pre></td></tr></table></figure>


<h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><ul>
<li>keras.Sequential(layer1, layer2, …)<ul>
<li>参数要继承自<code>keras.layers.Layer()</code></li>
<li>建立好网络后variable(w和b)是没有的<ul>
<li>法1:指定输入shape<code>network.build(input_shape=(None, 28*28))</code></li>
<li>法2:自动识别<code>network(x)</code><ul>
<li>这个的原理是调用了类中的call()方法,相当于network.<strong>call</strong>(x)。同理自定义类中也可如此</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>keras.layers.Layer()<ul>
<li>任何要自定义的层要继承自它</li>
</ul>
</li>
<li>keras.Model()<ul>
<li>compile/fit/evaluate</li>
<li>Sequential也是继承自该类，所以自定义的网络应该继承这个</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDense</span><span class="params">(layers.Layer)</span>:</span>    <span class="comment"># 自定义层继承</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp_dim, outp_dim)</span>:</span></span><br><span class="line">        super(MyDense, self).__init__() </span><br><span class="line">        self.kernel = self.add_weight(<span class="string">'name1'</span>, [inp_dim, outp_dim])   <span class="comment"># 用母类的add_weight而不是用tf.variable</span></span><br><span class="line">        self.bias = self.add_weight(<span class="string">'name2'</span>, [outp_dim])    <span class="comment"># name是给母类管理用的</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, training=None)</span>:</span></span><br><span class="line">        out = inputs @ self.kernel + self.bias</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比</span></span><br><span class="line">layers.Dense(<span class="number">256</span>, activation=tf.nn.relu),</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同理Model自定义方法也一样</span></span><br></pre></td></tr></table></figure>

<h4 id="模型的加载与保持"><a href="#模型的加载与保持" class="headerlink" title="模型的加载与保持"></a>模型的加载与保持</h4><ul>
<li>save/load weights<ul>
<li>只保存模型参数</li>
<li>缺点是没有源代码，网络不得而知</li>
</ul>
</li>
<li>save/load entire model<ul>
<li>简单粗暴的</li>
</ul>
</li>
<li>saved_model <ul>
<li>通用的保存格式</li>
</ul>
</li>
</ul>
<p><strong>save/load weights</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save</span></span><br><span class="line">model.save_weights(<span class="string">'PATH'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">model = create_model()    <span class="comment"># 需要人工创建网络</span></span><br><span class="line">model.load_weights(<span class="string">'PATH'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>save/load entire model</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save</span></span><br><span class="line">model.save(<span class="string">'PATH'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">model = tf.keras.models.load_model(<span class="string">'PATH'</span>)  <span class="comment"># 不需要人工创建网络</span></span><br></pre></td></tr></table></figure>

<p><strong>saved model</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save</span></span><br><span class="line">tf.saved_model.saved(model, <span class="string">'PATH'</span>)   <span class="comment"># 标准的，可供其他模型使用的保存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">imported = tf.saved_model.load(path)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原除网络</span></span><br><span class="line">f = imported.signature[<span class="string">'serving_defaut'</span>]</span><br></pre></td></tr></table></figure>



<h3 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h3><p>现实情况是我们并不知道模型的符合什么分布  </p>
<ul>
<li>model capacity,模型的学习能力<ul>
<li>显然项越多越高</li>
</ul>
</li>
<li>underfitting<ul>
<li>模型的表达能力弱于真实数据，如用直线拟合双曲线</li>
</ul>
</li>
<li>overfitting<ul>
<li>模型的表达能力大于真实数据，把不必要的噪声也拟合进来了</li>
<li>最常见</li>
</ul>
</li>
</ul>
<h4 id="检查overfitting"><a href="#检查overfitting" class="headerlink" title="检查overfitting"></a>检查overfitting</h4><h5 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h5><p>检查欠拟合和过拟合的方法   </p>
<p>一般情况下会把数据集切分(splitting)成三份,作用分别是train set，val set，test set<br>数据集一部分用来训练，一部分用来验证accuracy这是是显然的，那为什么有第三份呢？<br>因为在真实的需求中，是不是有取巧的人会把test用的数据集也用来训练，从而过拟合来达到很高的准确度(但实际它们已经过拟合了)<br>所以第三份是用来防止这种情况发生的，不参与训练的，最终检验模型的数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">network.compile(</span><br><span class="line">        optimizer=optimizers.Adam(lr=<span class="number">0.01</span>),   </span><br><span class="line">        loss=tf.loss.CategoricalCrossentropy(from_logits=<span class="literal">True</span>),   </span><br><span class="line">        metrics=[<span class="string">'accuracy'</span>]   </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">network.fit(</span><br><span class="line">        db,    <span class="comment"># training</span></span><br><span class="line">        epochs=<span class="number">10</span>,</span><br><span class="line">        validation_data=db_test,   <span class="comment"># val set</span></span><br><span class="line">        validation_freq=<span class="number">2</span>   </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">network.evaluate(ds_val)   <span class="comment"># test set</span></span><br></pre></td></tr></table></figure>

<h5 id="K-fold-cross-validation"><a href="#K-fold-cross-validation" class="headerlink" title="K-fold cross-validation"></a>K-fold cross-validation</h5><p>由上面知，test set是完全不能动的，所以在切分的时候train set和val set可以随机的切分，可以防止网络记忆特性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在tensorflow中可以表现为</span></span><br><span class="line">shuffle(db)  <span class="comment"># 打散</span></span><br><span class="line">splices()   <span class="comment"># 切割</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可用keras的功能</span></span><br><span class="line">network.fit(db, validation_split=<span class="number">0.1</span>)   <span class="comment"># 按照9:1随机切分</span></span><br></pre></td></tr></table></figure>

<h4 id="减轻overfitting"><a href="#减轻overfitting" class="headerlink" title="减轻overfitting"></a>减轻overfitting</h4><h5 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h5><ul>
<li>L1-regularization<ul>
<li>loss加上lambda约束的一范式</li>
<li>$j(\theta) = -\sum^m_1{y_i\log_e{\bar y_i} + (1-y_i)\log_e{(1-\bar y_i)}} + \lambda \sum_i^n{|\theta_i|}$</li>
</ul>
</li>
<li>L2-regularization<ul>
<li>loss加上lambda约束的一范式</li>
<li>$J(W;x,y)+\frac{1}{2} \times ||W||^2$</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 法一：在一层网络中添加kernel_regularizer参数</span></span><br><span class="line">keras.layers.Dense(<span class="number">16</span>,</span><br><span class="line">                    kernel_regularizer=keras.regularizers.L2(<span class="number">0.001</span>)   <span class="comment"># 0.001就是 lambda</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 法二：更加灵活的自己控制范式</span></span><br><span class="line">loss_regularization = []   </span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> network.trainable_variables:     <span class="comment"># 取范式里面的参数w1,w2...b1,b2...取法很灵活</span></span><br><span class="line">    loss_regularization.append(tf.nn.l2_loss(p))</span><br><span class="line">loss_regularization = tf.reduce_sum(tf.stack(loss_regularization))  <span class="comment"># 做一范式还是二范数...</span></span><br><span class="line"></span><br><span class="line">loss = loss + <span class="number">0.0001</span>*loss_regularization</span><br></pre></td></tr></table></figure>

<h4 id="动量与学习率"><a href="#动量与学习率" class="headerlink" title="动量与学习率"></a>动量与学习率</h4><h5 id="Momentum-动量"><a href="#Momentum-动量" class="headerlink" title="Momentum 动量"></a>Momentum 动量</h5><p>由于梯度的更新，会有大幅的反复跳跃的现象，动量就是在更新方向的基础上结合上一阶段的方向进行梯度更新，从而使得更平缓，像踩刹车一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimizer = SGD(learing_rate=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>)   <span class="comment"># momentum 就在超参数lambda</span></span><br><span class="line">optimizer = RMSprop(learing_rate=<span class="number">0.02</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">optimizer = Adam(learing_rate=<span class="number">0.02</span>,   <span class="comment"># Adam没有momentum(内置),但有beta_1,beta_2</span></span><br><span class="line">        beta_1=<span class="number">0.9</span>,</span><br><span class="line">        beta_2=<span class="number">0.999</span>)</span><br></pre></td></tr></table></figure>

<h5 id="Learning-rate-学习率"><a href="#Learning-rate-学习率" class="headerlink" title="Learning rate 学习率"></a>Learning rate 学习率</h5><p>学习率动态调整来优化网络</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">optimizer = SGD(learing_rate=<span class="number">0.02</span>)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># get loss</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># change learing_rate 比较简单粗暴</span></span><br><span class="line">    optimizer.learing_rate = <span class="number">0.2</span>*(<span class="number">100</span>-epoch)/<span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># update weights</span></span><br></pre></td></tr></table></figure>

<h4 id="Early-Stopping-amp-Dropout"><a href="#Early-Stopping-amp-Dropout" class="headerlink" title="Early Stopping &amp; Dropout"></a>Early Stopping &amp; Dropout</h4><h5 id="Early-Stopping"><a href="#Early-Stopping" class="headerlink" title="Early Stopping"></a>Early Stopping</h5><p>很多情况下虽然training accuracy还在上升，但是validation accuracy以及达到最优甚至开始下降了，这是就需要以前终止</p>
<h5 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h5><p>和overfitting的情况一样，为减少噪声的干扰，可以减少节点数(?矩阵里面的?),learning less to learning better</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network = Sequential([layers.Dense(<span class="number">256</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">                      layers.Dropout(<span class="number">0.5</span>),    <span class="comment"># 0.5 rate to dropout</span></span><br><span class="line">                      layers.Dense(<span class="number">256</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">                      layers.Dropout(<span class="number">0.5</span>),    <span class="comment"># 0.5 rate to dropout</span></span><br><span class="line">                      ...</span><br><span class="line">                    ])</span><br></pre></td></tr></table></figure>
<p>因为training和test的策略不同(training时为得到更好的w,b，而使用dropout的方法来减小overfitting,所以开启dropout，test是测试模型，所以不用开)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># training</span></span><br><span class="line">network(x, training=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># validation || test</span></span><br><span class="line">network(x, training=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h5 id="Stochastic"><a href="#Stochastic" class="headerlink" title="Stochastic"></a>Stochastic</h5><h5 id="Deterministic"><a href="#Deterministic" class="headerlink" title="Deterministic"></a>Deterministic</h5><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>在处理图像问题时，使用全连接的方式会导致大量的资源占用.<br>于是由生物学上眼睛可视域的启发，我们采用局部连接，然后滑动直至扫描全部输入。特点在于对于相同的层如(RGB),每次扫描的观察方式(卷积核)是一样的(weight sharing)<br>所以学习的时候就大大减少了参数量  </p>
<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>信号的叠加叫做卷积,得到的结果叫做<strong>feature map</strong>  </p>
<p>$$<br>y(t)=x(t) * h(t)=\int^\infty _ {-\infty}  x(\tau)h(t-\tau)\mathrm{d}x<br>$$</p>
<p>* 表示卷积操作,x就相当于输入,h就相当于观察方式(卷积核),t就相当偏移量，扫过整个图片t发生改变x和h卷积出信号输出y</p>
<h4 id="Padding-amp-Stride"><a href="#Padding-amp-Stride" class="headerlink" title="Padding &amp; Stride"></a>Padding &amp; Stride</h4><ul>
<li>Padding<ul>
<li>把输入层扩大(虚的)然后扫描后就能得到维度与输入相等的输出</li>
</ul>
</li>
<li>Stride<ul>
<li>把扫描的步长加大，就能减少输出的维度</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layers.Conv2D(<span class="number">4</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="string">'samd'</span>)  <span class="comment"># 卷积核个数,5*5,步长,'same'可以保证输入维度等于输出</span></span><br></pre></td></tr></table></figure>

<h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><ul>
<li>设输入是[1, 32, 32, 3],32*32的图片,3个通道<ul>
<li>那我们的一个卷积核可以是[3, 5, 5] 3表示输入通道的数量(RGB)</li>
<li>最后可以得到一个[b, 30, 30, 1]的输出</li>
</ul>
</li>
<li>如果使用多个核如[N, 3, 5, 5]那就能得到N个[b, 30, 30, 1]即[b, 30, 30, N]</li>
</ul>
<p>多通道输出，多通道输入</p>
<h4 id="Gradient"><a href="#Gradient" class="headerlink" title="Gradient"></a>Gradient</h4><p>$$<br>O _ {mn} = \sum {x _ {ij} * w _ {ij}} + b  \<br>\frac{\delta Loss}{\delta w _ {ij}}<br>$$</p>
<h3 id="Classic-Network"><a href="#Classic-Network" class="headerlink" title="Classic Network"></a>Classic Network</h3><h4 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h4><p>When the network get deeper, above 20, is get harder to training, even make trains revoke.</p>
<h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p>Residual</p>
<h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><p>Signal with time order</p>
<ul>
<li>sequence embed<ul>
<li>turn digital signal into a sequence</li>
</ul>
</li>
</ul>
<p>Many sets can be like a sequence. mnist for example[b, 28, 28]. can expand like [b, time, 28] or [time, b, 28] and so on.</p>
<p>But a sequence better to expand like a time orde things [time, b, 28] is much better. It depend on how you expand.</p>
<p>Here are some rules:</p>
<ul>
<li>semantic similarity</li>
<li>trainable</li>
</ul>
<h3 id="Cycle-network"><a href="#Cycle-network" class="headerlink" title="Cycle network"></a>Cycle network</h3><p>Two question:</p>
<ul>
<li><p>Long sentence</p>
<ul>
<li>weight sharing</li>
<li>We can do like a conv_net</li>
</ul>
</li>
<li><p>Context information</p>
<ul>
<li>It is a pertinence bettween word and word</li>
<li>Here is the example formulation</li>
</ul>
</li>
</ul>
<p>$$\begin{aligned}<br>h_t &amp;= f_w(h_{t-1}, x_t) \<br>h_t &amp;= tanh(W_{hh}h_{t-1} + W{xh}x_t) \<br>y_t &amp;= W_{hy}h_t \<br>\end{aligned}$$</p>
<h3 id="RNNlayer"><a href="#RNNlayer" class="headerlink" title="RNNlayer"></a>RNNlayer</h3><h4 id="SimpleRNN"><a href="#SimpleRNN" class="headerlink" title="SimpleRNN"></a>SimpleRNN</h4><p>$$<br>\begin{aligned}<br>call &amp;= xw_{xh} + h_tw_{hh}, (for\ each\ item\ in\ timeline) \<br>out_1, h_1 &amp;= call(x, h_0) \<br>out_2, h_2 &amp;= call(x, h_1) \<br>out_t, h_t &amp;= call(x, h_{t-1})<br>\end{aligned}<br>$$</p>
<p>$h_t$ and $out_t$ is the same thing(id) but have difference meaning </p>
<h4 id="Optimize"><a href="#Optimize" class="headerlink" title="Optimize"></a>Optimize</h4><ul>
<li>Step 1:Gradient Exploding<ul>
<li>Gradient Clipping</li>
<li>$grad = \frac{|grad|}{grad}$ ,shrink to 1 and mult $15\times{lr}$</li>
<li><code>grads = [tf.clipe_by_norm(g, 15) for g in grads]</code></li>
</ul>
</li>
<li>Step 2:Gradient Vanishing<ul>
<li><em>LSTM</em> \ <em>GRU</em>  </li>
</ul>
</li>
</ul>
<h5 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h5><p>Compare with RNN(short term memory), which can only remenber nearly sentence.<em>LSTM</em> is long short term memory.</p>
<p>LSTM use three gates(sigmoid) to contral the signal. </p>
<ul>
<li>Forget gate<ul>
<li>$f_t = \sigma(W_f\cdot[h_{t-1}, x_t]+b_f)$</li>
<li><img src="./static/forget_gate.png" style="zoom:50%"></li>
</ul>
</li>
<li>Input gate<ul>
<li>$$<br>\begin{aligned}<br>  i_t &amp;= \sigma(W_i\cdot[h{t-1}, x_t] + b_i) \<br>  \widetilde{C_t} &amp;= tanh(W_C\cdot[h_{t-1}, x_t] + b_C)<br>\end{aligned}<br>$$</li>
<li><img src="./static/input_gate.png" style="zoom:50%"></li>
</ul>
</li>
<li>Cell state<ul>
<li>$C_t = f_f * C_{t-1} + i_t * \widetilde{C_t}$</li>
<li><img src="./static/cell_state.png" style="zoom:50%"></li>
</ul>
</li>
<li>Output gate<ul>
<li>$$<br>  \begin{aligned}<br>  O_t &amp;= \sigma(W_o[h_{t-1}, x_t] + b_o) \<br>  h_t &amp;= O_t * tanh(C_t)<br>  \end{aligned}$$</li>
<li><img src="./static/output_gate.png" style="zoom:50%">

</li>
</ul>
</li>
</ul>
<h5 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h5><h2 id="Auto-Encoder"><a href="#Auto-Encoder" class="headerlink" title="Auto-Encoder"></a>Auto-Encoder</h2><p>Why we need:</p>
<ul>
<li>Dimension reduction</li>
<li>Visualization</li>
<li>Take advantages of <em>unsupervised</em> date<ul>
<li>Unsupervise</li>
<li><em>Reconstruct</em> itself</li>
</ul>
</li>
</ul>
<h3 id="Denoising-AutoEncoder"><a href="#Denoising-AutoEncoder" class="headerlink" title="Denoising AutoEncoder"></a>Denoising AutoEncoder</h3><p>Add some noise and can still reconstruct well. Means model can dig out information from a mass data.</p>
<h3 id="Dropout-AutoEncoder"><a href="#Dropout-AutoEncoder" class="headerlink" title="Dropout AutoEncoder"></a>Dropout AutoEncoder</h3><p>Use dropout to autoencoder. It the hard dropouted network can than the disdropout network do better.</p>
<h3 id="Adversarial-AutoEncoder"><a href="#Adversarial-AutoEncoder" class="headerlink" title="Adversarial AutoEncoder"></a>Adversarial AutoEncoder</h3><h3 id="Variational-AutoEncoder"><a href="#Variational-AutoEncoder" class="headerlink" title="Variational AutoEncoder"></a>Variational AutoEncoder</h3><h1 id="Gen"><a href="#Gen" class="headerlink" title="Gen"></a>Gen</h1><ul>
<li>Painter or Generator</li>
<li>Critic or Discriminator</li>
</ul>
<p>$$<br>\begin{aligned}<br>min_G\ max_D\ L(D,G) &amp;= E_{x<del>p_r(x)}[\log{D(x)}] + E_{z</del>p_r(z)}[\log{1-D(G(z))}] \<br>&amp;= E_{x<del>p_r(x)}[\log{D(x)}] + E_{x</del>p_r(x)}[\log{1-D(x)}] \<br>\end{aligned}<br>$$</p>
<p>Both of they want to maximum and than get a nash equilibrium</p>
<h3 id="Nash-Equilibrium"><a href="#Nash-Equilibrium" class="headerlink" title="Nash Equilibrium"></a>Nash Equilibrium</h3><ul>
<li>Q1.Where will D converge, given fixed G</li>
<li>Q2.Where will G converge, after optimal D</li>
</ul>
<h3 id="tensorflow运行机制"><a href="#tensorflow运行机制" class="headerlink" title="tensorflow运行机制"></a>tensorflow运行机制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本质 tf = tensor + 计算图</span></span><br><span class="line"><span class="comment"># tensor 数据</span></span><br><span class="line"><span class="comment"># op 操作</span></span><br><span class="line"><span class="comment"># graphs 数据操作</span></span><br><span class="line"><span class="comment"># session 会话核心</span></span><br></pre></td></tr></table></figure>

<h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是变量的话要先init</span></span><br><span class="line">tf.add(data1+data2)</span><br><span class="line">tf.multiply(data1,data2)</span><br><span class="line">tf.subtract(data1,data2)</span><br><span class="line">tf.divide(data1,data2)</span><br><span class="line"></span><br><span class="line">dataCopy = tf.assign(x1,x2)  <span class="comment"># 把x2的值赋给x1</span></span><br><span class="line">dataCopy.eval()  <span class="comment"># 相当于sess.run(dataCopy)</span></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">tf.get_default_session().run(dataCopy)</span><br></pre></td></tr></table></figure>

<h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 数据装载</span><br><span class="line">x1 &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">x2 &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">dataAdd &#x3D; tf.add(x1,x2)</span><br><span class="line">sess.run(dataAdd,feed_dict&#x3D;&#123;x1:2,x2:4&#125;)</span><br><span class="line"># 1.tensor张量dataAdd  2.追加的数据 语法同上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 矩阵~&#x3D;数组 矩阵整体[] 每列都要[]包起来 每[]就是一行</span><br><span class="line">x1 &#x3D; tf.constant([2,2])</span><br><span class="line">x2 &#x3D; tf.constant([[2],</span><br><span class="line">				  [2]])</span><br><span class="line">x1.shape  #维度</span><br><span class="line">sess.run(x1)   # 打印整体</span><br><span class="line">sess.run(x1.[0])   # 打印第0行</span><br><span class="line">sess.run(x1.[:,0])   # 打印第0列</span><br><span class="line"></span><br><span class="line"># 运算</span><br><span class="line">tf.matmul(x1,x2)  # 矩阵乘法</span><br><span class="line">tf.multiply()  # 普通乘法 对应元素相乘</span><br><span class="line">tf.add()   # ..</span><br><span class="line"></span><br><span class="line"># 特殊矩阵的初始化</span><br><span class="line">tf.zeros([2,3])  # 两行三列空间矩阵</span><br><span class="line">tf.onex([2,3])   # 全一矩阵</span><br><span class="line">tf.fill([2,3],15)  # 填充矩阵,全为15的2*3矩阵</span><br><span class="line"></span><br><span class="line">tf.zeros_like(x1)  # 矩阵维度同x1的全零矩阵</span><br><span class="line">x3 &#x3D; tf.linspace(0.0,2.0,11)  # 生成一个矩阵，元素从0到2均匀分成11分</span><br><span class="line">x4 &#x3D; tf.random_uniform([2,3],-1,2)  # 生成2*3的一个矩阵，元素是-1到2的随机数</span><br></pre></td></tr></table></figure>

<h3 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h3><p>loss function:<br>$$loss = \sum_i(w\times x_i+b-y_i)^2 \tag{1}$$<br>loss 累加会很大，所以一般会除以元素个数n,结果还是一样的</p>
<p>$$w^<code>= w - lr \times \frac{\partial{loss}}{\partial{w}} \tag{2}$$
$$b^</code> = b - lr \times \frac{\partial{loss}}{\partial{b}}$$<br>这样就会得到新的w b,再返回第(1)步，如此循环就能得到最回事的w b</p>
<p>对loss的求导其实有规律可循:<br>$$\frac{\partial{loss}}{\partial{w}} = \frac{2}{n}\sum(wx + b - y)x$$<br>$$\frac{\partial{loss}}{\partial{b}} = \frac{2}{n}\sum(wx + b - y)$$</p>
<h3 id="Discrete-Prediction"><a href="#Discrete-Prediction" class="headerlink" title="Discrete Prediction"></a>Discrete Prediction</h3><p>离散值预测  </p>
<p>Classification (分类)为例<br>显然的离散的问题，那我们要怎么解决离散的问题呢？<br>激活函数 activation<br>常见的有ReLU和sigmoid<br>目的是为了把线性的值离散化，然后才能套用上面的公式  </p>
<p>但是就算用一个函数把线性模型离散化了，但还是太简单<br>所以引入隐藏层概念<br>input -&gt; h1 -&gt; h2 -&gt; out<br>经过多层隐藏层问题就更加离散了<br>$$h1 = relu(x@w_1 + b_1)$$<br>$$h2 = relu(h1@w_2 + b_2)$$<br>$$out = relu(h2@w_3 + b_3)$$<br>@表示矩阵乘法, 每道工序都有自己的参数   </p>
<p>那参数w和b怎么确定呢？<br>若我们想要识别0~9,那我们是不是应该希望最后输出是有10类(一个[1,10]的矩阵,每个元素可以代表一个数字)<br>那么根据矩阵运算的规则(nm*mt = nt),所以我们只要控制每层运算符合矩阵乘法规则且最后输出是我们想要的规模就好<br>最后再用out来计算loss(这里是欧氏距离(n维空间两点的距离)的loss)<br>然后就可以反复更新w` b`了</p>
<hr>
<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>tensorflow的弟弟版,因为他不能GPU计算</p>
<h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.array([第一行],[第二行]...)</span><br><span class="line">x1.shape   <span class="comment"># 打印规模</span></span><br><span class="line">np.zeros([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">np.ones([<span class="number">2</span>,<span class="number">3</span>])   <span class="comment"># 零矩阵和单位矩阵的初始化（2行3列）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改查</span></span><br><span class="line">x1[<span class="number">1</span>,<span class="number">2</span>]=<span class="number">5</span>  <span class="comment"># 第二行第一列改成5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本运算</span></span><br><span class="line">x1*x2   <span class="comment"># 加减乘除都是对应元素加减乘除</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵运算</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><p><code>import matplotlib as plt</code></p>
<h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">y = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 折线图</span></span><br><span class="line">plt.plot(x,y,<span class="string">"r"</span>)  <span class="comment"># 1.x轴 2.y轴 3.颜色</span></span><br><span class="line">plt.plot(x,y,<span class="string">"g"</span>,lw=<span class="number">10</span>)  <span class="comment"># 1.x轴 2.y轴 3.颜色 4.折线的宽度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱状图</span></span><br><span class="line">plt.bar(x,y,<span class="number">0.9</span>,alpha=<span class="number">1</span>,color=<span class="string">'b'</span>)  <span class="comment"># 3.柱状图的宽 4.alpha通道,即透明度</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>













<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/15/universe/java/Maven_Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/15/universe/java/Maven_Note/" class="post-title-link" itemprop="url">Maven 基本操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-15T00:00:00+08:00">2019-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>each project should have a pom.xml that is the setting of maven.<br>Add dependency.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>groupId<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>artifactId<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>This block of XML declares a list of dependencies for the project. Specifically, it declares a single dependency for the Joda Time library. Within the &lt;dependency&gt; element, the dependency coordinates are defined by three sub-elements:</p>
<ul>
<li><strong>&lt;groupId&gt;</strong>-The group or organization that the dependency belongs to.</li>
<li><strong>&lt;artifactId&gt;</strong>- The library that is required.</li>
<li><strong>&lt;version&gt;</strong>-The specific version of the library that is required.</li>
</ul>
<p>Creat a library package (such as JAR file),and install the library in the local Maven dependency repository.<br>When it finished,you should find the file in target/classes  directory.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure>
<p>Package the code up in a JAR(setting in pom.xml) within the target directory.<br>The name of the JAR file will be baseed on the project’s &lt;artifactId&gt; and &lt;version&gt;.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>

<p>To execute the JAR file run:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target&#x2F;gs-maven-0.1.0.jar</span><br></pre></td></tr></table></figure>

<p>Maven also maintains a repository of dependencies on your local machine (usually in a <em>.m2/repository</em> directory in your home directory) for quick access to project dependencies. If you’d like to install your project’s JAR file to that local repository, then you should invoke the <em>install</em> goal:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>
<p>The install goal will compile, test, and package your project’s code and then copy it into the local dependency repository, ready for another project to reference it as a dependency.</p>
<p>Maven uses a plugin called “surefire” to run unit tests. The default configuration of this plugin compiles and runs all classes in src/test/java with a name matching *Test. You can run the tests on the command line like this.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure>
<p>or just use mvn install step as we already showed above (there is a lifecycle definition where “test” is included as a stage in “install”).</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/14/universe/java/Spring_Boot_Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/14/universe/java/Spring_Boot_Note/" class="post-title-link" itemprop="url">Spring Boot Note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-14 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-14T00:00:00+08:00">2019-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Project that build with Maven</p>
<h2 id="Quick-buile-a-Spring-Boot-project"><a href="#Quick-buile-a-Spring-Boot-project" class="headerlink" title="Quick buile a Spring Boot project"></a>Quick buile a Spring Boot project</h2><p>Use your IDE and new a project with Spring Initializer</p>
<hr>
<h2 id="Some-basic-operations"><a href="#Some-basic-operations" class="headerlink" title="Some basic operations"></a>Some basic operations</h2><h3 id="Creat-an-excutable-jar"><a href="#Creat-an-excutable-jar" class="headerlink" title="Creat an excutable jar"></a>Creat an excutable jar</h3><p>To create an excutable jar we neen to add the <code>spring-boot-maven-plugin</code> to our pom.xml.  </p>
<p>Insert the following lines just below the <code>dependencis</code> section</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">and than run</span><br></pre></td></tr></table></figure>
<p>mvn package</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">If you look in the &#96;target&#96; directory,you should see a JAR file.</span><br><span class="line"></span><br><span class="line">To run the JAR use the &#96;java -jar&#96;command.</span><br><span class="line"></span><br><span class="line">### Run with Maven Plugin</span><br></pre></td></tr></table></figure>
<p>mvn spring-boot:run</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## About POM file</span><br><span class="line">###1. &lt;parent&gt;</span><br><span class="line">&#96;&#96;&#96; xml</span><br><span class="line">&lt;!-- example --&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure>
<p>Which is like the arbitration center of Spring Boot  </p>
<p>###2. &lt;dependencis&gt;<br>This part is to import dependencis</p>
<h4 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h4><p>Starters are a set of convenient dependency descriptors that you can include in your application.<br><a href="https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/using-boot-build-systems.html#using-boot-starter</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		...       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Main-procedure-class-main-entrance-class"><a href="#Main-procedure-class-main-entrance-class" class="headerlink" title="Main procedure class,main entrance class"></a>Main procedure class,main entrance class</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>The <code>@SpringBootApplication</code> annotation is often placed on your main class, and it implicitly defines a base “search package” for certain items.  </p>
<p>For example, if you are writing a JPA application, the package of the <code>@SpringBootApplication</code> annotated class is used to search for <code>@Entity</code> items.  </p>
<p> Using a root package also allows component scan to apply only on your project. </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>below is the detail of @SpringBootApplication,which is like a gather.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>

<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><ul>
<li>@SpringBootConfiguration annotated class is an option class of Spring Boot.</li>
</ul>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>Spring Boot auto-configuration attempts to automatically configure your Spring application based on the jar dependencies that you have added.    </p>
<p>You need to opt-in to auto-configuration by adding the <code>@EnableAutoConfiguration</code> or <code>@SpringBootApplication</code> annotations to one of your @Configuration classes.<br>(Because the <code>@SpringBootConfiguration</code> have included @EnableAutoConfiguration,the auto-configuration wil automatically configure all component that in the same package with the <code>@SpringBootConfiguration</code>)</p>
<hr>
<h2 id="Configuration-file"><a href="#Configuration-file" class="headerlink" title="Configuration file"></a>Configuration file</h2><p>Spring Boot default configuration in <em>src/main/resources/</em>.<br><code>application.yml</code> or <code>application.properties</code></p>
<h3 id="1-YAML-basic"><a href="#1-YAML-basic" class="headerlink" title="1.YAML basic"></a>1.YAML basic</h3><p>format like Python<br>key:(space)value </p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">	<span class="attr">path:</span> <span class="string">/halo</span></span><br></pre></td></tr></table></figure>
<p>do not ignore case</p>
<h3 id="2-key-value"><a href="#2-key-value" class="headerlink" title="2. key: value"></a>2. key: value</h3><h4 id="Object-Map"><a href="#Object-Map" class="headerlink" title="Object,Map"></a>Object,Map</h4><p>key: value</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">	<span class="string">name:ring</span></span><br><span class="line">	<span class="string">age:20</span></span><br><span class="line"><span class="string">```</span>  </span><br><span class="line"></span><br><span class="line"><span class="string">inline</span>	</span><br><span class="line"><span class="string">```</span> <span class="string">yml</span></span><br><span class="line"><span class="string">friends:&#123;name:ring,age:20&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>-value</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line">	<span class="string">-cat</span></span><br><span class="line">	<span class="string">-dog</span></span><br></pre></td></tr></table></figure>

<p>inline  </p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pet:</span> <span class="string">[dog,cat]</span></span><br></pre></td></tr></table></figure>

<h3 id="ConfigurationProperties-prefix-“person”"><a href="#ConfigurationProperties-prefix-“person”" class="headerlink" title="@ConfigurationProperties(prefix = “person”)"></a>@ConfigurationProperties(prefix = “person”)</h3><p>Bind all properties in this class with the properties in configuration file<br><code>prefix = &quot;person&quot;</code> means bind class properties with person properties.  </p>
<p>Only the component props can use the component function<code>@ConfigurationProperties</code>.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span></span>&#123;</span><br></pre></td></tr></table></figure>

<h3 id="PropertySource-value-“classpath-application2-yml’"><a href="#PropertySource-value-“classpath-application2-yml’" class="headerlink" title="@PropertySource(value = {“classpath:application2.yml’})"></a>@PropertySource(value = {“classpath:application2.yml’})</h3><p>Like @ConfigurationProperties ,but this can select another configuration file.  </p>
<h3 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h3><p>Import Spring configuration file,and<br>……..</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/08/universe/operate/git_usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/08/universe/operate/git_usage/" class="post-title-link" itemprop="url">git操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-08T00:00:00+08:00">2019-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-29 10:48:34" itemprop="dateModified" datetime="2020-12-29T10:48:34+08:00">2020-12-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Git-操作"><a href="#Git-操作" class="headerlink" title="Git 操作"></a>Git 操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>


<h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>


<h3 id="查看修改"><a href="#查看修改" class="headerlink" title="查看修改"></a>查看修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff BRANCHNAME</span><br></pre></td></tr></table></figure>


<h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>


<h3 id="添加修改并追踪"><a href="#添加修改并追踪" class="headerlink" title="添加修改并追踪"></a>添加修改并追踪</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add FILE</span><br><span class="line">git add .  // 添加所有</span><br></pre></td></tr></table></figure>


<h3 id="退回"><a href="#退回" class="headerlink" title="退回"></a>退回</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br><span class="line">git reset --hard HEAD^ 退回到上一个版本</span><br><span class="line">git reset --hard HEAD~n 退回到上n个版本</span><br><span class="line">git reset --hard sjaieral 退回某个版本</span><br></pre></td></tr></table></figure>


<h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "NAME"</span><br><span class="line">git config --global user.email "EMAIL"</span><br><span class="line">...等等</span><br></pre></td></tr></table></figure>


<h3 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.获取工程</span><br><span class="line">git clone URL</span><br><span class="line"></span><br><span class="line">2.更新</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>


<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.gibhub上创建一个仓库</span><br><span class="line"></span><br><span class="line">2.添加远程仓库</span><br><span class="line">git remote add origin ULR</span><br><span class="line"></span><br><span class="line">3.推到远程仓库</span><br><span class="line">git push --set-upstream origin master</span><br><span class="line">或者</span><br><span class="line">git push -u origin master</span><br><span class="line">// 然后登录</span><br><span class="line">// push master分支到origin仓库</span><br><span class="line"></span><br><span class="line">4.记住密码</span><br><span class="line">git config credential.helper store</span><br><span class="line">// 再次登录就可以记住了</span><br></pre></td></tr></table></figure>


<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit // 会打开文件让你添加描述</span><br><span class="line">git commit -m "描述" // 快捷添加描述提交</span><br></pre></td></tr></table></figure>


<h3 id="PR"><a href="#PR" class="headerlink" title="PR"></a>PR</h3><ul>
<li>fork到自己仓库</li>
<li>clone自己仓库到电脑</li>
<li>与源代码仓库建立连接<ul>
<li><code>git remote add upstream &lt;url&gt;</code></li>
<li>查看是否成功建立连接<code>git remote -v</code></li>
</ul>
</li>
<li>创建分支<ul>
<li><code>git switch -c &lt;branch_name&gt;</code>或<code>git checkout -b &lt;branch&gt;</code></li>
</ul>
</li>
<li>从其他仓库下载(先同步)<ul>
<li><code>git fetch upstream</code></li>
<li><code>git rebase upstream/&lt;branch&gt;</code></li>
<li>然后提交到自己仓库提pr<code>git push &lt;origin&gt; &lt;branch&gt;</code></li>
</ul>
</li>
<li>修改代码<ul>
<li>提交当前分支到自己仓库<ul>
<li><code>git push origin &lt;branch_name&gt;</code></li>
</ul>
</li>
<li>提交pr</li>
</ul>
</li>
</ul>
<h3 id="不让git管理指定文件"><a href="#不让git管理指定文件" class="headerlink" title="不让git管理指定文件"></a>不让git管理指定文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.新建一个 .gitignore 文件</span><br><span class="line"></span><br><span class="line">2.写入不需要git管理等文件名</span><br><span class="line">// 但是git一旦追踪某个文件那就会一只追踪</span><br><span class="line">// 停止追踪 git rm --cached FILE</span><br></pre></td></tr></table></figure>


<h3 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.创建分支</span><br><span class="line">git branch NAME</span><br><span class="line"></span><br><span class="line">2.切换分支</span><br><span class="line">git checkout NAME</span><br><span class="line"></span><br><span class="line">3.分支合并</span><br><span class="line">git merge NAME // 会把NAME分支合并到当前分支</span><br><span class="line"></span><br><span class="line">4.删除分支</span><br><span class="line">git branch -d NAME // -D强制删除</span><br><span class="line">// 主分支叫master</span><br></pre></td></tr></table></figure>


<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>HEAD表示当前版本</p>
<h3 id="时间胶囊"><a href="#时间胶囊" class="headerlink" title="时间胶囊"></a>时间胶囊</h3><ul>
<li><code>git log</code>查看提交历史，确定版本号</li>
<li><code>git reset --hard &lt;commit_id&gt;</code>退回到指定版本<ul>
<li>退回后<code>git log</code>将找不到新版本的信息，但是不用担心本版仓库还在，只要找到对应的id就能回去</li>
</ul>
</li>
<li><code>git reflog</code>查看命令历史</li>
</ul>
<h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><ul>
<li>checkout<ul>
<li><code>git checkout -- &lt;file&gt;</code>，撤销修改(checkout文件到本版原始的状态)</li>
<li><code>--</code>是必要的，否则就是分支的切换</li>
</ul>
</li>
<li>reset<ul>
<li><code>git reset HEAD &lt;file&gt;</code>，reset文件在暂存区(stage)的状态(清出暂存区)，也就是unstaged</li>
</ul>
</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>一个文件被删除后git会检测到修改(工作区和版本库不一样)，可以使用<code>git rm</code>删除版本库中的记录。 <strong>git rm</strong> 是一样的效果</p>
<p>如果版本库的文件没被删除，则可用<code>git checkout -- &lt;file&gt;</code>恢复，如果已经删除可以使用<code>git reset</code>的方法来unstage</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>git把版本穿成一条时间线，每条时间线就是一个分支，每个版本就是一个节点。当创建新分支dev时相当于创建了一个dev的指针指向当前节点，再把HEAD指向dev，然后就可以以此为基础往后建立时间线。</p>
<p>缺省前缀(如<code>&lt;remote&gt;/&lt;branch&gt;</code>)的操作，默认对本地的branch操作，所以<code>fetch upstream</code>后log还看不到本地commit的变化，因为还在upstream里用<code>git log &lt;remote&gt;/&lt;bracn&gt;</code>查看</p>
<ul>
<li>查看分支信息和commit<ul>
<li><code>git log --graph --pretty=oneline --abbrev-commit</code></li>
</ul>
</li>
<li>建立分支<ul>
<li><code>git branch &lt;branch_name&gt;</code></li>
<li><code>git switch -c</code><ul>
<li><code>-c</code>表示新建并切换</li>
</ul>
</li>
<li><code>git checkout -b &lt;branch_name&gt;</code><ul>
<li><code>-b</code>表示新建并切换</li>
<li>但是checkout命令又是撤销修改的命令，所以推荐使用switch</li>
</ul>
</li>
</ul>
</li>
<li>合并分支<ul>
<li><code>git merge &lt;branch&gt;</code>把指定分支合并到但前分支</li>
</ul>
</li>
</ul>
<p>如果两个分支只形成一条时间线，则git可以<code>fast forward</code> “快速合并”，即<code>git merge dev</code>把HEAD和master的指针指向dev，即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|</span><br><span class="line">* (master)</span><br><span class="line">|</span><br><span class="line">* dev</span><br></pre></td></tr></table></figure>

<p>如果分支有各自的提交，则git无法执行”快速合并”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    |</span><br><span class="line">    * </span><br><span class="line">    | \</span><br><span class="line">dev *  * master</span><br></pre></td></tr></table></figure>


<h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>合并时，git会尽可能使用<code>Fast forward</code>模式，这模式下，删除分支后，会丢失部分分支信息。可以使用<code>--no-ff</code>参数来禁用<code>Fast forward</code>模式，以保留分支历史</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始情况</span><br><span class="line">|</span><br><span class="line">* master</span><br><span class="line">|</span><br><span class="line">* HEAD -&gt; dev</span><br><span class="line"></span><br><span class="line">Fast forward合并</span><br><span class="line">|</span><br><span class="line">*</span><br><span class="line">|</span><br><span class="line">* HEAD -&gt; dev, master</span><br><span class="line"></span><br><span class="line">no Fast forward合并</span><br><span class="line">|</span><br><span class="line">* </span><br><span class="line">| \</span><br><span class="line">|  * dev</span><br><span class="line">| /</span><br><span class="line">*  HEAD -&gt; master</span><br></pre></td></tr></table></figure>


<h4 id="复制特定提交而不合并分支"><a href="#复制特定提交而不合并分支" class="headerlink" title="复制特定提交而不合并分支"></a>复制特定提交而不合并分支</h4><p>如果一个bug早期就存在了，那每个分支上这个bug都存在。git提供了复制特定提交到当前分支的功能<code>cherry-pick &lt;commit_id&gt;</code></p>
<p>这样一条命令就完成了修复bug，而不需要把分区合并</p>
<h3 id="保存工作区"><a href="#保存工作区" class="headerlink" title="保存工作区"></a>保存工作区</h3><p>当你要修一个bug，但是你当前的工作没有完成(提交)时，使用<code>stash</code>功能可以把当前的工作现场保存起来。这样你转去修bug的时候就有一块干净的工作区了。</p>
<ul>
<li><code>git stash</code><ul>
<li>保存当前工作现场</li>
</ul>
</li>
<li><code>git stash list</code><ul>
<li>查看以保存工作现场</li>
</ul>
</li>
<li>工作现场恢复<ul>
<li><code>git stash apply [stash_id]</code><ul>
<li>这种恢复后不会删除stash内容，需要<code>git stash drop</code>删除</li>
</ul>
</li>
<li><code>git stash pop [stash_id]</code><ul>
<li>恢复的同时删除</li>
</ul>
</li>
<li>stash是栈的结构，所以apply和drop的时候默认都是操作栈顶的stash</li>
</ul>
</li>
</ul>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>tag就是给commit起一个容易记住的名字，tag和commit是绑定在一起的</p>
<ul>
<li><p><code>git tag &lt;name&gt; [commit_id]</code></p>
<ul>
<li>给一个commit一个为名tag，默认是当前commit</li>
</ul>
</li>
<li><p><code>git tag -a &lt;name&gt; -m &lt;desc&gt; [commit_id]</code></p>
<ul>
<li>给<code>&lt;commit_id&gt;</code>(默认当前commit)创建一个带有说明信息<code>&lt;desc&gt;</code>的<code>&lt;name&gt;</code>标签</li>
</ul>
</li>
<li><p><code>git show &lt;tagname&gt;</code></p>
<ul>
<li>显示tag信息</li>
</ul>
</li>
<li><p><code>git tag -d &lt;tagname&gt;</code></p>
<ul>
<li>删除标签</li>
</ul>
<p><strong>注意</strong> ：标签是按字母排序的，而不是commit是时间顺序</p>
</li>
</ul>
<p>标签只会储存在本地，如果要推送到远程，使用<code>git push &lt;origin&gt; &lt;tagname&gt;</code></p>
<p>一次性推送所有标签<code>git push &lt;origin&gt; --tags</code></p>
<p>删除远程标签(前提是本地标签已经删除):<code>git push &lt;origin&gt; :refs/tags/&lt;tagname&gt;</code></p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ul>
<li>查看分支信息<ul>
<li><code>git remote -v</code></li>
</ul>
</li>
<li>推送分支<ul>
<li><code>git push &lt;origin&gt; &lt;branch_name&gt;</code></li>
</ul>
</li>
</ul>
<p>当小伙伴 <strong>clone时，默认只能看到本地的master分支</strong>。要在dev分支上开发就需要建立远程<code>origin</code>的<code>dev</code>分支到本地：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;local_branch&gt; &lt;origin&gt;/&lt;remote_branch&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不能缺少&lt;local_branch&gt;，不然就变成了创建分支</span></span><br></pre></td></tr></table></figure>

<p>如果git提示<code>no tracking information</code>，则说明本地分支和远程分支的连接关系没有建立，使用命令<code>git branch --set-upstream-to &lt;branch_name&gt; origin/&lt;branch_name&gt;</code>远程的branchname建立连接到本地的branchname</p>
<h4 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h4><p>TODO</p>
<h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><p>对于复杂的项目，主目录依赖子模块，但我们又不想把子模块合并到主项目中，想让他们相互独立。</p>
<p>我们可以将子模块加入<code>.gitignore</code>文件中，这么做虽然独立了，但这么做的前提是主项目的人需要在当前目录下放置某以版本的子模块代码。</p>
<p>Git提供了<code>submodule</code>功能，用于建立当前项目与子模块之间的依赖关系：子模块路径、子模块远程仓库、子模块版本号。即让你在一个git仓库中存在另一个git仓库。</p>
<ul>
<li>添加子模块<ul>
<li><code>git submodule add &lt;submodule_url&gt; &lt;local_path&gt;</code></li>
<li>会在父仓库根目录下增加<code>.gitmodule</code>文件  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitmodule</span><br><span class="line">[submodule &quot;XXX&quot;]</span><br><span class="line">path &#x3D; XXX</span><br><span class="line">url &#x3D; XXX</span><br></pre></td></tr></table></figure></li>
<li>并在配置文件中加入submodule字段  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git&#x2F;config</span><br><span class="line">[submodule &quot;sub&quot;]</span><br><span class="line">    url &#x3D; ssh:&#x2F;&#x2F;git@10.2.237.56:23&#x2F;dennis&#x2F;sub.git</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>checkout<ul>
<li>clone一个包含子仓库的仓库并不会clone子仓库的文件，而是clone<code>.gitmodule</code>的描述文件用于构建子仓库</li>
<li>使用  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 初始化本地配置文件</span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule init</span></span><br><span class="line">// 检出父仓库列出的commit</span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update --init --recursive</span></span><br></pre></td></tr></table></figure></li>
<li>此时子仓库会在某个git提交本版，即可在子仓库中git命令(pull)进行版本控制</li>
<li>主目录中会看到的子仓库的修改，是一个<code>commit id</code></li>
</ul>
</li>
</ul>
<ul>
<li>删除子仓库<ul>
<li><code>git submodule deinit &lt;submodule&gt;</code></li>
<li>会自动删除<code>.git/config</code>中的内容，但是<code>.submodule</code>和<code>.git/modules</code>还会保留，可以通过<code>.submodule</code>恢复</li>
<li>使用<code>git rm &lt;submodule_dir&gt;</code>，移除子仓库文件夹，此时子模块信息基本移除(除了<code>.git/modules</code>)  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On branch main</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;main&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        modified:   .gitmodules</span><br><span class="line">        deleted:    &lt;submodule_dir&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>todo</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/universe/go/golang%E6%93%8D%E4%BD%9C%20mgov2%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/27/universe/go/golang%E6%93%8D%E4%BD%9C%20mgov2%E7%AF%87/" class="post-title-link" itemprop="url">golang操作 mgov2篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-27T00:00:00+08:00">2019-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="打开mongo"><a href="#打开mongo" class="headerlink" title="打开mongo"></a>打开mongo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"gopkg.in/mgo.v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">	url:=<span class="string">"mongodb://localhost:27017"</span>  <span class="comment">// 不登录mongo的</span></span><br><span class="line">	url:=<span class="string">"mongodb://root:password@localhost:27017/登录的用户名"</span> <span class="comment">// 登录mongo的</span></span><br><span class="line">	session,err:=mgo.Dial(url)</span><br><span class="line">	<span class="keyword">defer</span> session.Close() <span class="comment">// 最后记得关闭 减压</span></span><br><span class="line">	ses:=session.DB(<span class="string">"databaseName"</span>).C(<span class="string">"collectionName"</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Update更新数据库"><a href="#Update更新数据库" class="headerlink" title="Update更新数据库"></a>Update更新数据库</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"gopkg.in/mgo.v2"</span></span><br><span class="line">	<span class="string">"gopkg.in/mgo.v2/bson"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update只能更新一条，UpdateAll批量更新</span></span><br><span class="line">	selector := bson.M&#123;<span class="string">"word"</span>:<span class="string">"god"</span>&#125;  <span class="comment">// 选择器：按word:god找，不存在返回nor found</span></span><br><span class="line">	<span class="comment">//bson.M&#123;key:value&#125;就相当于python的字典</span></span><br><span class="line">	data := bson.M&#123;<span class="string">"$set"</span>:bson.M&#123;<span class="string">"word"</span>:<span class="string">"good"</span>&#125;&#125; <span class="comment">// 找到后用$set修改</span></span><br><span class="line">	ses.Update(selector,data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果要更新集合里一个数组的</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Travis TuRing</p>
  <div class="site-description" itemprop="description">Mens et Manus</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Travis TuRing</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
