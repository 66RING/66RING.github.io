<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/20/Major/algorithm/funny_algorithm/funny_algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/20/Major/algorithm/funny_algorithm/funny_algorithm/" class="post-title-link" itemprop="url">有趣的算法问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-20T00:00:00+08:00">2020-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-27 11:52:44" itemprop="dateModified" datetime="2020-07-27T11:52:44+08:00">2020-07-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="随机模拟问题"><a href="#随机模拟问题" class="headerlink" title="随机模拟问题"></a>随机模拟问题</h2><h3 id="分钱问题"><a href="#分钱问题" class="headerlink" title="分钱问题"></a>分钱问题</h3><p>房间里有100个人，每个人有100块钱，他们在玩一个游戏。没轮游戏中，每个人都拿出一元前随机给另一个人，最后这100个人的财富分布是怎样的？</p>
<p>最后分布将是非常无序的，而非每人差不多。相当于100x100分给100个人，而每个人差不多的概率其实是小概率事件。</p>
<h3 id="蒙特卡洛算法"><a href="#蒙特卡洛算法" class="headerlink" title="蒙特卡洛算法"></a>蒙特卡洛算法</h3><p>蒙特卡洛方法是一种统计学的方法，是一种模拟。通过大量随机样本，去了解一个系统，进而得到所要计算的值。</p>
<h4 id="蒙特卡洛方法求Pi值"><a href="#蒙特卡洛方法求Pi值" class="headerlink" title="蒙特卡洛方法求Pi值"></a>蒙特卡洛方法求Pi值</h4><p>一个正方形，里面是一个直径和它边长相等的圆</p>
<ul>
<li>圆面积 = Pi x R x R</li>
<li>方面积 = 2R x 2R</li>
<li>比一下则：Pi = 4 x 圆面积/方面积</li>
</ul>
<p>那么不知道Pi怎么计算圆的面积呢？大可不必算，圆/方不就是落在圆中的概率么。</p>
<h4 id="三门问题-Monty-Hall-Problem"><a href="#三门问题-Monty-Hall-Problem" class="headerlink" title="三门问题(Monty Hall Problem)"></a>三门问题(Monty Hall Problem)</h4><p>参赛者会看见三扇关闭的门，其中一扇的后面有一辆汽车，选中后面有车的门可以赢得该汽车，而另外两扇门后面什么都没有。当参赛者选定一扇门，但开启前，节目主持人会开启剩下两扇门中的一扇，这扇门后面一定没有汽车。主持人问参赛者要不要换另一扇门。问题是：另一扇门会不会增加参赛者获奖概率？</p>
<p>直觉上，主持人开的门并不会影响我们，相当于1/2的命中率。但事实上:</p>
<ul>
<li>换门中奖概率2/3</li>
<li>不换门中奖概率1/3</li>
</ul>
<p>因为主持人知道哪个门没奖，而且一直选择没奖的没，因此导致了概率的不平均，产生偏差</p>
<h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><h3 id="迷宫生成"><a href="#迷宫生成" class="headerlink" title="迷宫生成"></a>迷宫生成</h3><p>抽象成计算机的概念，迷宫其实就是一棵树，迷宫生成问题就是一个随机生成树问题。</p>
<p><img src="./assets/mazi.png" alt="迷宫初始化"></p>
<p>以这么的结构初始化图，再随机生成树</p>
<p>要随机的生成数，就需要创建一个随机队列，出队时随机选择一个元素出队。 <strong>出队时，随机选中的元素和队尾元素交换位置，然后出队。</strong></p>
<h4 id="随机性更强的迷宫"><a href="#随机性更强的迷宫" class="headerlink" title="随机性更强的迷宫"></a>随机性更强的迷宫</h4><p>上面的迷宫随机性不强，总体上从左上到右下，原因是每次从随机队列选出一个元素时，如果选择的元素是上个元素的最后一个元素，那么就相当于执行了一个小的深度优先遍历。而深度优先走的整体就是向下向右。</p>
<ul>
<li>另一种随机队列：<ul>
<li>基于链表</li>
<li>入队：随机入队首或队尾</li>
<li>出队：随机从队首或队尾挑选元素</li>
</ul>
</li>
</ul>
<h4 id="更多随机方案、更多形状的迷宫"><a href="#更多随机方案、更多形状的迷宫" class="headerlink" title="更多随机方案、更多形状的迷宫"></a>更多随机方案、更多形状的迷宫</h4><h3 id="扫雷游戏"><a href="#扫雷游戏" class="headerlink" title="扫雷游戏"></a>扫雷游戏</h3><ul>
<li>随机生成雷区<ul>
<li>方案1：随机坐标，然后在这个位置埋雷<ul>
<li>缺点：随机出的坐标可能已经有雷，如果在while中跳过已经有雷的区域，则时间将不确定，有可能每次都随机出已经有雷的区域</li>
</ul>
</li>
<li>方案2：将雷顺序放在前面的格子，然后随机交换一定次数</li>
</ul>
</li>
</ul>
<h4 id="什么样的乱序化才是好的乱序"><a href="#什么样的乱序化才是好的乱序" class="headerlink" title="什么样的乱序化才是好的乱序"></a>什么样的乱序化才是好的乱序</h4><ul>
<li>问：给一副扑克牌，设计一个洗牌算法，怎么说明你的洗牌算法是个好的洗牌算法</li>
<li>54张牌，可以有54!种结果。所以一个好的洗牌算法可以等概率获得54!种结果之一</li>
</ul>
<h4 id="等概率洗牌算法"><a href="#等概率洗牌算法" class="headerlink" title="等概率洗牌算法"></a>等概率洗牌算法</h4><ul>
<li>方案1：根据现实模拟。54!种结果来源于第一张牌有54个位置可选，第二张53…根据这点设计洗牌算法。从54张牌中随机抽一张放在一个位置…<ul>
<li>缺点：不是原地的，即需要额外的存储空间;如果随机取牌不够随机，那也不是等概率的</li>
</ul>
</li>
</ul>
<h4 id="Fisher-Yates-Knuth-洗牌算法"><a href="#Fisher-Yates-Knuth-洗牌算法" class="headerlink" title="Fisher-Yates(-Knuth)洗牌算法"></a><strong>Fisher-Yates(-Knuth)洗牌算法</strong></h4><p>以洗牌为例，在长度位54的数组中随机选择一个元素，然后与第一个元素交换位置。然后以剩下的张牌位单位重复这个操作。</p>
<h4 id="Floodfill算法"><a href="#Floodfill算法" class="headerlink" title="Floodfill算法"></a>Floodfill算法</h4><p>就像一滴墨水滴在白纸上，慢慢扩散，所以称floodfill。也就是要注意边界的BFS或DFS。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/universe/python/python_opencv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/19/universe/python/python_opencv/" class="post-title-link" itemprop="url">openCV学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-19 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-19T00:00:00+08:00">2020-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-25 10:19:23" itemprop="dateModified" datetime="2020-07-25T10:19:23+08:00">2020-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在openCV中图像的xy轴是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(0,0) -------&gt; x</span><br><span class="line">      |</span><br><span class="line">      |</span><br><span class="line">      |</span><br><span class="line">    y v</span><br></pre></td></tr></table></figure>


<h2 id="读取图像和视频"><a href="#读取图像和视频" class="headerlink" title="读取图像和视频"></a>读取图像和视频</h2><p><code>import cv2</code></p>
<h3 id="图像读取"><a href="#图像读取" class="headerlink" title="图像读取"></a>图像读取</h3><ul>
<li>读取数据<ul>
<li><code>img_data = cv2.imread(file)</code></li>
</ul>
</li>
<li>显示<ul>
<li><code>cv2.imshow(window_name, img_data)</code></li>
<li>持久化显示：<code>cv2.waitKey(x_ms)</code>。0表示时间无限</li>
</ul>
</li>
</ul>
<h3 id="视频读取"><a href="#视频读取" class="headerlink" title="视频读取"></a>视频读取</h3><ul>
<li>读取数据<ul>
<li><code>cap = cv2.VideoCapture(file)</code></li>
</ul>
</li>
<li>显示  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    success, img = cap.read()</span><br><span class="line">    cv2.imshow(<span class="string">"video_window"</span>, img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># q退出</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="摄像头获取"><a href="#摄像头获取" class="headerlink" title="摄像头获取"></a>摄像头获取</h3><ul>
<li>读取数据<ul>
<li><code>cap = cv2.VideoCapture(id_of_cam)</code></li>
<li>0表示使用默认摄像头</li>
</ul>
</li>
<li>设置<ul>
<li><code>cap.set(id, value)</code><ul>
<li>id=3，表示宽度</li>
<li>id=4，表示高度</li>
<li>id=10, 表示亮度</li>
</ul>
</li>
</ul>
</li>
<li>显示  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    success, img = cap.read()</span><br><span class="line">    cv2.imshow(<span class="string">"video_window"</span>, img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># q退出</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="转换灰度"><a href="#转换灰度" class="headerlink" title="转换灰度"></a>转换灰度</h3><ul>
<li><code>imgGray = cv2.cvtColor(img_data, Color_you_want)</code><ul>
<li>Color使用<code>cv2.COLOR...</code></li>
<li>注意在openCV中图像通道是BGR，而不是RGB</li>
</ul>
</li>
</ul>
<h3 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h3><p>这里以GaussianBlur为例，当然还有很多种blur方案</p>
<ul>
<li><code>imgBlur = cv2.GaussianBlur(img_data, (kernel_size, ), sigmaX)</code></li>
</ul>
<h3 id="边缘检测器"><a href="#边缘检测器" class="headerlink" title="边缘检测器"></a>边缘检测器</h3><ul>
<li><code>imgCanny = cv2.Canny(img_data, threshold1, threshold2)</code><ul>
<li>threshold阀值就是可能需要调整的参数，要减少边数就提高阀值</li>
</ul>
</li>
<li>增加边缘的厚度：膨胀(dilate)<ul>
<li><code>imgDialation = cv2.dilate(imgCanny, kernel, iterations=times)</code></li>
<li>kernel是一个矩阵的大小和值的阵列，可以使用numpy建立<code>kernel = np.ones((x, y), 数据类型)</code>，ones表示所有的值都是1</li>
<li>iterations=times表示迭代的次数(我们想要多厚)</li>
</ul>
</li>
<li>减小边缘的厚度：侵蚀(erode与膨胀相反)<ul>
<li><code>imgEroded = cv2.erode(imgDialation, kernel, iterations=times)</code></li>
</ul>
</li>
</ul>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><ul>
<li>获得大小和通道数据<ul>
<li><code>img.shape</code>，返回(height, width, BGR)</li>
</ul>
</li>
<li>调整大小<ul>
<li><code>resized = cv2.resize(img, (width, height))</code></li>
</ul>
</li>
<li>裁剪<ul>
<li><code>img[h_begin:h_end, w_begin:w_end]</code>，和cv2的函数不同，这里先高度再宽度，使用数据切片来裁剪图片</li>
</ul>
</li>
</ul>
<h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><p>图像的本质就是一个矩阵，所以我们可以使用numpy来生成矩阵，然后show出来。如<code>img = np.zeros((x, y))</code>，0表示黑色，所有将得到一个纯黑的图片。</p>
<p>当然用numpy生成矩阵的时候也可以指定通道数，所谓通道就是n个(x, y)的矩阵。需要注意的是opencv中通道是BGR，在python中矩阵的表示形式也需要了解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = np.zeros((x, y, <span class="number">3</span>), np.uint8)</span><br><span class="line">img[:] = <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 生成纯蓝的图片</span></span><br></pre></td></tr></table></figure>

<ul>
<li>画线<ul>
<li><code>cv2.line(img, (x1, y1), (x2, , y2), (B, G, R), thick)</code>，需要起始点和终点(x1, y1)和(x2, y2)</li>
</ul>
</li>
<li>画矩形<ul>
<li><code>cv2.rectangle(img, (x1, y1), (x2, , y2), (B, G, R), thick)</code>，需要起始点和终点(x1, y1)和(x2, y2)</li>
<li>如果font_size部分写入<code>cv2.FILLED</code>则会填充整个矩形，同理还有很多<code>cv2.XXX</code>可以使用</li>
</ul>
</li>
<li>画圆<ul>
<li><code>cv2.circle(img, (x1, y1), r, (B, G, R), thick)</code>，需要起始点和半径(x1, y1)和r</li>
</ul>
</li>
<li>文本<ul>
<li><code>cv2.putText(img, &quot;text&quot;, (x1, y1), font, scale, (B, G, R), thick)</code></li>
<li><code>font</code>可以使用cv2内置的<code>cv2.XXX</code></li>
</ul>
</li>
</ul>
<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><h4 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pts1 = np.float32([x1, y1], [x2, y2], [x3, y3], [x4, y3])</span><br><span class="line">pts2 = np.float32([x1, y1], [x2, y2], [x3, y3], [x4, y3])</span><br><span class="line">matrix = cv2.getPerspectiveTransform(pts1, pts2)  <span class="comment"># 从pts1到pts2的透视变换矩阵，相当于ps中扯4个点</span></span><br><span class="line">imgOutput = cv.warpPerspective(img, matrix, (width, heigh))</span><br></pre></td></tr></table></figure>


<h3 id="图像结合"><a href="#图像结合" class="headerlink" title="图像结合"></a>图像结合</h3><p>如果有很多图像，使用图像结合就不用一张一张的的运行了，在一个窗口中完成</p>
<ul>
<li>简单的合并<ul>
<li>水平合并<ul>
<li><code>img = np.hstack((img1, img2, ..., imgN))</code></li>
</ul>
</li>
<li>垂直合并<ul>
<li><code>img = np.vstack((img1, img2, ..., imgN))</code></li>
</ul>
</li>
<li>但单纯使用这两种简单合并存在一些问题<ul>
<li><ol>
<li>无法调节大小</li>
</ol>
</li>
<li><ol start="2">
<li>通道数必须一样</li>
</ol>
</li>
<li>因此需要自己写些函数来有机结合他们</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="检测颜色"><a href="#检测颜色" class="headerlink" title="检测颜色"></a>检测颜色</h3><ul>
<li>色彩捕获</li>
<li><ol>
<li>将图像转换成HSV<code>imgHSV = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</code></li>
</ol>
</li>
<li><ol start="2">
<li>编写TrackBars以辅助我们找出最佳值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个窗口</span></span><br><span class="line">cv2.namedWindow(<span class="string">"TrackBars"</span>)</span><br><span class="line">cv2.resizeWindow(<span class="string">"TrackBars"</span>, <span class="number">640</span>, <span class="number">240</span>)  <span class="comment"># 通过winName找到想要的win</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建跟踪栏</span></span><br><span class="line"><span class="comment"># cv2.createTrackbar("barName", "winName", min, max, func)</span></span><br><span class="line"><span class="comment"># func接受一个值，当Trackbar的值改变值执行对应操作</span></span><br><span class="line"><span class="comment"># 这样的trackbar有6个，包含所有的色相最大最小饱和度等</span></span><br><span class="line">cv2.createTrackbar(<span class="string">"Hue min"</span>, <span class="string">"TrackBars"</span>, <span class="number">0</span>, <span class="number">179</span>, func)</span><br><span class="line">cv2.createTrackbar(<span class="string">"Hue max"</span>, <span class="string">"TrackBars"</span>, <span class="number">179</span>, <span class="number">179</span>, func)</span><br><span class="line">cv2.createTrackbar(<span class="string">"Sat min"</span>, <span class="string">"TrackBars"</span>, <span class="number">0</span>, <span class="number">255</span>, func)</span><br><span class="line">cv2.createTrackbar(<span class="string">"Sat max"</span>, <span class="string">"TrackBars"</span>, <span class="number">255</span>, <span class="number">255</span>, func)</span><br><span class="line">cv2.createTrackbar(<span class="string">"val min"</span>, <span class="string">"TrackBars"</span>, <span class="number">0</span>, <span class="number">255</span>, func)</span><br><span class="line">cv2.createTrackbar(<span class="string">"val max"</span>, <span class="string">"TrackBars"</span>, <span class="number">255</span>, <span class="number">255</span>, func)</span><br></pre></td></tr></table></figure>
<ul>
<li>跟踪trackbar的值<code>val = cv2.getTrackbarPos(&quot;barName&quot;, &quot;winName&quot;)</code></li>
<li>无限循环以实时更新</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>创建mask遮罩<code>mask = cv2.inRange(img, lower, upper)</code><ul>
<li><code>lower = np.array([min1, min2, ..., minN])</code></li>
<li><code>upper = np.array([max1, max2, ..., maxN])</code></li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>把遮罩显示出来调整trackbar，以找到合适的值</li>
</ol>
</li>
<li><ol start="5">
<li>使用遮罩和原始图片创建新图片即可得到抽取颜色后的图片<ul>
<li><code>res = cv2.bitwise_and(img, img, mask=mask)</code>，and:按位与操作</li>
</ul>
</li>
</ol>
</li>
<li>堆叠图像，而不是一个一个显示所有图像</li>
</ul>
<h3 id="检查图形"><a href="#检查图形" class="headerlink" title="检查图形"></a>检查图形</h3><ul>
<li><ol>
<li>转化成灰度图，以便找到拐角<ul>
<li><code>imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</code></li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>添加一些模糊<ul>
<li><code>imgBlur = cv2.GaussianBlur(imgGray, (kernel,), sigma)</code></li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>描边<ul>
<li><code>imgCanny = cv2.Canny(imgBlur, threshold, threshold)</code></li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li><p>检测轮廓</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getContours</span><span class="params">(img)</span>:</span></span><br><span class="line">    contours, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">    <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:</span><br><span class="line">        area = cv2.contourArea(cnt)</span><br><span class="line">        <span class="keyword">if</span> area&gt;<span class="number">500</span>:  <span class="comment"># 通过面积来消除噪声</span></span><br><span class="line">            cv2.drawContours(drawToImg, cnt, <span class="number">-1</span>, (B, G, R), thick) <span class="comment"># -1 画所有轮廓</span></span><br><span class="line">            <span class="comment"># 计算轮廓长度</span></span><br><span class="line">            peri = cv2.arcLength(cnt, <span class="literal">True</span>)  <span class="comment"># true表示封闭</span></span><br><span class="line">            <span class="comment"># 计算拐点位置</span></span><br><span class="line">            approx = cv2.approxPolyDP(cnt, <span class="number">0.02</span>*peri, <span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># 计算角</span></span><br><span class="line">            objCor = len(approx)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 画边框，实现有个方框包围的效果</span></span><br><span class="line">            x, y, w, h = cv2.boundingRect(approx)</span><br><span class="line">            cv2.rectangle(drawToImg, (x, y), (x+w, y+h), (B, G, R))</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<h3 id="检查面部"><a href="#检查面部" class="headerlink" title="检查面部"></a>检查面部</h3><p>opencv使用训练得到的级联(Cascade)文件来处理图像。opencv提供了一些默认的Cascade，可以处理人脸、车牌、眼睛等等。</p>
<ul>
<li>引入Cascade，如<ul>
<li><code>faceCascade = cv2.CascadeClassifier(&quot;path/to/Cascade/file&quot;)</code></li>
</ul>
</li>
<li>把图像换成灰度图</li>
<li>使用引入的Cascade处理图像<ul>
<li><code>faces = faceCascade.detectMultiScale(img, scale, minimum_neighbor)</code></li>
</ul>
</li>
<li>画框框  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.recrangle(img, (x, y), (x+w, y+h), (B, G, R), thick)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://github.com/murtazahassan/Learn-OpenCV-in-3-hours" target="_blank" rel="noopener">源码</a></p>
<h3 id="检查画笔颜色并在图像中画出"><a href="#检查画笔颜色并在图像中画出" class="headerlink" title="检查画笔颜色并在图像中画出"></a>检查画笔颜色并在图像中画出</h3><ul>
<li><ol>
<li><a href="#检测颜色">颜色检测</a>，创建蒙版<ul>
<li>为同时应对多种色彩，可以将检查到的颜色的参数记录在一个列表中</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>试着<a href="#检查图形">描出颜色的轮廓</a><ul>
<li>只是为了给出明显的反馈，用完可以删除</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>使用轮廓的参数如x，y就可确定一点的位置</li>
</ol>
</li>
<li><ol start="4">
<li>然后就可画出想要的BGR颜色<ul>
<li>创建一个点的列表，每次绘制出所有点[x, y, color]</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="物体扫描"><a href="#物体扫描" class="headerlink" title="物体扫描"></a>物体扫描</h3><ul>
<li>预处理<ul>
<li><a href="#摄像头获取">调整大小</a></li>
<li><a href="#转换灰度">使用灰度图</a></li>
<li><a href="#模糊">模糊</a></li>
<li><a href="#边缘检测器">描边</a><ul>
<li>调整边框粗细等</li>
</ul>
</li>
</ul>
</li>
<li>找到主体<ul>
<li>预处理好的图像该如何找到主体?</li>
<li>可通过<a href="#检查图形">拐角数</a>、最大面积等判断</li>
</ul>
</li>
<li>通过主体的拐角进行<a href="#变换">变换</a></li>
</ul>
<h3 id="车牌识别"><a href="#车牌识别" class="headerlink" title="车牌识别"></a>车牌识别</h3><ul>
<li><ol>
<li><a href="#检查面部">引入Cascade</a>，用于识别车牌号</li>
</ol>
</li>
<li><ol start="2">
<li>框出</li>
</ol>
</li>
<li><ol start="3">
<li>把识别出来的<a href="#绘制图形">数字放在图片的适当位置</a></li>
</ol>
</li>
<li><ol start="4">
<li>保存识别的图片<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"path/to/file"</span>, img)</span><br></pre></td></tr></table></figure>

















</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/universe/linux/exec_and_fork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/18/universe/linux/exec_and_fork/" class="post-title-link" itemprop="url">Fork & Exec in Linux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-18 00:00:00 / Modified: 21:13:28" itemprop="dateCreated datePublished" datetime="2020-07-18T00:00:00+08:00">2020-07-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在linux中启动新一个程序有两种方式：</p>
<ul>
<li>Fork(分叉)<ul>
<li>创建一个新的进程，该进程几乎是前一个进程的拷贝</li>
<li>子进程和父进程使用相同的代码段，子进程复制父进程的堆栈段和数据段</li>
<li>子进程对父进程的复制是逻辑上的复制，所有实际上物理空间还是共享着的，直到一个进程写了数据，才将有差别的”页”从物理地址上分开</li>
</ul>
</li>
<li>Exec<ul>
<li>启动另外的进程以取代当前运行的进程</li>
<li>调用exec的进程将会死亡，废弃原有的数据段和堆栈段，分配新的数据段和堆栈段，<strong>但是进程号是同一个</strong> 。所以对于系统来说还是同一个进程，但不是同一个程序了</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/universe/java/java_annotations_and_reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/universe/java/java_annotations_and_reflection/" class="post-title-link" itemprop="url">java注解与反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-17T00:00:00+08:00">2020-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-18 16:20:14" itemprop="dateModified" datetime="2020-07-18T16:20:14+08:00">2020-07-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解可以让程序读取，格式<code>@注解名(参数)</code></p>
<ul>
<li>常用注解<ul>
<li><code>@Override</code>：重写的方法</li>
<li><code>@Deprecated</code>：已经废弃的方法</li>
<li><code>@SuppressWarnings</code>：镇压警告</li>
</ul>
</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><strong>元注解负责注解其他注解</strong> 。java定义了4个标准meta-annotation类型，他们被用来提供对其他annotation类型作说明</p>
<ul>
<li><code>@Target</code>：表示这个注解可以注在什么地方：类、方法等</li>
<li><code>@Retention</code>：表示需要在什么级别保存注释信息，用于描述注解的生命周期(SOURCE &lt; CLASS &lt; RUNTIME)</li>
<li><code>@Documented</code>：说明改注解将被包含在javadoc中</li>
<li><code>@Inherited</code>：说明子类可以继承父类中的注解</li>
</ul>
<h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>使用<code>@interface</code>自定义注解时，自动继承了<code>java.lang.annotation.Annotation</code>接口。</p>
<ul>
<li><code>@interface</code>用来声明一个注解，格式<code>public @interface 注解名{定义内容}</code></li>
<li>其中的每一个方法实际上是声明了一个配置参数</li>
<li>方法名就是参数的名称</li>
<li>返回值类型就是参数的类型(返回值只能是基本类型)</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员，一般参数名为value，然后此时调用这个注解时可以省略一个value<code>@MyAnnotaion(&quot;hi&quot;)</code></li>
<li>注解元素必须要有值，我们定义注解时，经常使用空字符串、0作为默认值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;  <span class="comment">// 是注解的参数，而非一个方法</span></span><br><span class="line">    <span class="function">String <span class="title">addr</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;   <span class="comment">// 可设默认值 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation</span>(addr = <span class="string">"home"</span>, name = <span class="string">"ring"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>


<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul>
<li><p>反射让java具有动态性，反射机制允许程序在执行期间借助于Retention API获取任何类的内部信息，并能直接操作任意对象的内部属性和方法</p>
</li>
<li><p>加载完后，在堆内存的方法区中就产生了一个Class类型对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构</p>
</li>
<li><p>正常方式</p>
<ul>
<li>引入需要的”包类(包名和类名)”名称 -&gt; 通过new实例化 -&gt; 取得实例化对象</li>
</ul>
</li>
<li><p>反射方式</p>
<ul>
<li>实例化对象 -&gt; <code>getClass()</code>方法 -&gt; 得到完整的”包类”名称</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>可以实现动态创建和编译，灵活</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>对性能有影响，使反射基本上是一种解释操作。比较慢</li>
</ul>
</li>
</ul>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p><code>Class c1 = Class.forName(&quot;your.package.className&quot;);</code></p>
<h4 id="获取Class类是实例"><a href="#获取Class类是实例" class="headerlink" title="获取Class类是实例"></a>获取Class类是实例</h4><ul>
<li><ol>
<li>已知具体类，通过类的class属性获取，改方法最为安全可靠，程序性能高<ul>
<li><code>Class clazz = Person.class;</code></li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>已知某个类是实例，调用改实例的<code>getClass()</code>方法获取Class对象<ul>
<li><code>Class clazz = person.getClass();</code></li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>已知一个类的全类名，且该类在类路径下，可通过Class类静态方法<code>forName()</code>获取，可能抛出ClassNotFoundException<ul>
<li><code>Class clazz = Class.forName(&quot;demo01.Student&quot;);</code></li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>内置基本数据类型可直接用类名.Type</li>
</ol>
</li>
<li><ol start="5">
<li>可以利用ClassLoader，如获得父类的类型<code>son.getSuperclass();</code></li>
</ol>
</li>
</ul>
<h4 id="获取类运行时结构"><a href="#获取类运行时结构" class="headerlink" title="获取类运行时结构"></a>获取类运行时结构</h4><p>获取Class类实例后可以通过以下方法获取类运行时结构</p>
<ul>
<li>获得属性<ul>
<li><code>v = obj.getFields();</code><ul>
<li>可指定要获取的属性作为参数</li>
<li>获取公有的属性</li>
</ul>
</li>
<li><code>v = obj.getDeclareFields();</code><ul>
<li>可指定要获取的属性作为参数</li>
<li>获取全部属性</li>
</ul>
</li>
<li>使用：set，<code>v.set(obj, value);</code></li>
</ul>
</li>
<li>获得方法<ul>
<li><code>m = obj.getMethods();</code><ul>
<li>可指定要获取的方法(方法名和参数)作为参数</li>
<li>获取本类和父类的公有的方法</li>
</ul>
</li>
<li><code>m = obj.getDeclareMethods();</code><ul>
<li>可指定要获取的方法(方法名和参数)作为参数</li>
<li>获取本类的全部方法</li>
</ul>
</li>
<li>使用：Invoke(激活)，<code>m.invoke(obj, args);</code></li>
</ul>
</li>
<li>获得构造器<ul>
<li><code>obj = clazz.getConstructors();</code><ul>
<li>可指定要获取的构造器(需要的参数)作为参数</li>
<li>获取公有的构造器</li>
</ul>
</li>
<li><code>obj = clazz.getDeclareConstructors();</code><ul>
<li>可指定要获取的构造器(需要的参数)作为参数</li>
<li>获取本类的全部构造器</li>
</ul>
</li>
<li>使用：newInstance，<code>Type a = (Type)obj.newInstance(args);</code></li>
</ul>
</li>
<li>获得泛型</li>
</ul>
<h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h4><ul>
<li>java内存<ul>
<li>堆<ul>
<li>存放new的对象和数组</li>
<li>可以被所有的线程共享，不会存放别的对象引用</li>
</ul>
</li>
<li>栈<ul>
<li>存放基本变量</li>
<li>引用对象的变量</li>
</ul>
</li>
<li>方法区<ul>
<li>可以被所有线程共享</li>
<li>包含了所有的class和stack变量</li>
</ul>
</li>
</ul>
</li>
<li>类加载的过程<ul>
<li><ol>
<li>类加载(Load)<ul>
<li>将类的 <strong>class文件</strong> 读入内存，并为之创建一个java.lang.Class对象，此过程由类加载器完成</li>
<li>加载：将class文件字节码内容加载到内存，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>类的链接(Link)<ul>
<li>将类的二进制数据合并到JRE中</li>
<li>连接：将java类的二进制代码合并到JVM的运行状态之中的过程</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>类的初始化(Initialize)<ul>
<li>JVM负责对类进行初始化</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>类的初始化<ul>
<li>主动引用(一定发生类的初始化)<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先初始化它的父亲</li>
</ul>
</li>
<li>被动引用(不会发生类的初始化)<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li>
<li>通过数组定义类引用，不会触发类的初始化</li>
<li>引用常量不会触发类的初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><p>加载器将class文件字节码内容加载到内存，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中数据的访问入口。</p>
<p>类缓存：标准的JavaSE类加载器可以按要求查找类，一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间。JVM的垃圾回收机制可以回收这些Class对象。</p>
<h2 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h2><p>以ORM(Object relationship Mapping，对象关系映射)为例。类映射到数据库，类和表结构对应，属性和字段对应，对象和记录对应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Students</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">// 反射创建对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">"pkg.of.yours.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射获得注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得注解的value的值</span></span><br><span class="line">        TableStudent tablestudent = (TableStudent)c1.getAnnotation(TableStudent(TableStudent<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        String value = tablestudent.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得类指定的注解</span></span><br><span class="line">        Field f = c1.getDeclareField(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// 反射回去对象的属性</span></span><br><span class="line">        FieldStudent annotation = f.getAnnotation(FieldStudent<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(annotaion.columName());</span><br><span class="line">        System.out.println(annotaion.len());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@TableStudent</span>(<span class="string">"db_student"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="meta">@FieldStudent</span>(columName = <span class="string">"db_age"</span>, len = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> age;</span><br><span class="line">    <span class="meta">@FieldStudent</span>(columName = <span class="string">"db_name"</span>, len = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> name;</span><br><span class="line">    <span class="comment">// getter and setter and construction</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类上的注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) </span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> TableStudent&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义属性上的注解</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> FieldStudent&#123;</span><br><span class="line">    <span class="function">String <span class="title">columName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;++&gt;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/13/universe/linux/linux_kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/13/universe/linux/linux_kernel/" class="post-title-link" itemprop="url">深入理解linux内核</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-13 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-13T00:00:00+08:00">2020-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-15 10:27:22" itemprop="dateModified" datetime="2020-07-15T10:27:22+08:00">2020-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="庖丁解牛linux内核"><a href="#庖丁解牛linux内核" class="headerlink" title="庖丁解牛linux内核"></a>庖丁解牛linux内核</h1><h2 id="堆栈寄存器"><a href="#堆栈寄存器" class="headerlink" title="堆栈寄存器"></a>堆栈寄存器</h2><ul>
<li>esp, 堆栈指针</li>
<li>ebp，基址指针</li>
</ul>
<h3 id="利用堆栈实现函数的调用和返回"><a href="#利用堆栈实现函数的调用和返回" class="headerlink" title="利用堆栈实现函数的调用和返回"></a>利用堆栈实现函数的调用和返回</h3><ul>
<li>cs:eip总是指向下一条指令的地址，在跳转时cs:eip的值会根据程序需要被修改</li>
<li>call将当前cs:eip的值压入栈顶，cs:eip指向被调用函数的入口</li>
<li>ret从栈顶弹出原来保存在这里的cs:eip的值，放入cs:eip中</li>
</ul>
<h4 id="函数调用框架"><a href="#函数调用框架" class="headerlink" title="函数调用框架"></a>函数调用框架</h4><ul>
<li>调用者:<code>call func</code><ul>
<li>call把<code>call func</code>指令的下一条指令保存在栈顶，eip指向函数开始处</li>
</ul>
</li>
<li>被调用者:储存在某块地址  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 建立被调用者函数的堆栈框架</span><br><span class="line">push %ebp</span><br><span class="line">mov %esp,%ebp</span><br><span class="line"></span><br><span class="line">函数体</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拆除被调用者函数的堆栈框架</span><br><span class="line">movl %ebp,%esp</span><br><span class="line">pop %ebp</span><br><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<ul>
<li>call被调用前程序可能就有使用堆栈，esp到ebp之间的内容被占用</li>
<li>call执行之后<ul>
<li>当前cs:eip入栈，然后cs:eip指向函数开始，然后向下执行</li>
<li><code>push</code>和<code>mov</code>把ebp(原栈底)入栈，然后ebp指向esp，即开辟一段新的栈，供函数使用</li>
<li>函数调用结束后<code>mov</code>和<code>pop</code>恢复原来的栈顶和栈底</li>
<li>ret把栈顶元素(cs:eip)出栈，赋给cs:eip，即恢复原cs:eip</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="参数传入"><a href="#参数传入" class="headerlink" title="参数传入"></a>参数传入</h4><p>如调用一个两个参数的函数<code>func(x, y);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pushl 0xfffffff8(%ebp)</span><br><span class="line">pushl 0xfffffff4(%ebp) </span><br><span class="line">&#x2F;&#x2F; 先通过栈底+偏移的方式把局部变量压栈，方便在函数框架建立后使用</span><br><span class="line">&#x2F;&#x2F; 然后再call func建立函数框架</span><br><span class="line"></span><br><span class="line">call funn</span><br><span class="line">add $0x8,%esp</span><br><span class="line">&#x2F;&#x2F; 由于压入了两个参数，所以通过这样的方式来清理掉</span><br></pre></td></tr></table></figure>

<p>一个函数也会有自己的局部变量，所以函数框架创建后，编译器会扫描整个函数，然后计算需要的空间，位局部变量预留空间。以main函数为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    push %ebp</span><br><span class="line">    mov %esp,%ebp</span><br><span class="line">    sub 立即数,%esp  &#x2F;&#x2F; 为声明的变量预留空间</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    movl %ebp,%esp</span><br><span class="line">    pop %ebp</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断信号发生时，cpu把当前的eip、ebp等都压到  <strong>内核堆栈</strong> 保存现场。然后把eip指向中断处理程序入口，执行中断处理程序。</p>
<h2 id="嵌入汇编语法"><a href="#嵌入汇编语法" class="headerlink" title="嵌入汇编语法"></a>嵌入汇编语法</h2><p>内嵌汇编语法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">    汇编语句模板：</span><br><span class="line">    输出部分：</span><br><span class="line">    输入部分：</span><br><span class="line">    破坏描述部分：); <span class="comment">// 表示这代码可能会破坏哪个寄存器的内容等</span></span><br></pre></td></tr></table></figure>

<p>看个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// val1+val2=val3</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> val1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> val2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> val3 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl$0,%%eax\n\t"</span>  <span class="comment">// 把eax清0,%%转意</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"addl%1,%%eax\n\t"</span>  <span class="comment">// %eax+=val1</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// %1，%2等指下面输出和输入部分从0开始编号</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// 所以%1指val1</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"addl%2,%%eax\n\t"</span>  <span class="comment">// %eax+=val2</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl%%eax,%0\n\t"</span>  <span class="comment">// val2 = %eax</span></span></span></span><br><span class="line"><span class="function"><span class="params">    :<span class="string">"=m"</span>(val3)         <span class="comment">// =m指写到内存变量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    :<span class="string">"c"</span>(val1),<span class="string">"d"</span>(val2)<span class="comment">// c,d做修饰，指%eax,%edx，用ecx存val1，edx存val2</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"val1:%d+val2:%d=val3:%d\n"</span>, val1, val2, val3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="内嵌汇编常用修饰符-限定符"><a href="#内嵌汇编常用修饰符-限定符" class="headerlink" title="内嵌汇编常用修饰符(限定符)"></a>内嵌汇编常用修饰符(限定符)</h3><table>
<thead>
<tr>
<th></th>
<th>限定符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>“a”</td>
<td>将输入变量放入eax</td>
</tr>
<tr>
<td></td>
<td>“b”</td>
<td>将输入变量放入ebx</td>
</tr>
<tr>
<td></td>
<td>“c”</td>
<td>将输入变量放入ecx</td>
</tr>
<tr>
<td></td>
<td>“d”</td>
<td>将输入变量放入edx</td>
</tr>
<tr>
<td></td>
<td>“s”</td>
<td>将输入变量放入esi</td>
</tr>
<tr>
<td></td>
<td>“D”</td>
<td>将输入变量放入edi</td>
</tr>
<tr>
<td></td>
<td>“q”</td>
<td>将输入变量放入eax、ebx、ecx、edx中的一个</td>
</tr>
<tr>
<td></td>
<td>“r”</td>
<td>将输入变量放入通用寄存器中的一个</td>
</tr>
<tr>
<td>——-</td>
<td>“A”</td>
<td>放入eax和edx，把eax和edx，合成一个64位的寄存器</td>
</tr>
<tr>
<td>内存</td>
<td>“m”</td>
<td>内存变量</td>
</tr>
<tr>
<td></td>
<td>“o”</td>
<td>操作数为内存变量，但其寻址方式是偏移量类型</td>
</tr>
<tr>
<td></td>
<td>“V”</td>
<td>操作数为内存变量，但其寻址方式不是偏移量类型</td>
</tr>
<tr>
<td>——-</td>
<td>“.”</td>
<td>操作数为内存变量，但其寻址方式为自增量</td>
</tr>
<tr>
<td>寄存器或内存</td>
<td>“g”</td>
<td>将输入放入eax、ebx、ecx、edx中的一个或者作为内存变量</td>
</tr>
<tr>
<td>——-</td>
<td>“X”</td>
<td>操作数可以是任何类型</td>
</tr>
<tr>
<td>立即数</td>
<td>“I”</td>
<td>0-31之间的立即数(用于32位移位指令)</td>
</tr>
<tr>
<td></td>
<td>“J”</td>
<td>0-63之间的立即数(用于64位移位指令)</td>
</tr>
<tr>
<td></td>
<td>“N”</td>
<td>0-255之间的立即数(用于out指令)</td>
</tr>
<tr>
<td></td>
<td>“i”</td>
<td>立即数</td>
</tr>
<tr>
<td>——-</td>
<td>“n”</td>
<td>立即数，有些系统不支持除字以外的立即数，这些系统应该使用”n”</td>
</tr>
<tr>
<td>操作数类型</td>
<td>“=”</td>
<td>操作数在指令中是只写的(输出操作数)</td>
</tr>
<tr>
<td>——-</td>
<td>“+”</td>
<td>操作数在指令中是读写的(输入输出操作数)</td>
</tr>
<tr>
<td>浮点数</td>
<td>“f”</td>
<td>浮点数</td>
</tr>
<tr>
<td></td>
<td>“t”</td>
<td>第一个浮点数寄存器</td>
</tr>
<tr>
<td></td>
<td>“u”</td>
<td>第二个浮点数寄存器</td>
</tr>
<tr>
<td></td>
<td>“G”</td>
<td>标准的80387</td>
</tr>
<tr>
<td></td>
<td>%</td>
<td>该操作数可以和下一个操作数交换位置</td>
</tr>
<tr>
<td></td>
<td>#</td>
<td>部分注释，注释从该字符到气候的逗号之间的内容</td>
</tr>
<tr>
<td></td>
<td>*</td>
<td>表述如果选中寄存器，则其后的字母被忽略</td>
</tr>
</tbody></table>
<h3 id="用户态、内核态和中断处理过程"><a href="#用户态、内核态和中断处理过程" class="headerlink" title="用户态、内核态和中断处理过程"></a>用户态、内核态和中断处理过程</h3><p>CPU一般都有几种不同的指令执行级别。在高级级别下，代码可以执行 <strong>特权指令，访问访问任意物理地址</strong> ，这种CPU执行级别对应内核态，类似的用户态。</p>
<p>linux中如何区分用户态和内核态：一般来说地址空间是一个显著特征(cs:eip)，0xc0000000以上的地址空间只有在内核态下可以访问，0x00000000-0xbfffffff的地址空间两种状态都可以访问。</p>
<p>用户态可以传递系统调用号，系统调用根据系统调用号跳到内核态进行相应的处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/25/universe/python/python_network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/25/universe/python/python_network/" class="post-title-link" itemprop="url">python 网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-25T00:00:00+08:00">2020-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-11 11:28:32" itemprop="dateModified" datetime="2020-07-11T11:28:32+08:00">2020-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Socket基本使用"><a href="#Socket基本使用" class="headerlink" title="Socket基本使用"></a>Socket基本使用</h2><ul>
<li><p>创建套接字对象<code>socket.socket(AddressFamily, Type)</code></p>
<ul>
<li>udp: <code>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</code></li>
<li>tcp: <code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code></li>
<li>其中<code>AF_INET</code>表示IPv4，<code>SOCK_DGRAM</code>表示udp，<code>SOCK_STREAM</code>表示tcp</li>
</ul>
</li>
<li><p>绑定端口<code>s.bind((ip, port))</code>让程序使用固定的端口负责接收</p>
</li>
<li><p>发送数据</p>
<ul>
<li>udp: <code>s.sendto(data, (ip, port))</code>，如果没绑定端口则由系统随机分配</li>
<li>tcp: <code>s.send(data)</code></li>
</ul>
</li>
<li><p>接收数据</p>
<ul>
<li><ol>
<li>创建套接字</li>
</ol>
</li>
<li><ol start="2">
<li>必须绑定端口，让程序使用固定的端口负责接收</li>
</ol>
</li>
<li><ol start="3">
<li>接收<code>s.recvfrom(size)</code>，返回元祖<code>(data, src_ip)</code></li>
</ol>
</li>
</ul>
</li>
<li><p>单工：只能收/发</p>
</li>
<li><p>办双工：能收发，要收就不能发，要发就不能收</p>
</li>
<li><p>全双工：能收发，如打电话</p>
</li>
</ul>
<p>套接字可以同时收发，是全双工</p>
<h3 id="Socket中使用tcp"><a href="#Socket中使用tcp" class="headerlink" title="Socket中使用tcp"></a>Socket中使用tcp</h3><p>和udp的方法有些不同</p>
<ul>
<li>建立连接<ul>
<li><code>s.connect((ip, port))</code></li>
</ul>
</li>
<li>发送数据<ul>
<li>tcp: <code>s.send(data)</code></li>
</ul>
</li>
</ul>
<h3 id="tcp服务器"><a href="#tcp服务器" class="headerlink" title="tcp服务器"></a>tcp服务器</h3><p>一般需要以下步骤：</p>
<ul>
<li><p>创建套接字</p>
</li>
<li><p>bind绑定ip和port</p>
</li>
<li><p>listen使套接字变为被动链接</p>
<ul>
<li>被动：即可以让别人来呼叫</li>
</ul>
</li>
<li><p>accept等待客户端的链接</p>
<ul>
<li>返回一个元祖，<code>(client_socket, client_addr)</code><ul>
<li>可以通过<code>client_socket</code>向客户端发送数据</li>
</ul>
</li>
</ul>
</li>
<li><p>recv/send收发数据</p>
<ul>
<li>不同与recvfrom，recv只返回data，因为accept的时候已经知道来源地址了</li>
</ul>
</li>
<li><p>同时为多个客户端服务，并且多次服务一个客户端</p>
<ul>
<li>由于accept会阻塞进程(类似input)，如何同时为多个服务？<ul>
<li>多任务</li>
</ul>
</li>
<li>一个客户端不一定只需要一次服务，如何多次服务一个客户端？<ul>
<li>当一个客户端不需要服务的时候，即客户端调用close的时候，会使服务端recv解堵塞，返回空，以此做判断依据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h4><ul>
<li>三次握手：建立连接<ul>
<li>C: 服务器你准备好没？SYN</li>
<li>S: 准备好了SYN ACK，你呢？SYN</li>
<li>C: 我也好了SYN ACK</li>
</ul>
</li>
<li>四次挥手<ul>
<li>C: 拜拜<code>close()</code>，不再给你发数据了哦</li>
<li>S: 好的(recv不等收了)知道了</li>
<li>S: 我也不发了(close，也许会延时，所以是4次)</li>
<li>C: 好的(recv不用等待接收了)</li>
<li>服务器和客户端的接收都关了</li>
</ul>
</li>
<li>为什么一般是客户端先关闭的原因：<ul>
<li>客户端的消息这么知道服务器收到了？服务器发生确认。那服务器的确认如何知道被收到了？客户端发送确认…无穷无尽也</li>
<li>所以采用发起消息的一方设置超时时间(等待)，所以如果是服务器发起消息(close)那服务器就要进入等待(额外开销浪费)</li>
</ul>
</li>
</ul>
<h3 id="一个简单下载器的实现"><a href="#一个简单下载器的实现" class="headerlink" title="一个简单下载器的实现"></a>一个简单下载器的实现</h3><ul>
<li>服务端<ul>
<li>根据用户需求寻找文件</li>
<li>将文件数据发送给客户</li>
</ul>
</li>
<li>客户端<ul>
<li>在本地新建一个同名文件</li>
<li>将从服务接收(recv)到的数据写入(二进制模式)文件即完成下载任务</li>
</ul>
</li>
</ul>
<h3 id="TCP注意点"><a href="#TCP注意点" class="headerlink" title="TCP注意点"></a>TCP注意点</h3><ul>
<li>tcp服务器一般绑定端口<ul>
<li>否则客户端找不到服务器</li>
</ul>
</li>
<li>tcp客户端一般不绑定端口<ul>
<li>因为连接服务器只需服务器的ip、port等。而且如果绑定不利于客户端多开</li>
</ul>
</li>
<li>tcp服务通过listen将socket创建出来的主动套接字变为被动是必要的</li>
<li>关闭listen后的套接字意味着被动套接字关闭了，新的客户端不能连接，但之前已经连接成功的客户端正常通信</li>
</ul>
<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><h3 id="Thread的基本使用"><a href="#Thread的基本使用" class="headerlink" title="Thread的基本使用"></a>Thread的基本使用</h3><p>对于单核cpu，可以在程序间快速切换，以达到多任务的效果，如：qq执行0.00001s，然后切换到微信。如此快速切换以致于人无法察觉，来实现多任务。但本质操作系统调度，一次执行一个任务，这样的方式称为并发。</p>
<p>对于多核cpu，每个核功能同单核，多个核在可以同时多个任务。这些在不同核中执行的进程的方式称为并行。真正意义的多任务。</p>
<p>thread使用需要引入threading模块：<code>import threading</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=func_pointer1, args=(args,))  <span class="comment"># 返回对象，参数以元祖方式传入</span></span><br><span class="line">t2 = threading.Thread(target=func_pointer2, args=(args,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>

<p>创建子线程t1、t2，通过start()来开始执行子线程，开启后执行下一行，子线程在后台执行，子线程执行完后主线程关闭。这样就实现了t1、t2多任务。</p>
<ul>
<li><code>threading.enumerate()</code><ul>
<li>以列表形式返回正在运行的线程</li>
<li>查看线程数量:<code>len(threading.enumerate())</code></li>
</ul>
</li>
<li><code>t.start()</code><ul>
<li>start实际上是调用了<code>threading.Thread</code>的<code>run(self)</code>方法，所以可以通过继承然后重载run方法</li>
</ul>
</li>
<li>多线程间是共享全局变量的<ul>
<li>同时对一个数据进行写入操作会存在问题，因为写入操作大致可分为这么几个步骤：读取数据、操作数据、写入数据。由于cpu在线程间切换，如果操作数据后切换到另一个进程，然后才写入数据，将导致问题。</li>
<li>互斥锁解决资源竞争<ul>
<li>创建互斥锁：<code>mutex = threading.Lock()</code></li>
<li>锁定：<code>mutex.acquire()</code>，如果已经上锁会阻塞直到解锁</li>
<li>释放：<code>mutex.release()</code></li>
</ul>
</li>
<li>多个互斥锁会出现的问题<ul>
<li>死锁：线程A等线程B用完资源，偏偏资源B在等A用完资源，的状态叫做死锁，如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">()</span>:</span></span><br><span class="line">    mutexA.acquire()</span><br><span class="line">    mutexB.acquire()</span><br><span class="line">    mutexB.release()</span><br><span class="line">    mutexA.release()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcB</span><span class="params">()</span>:</span></span><br><span class="line">    mutexB.acquire()</span><br><span class="line">    mutexA.acquire()</span><br><span class="line">    mutexA.release()</span><br><span class="line">    mutexB.release()</span><br></pre></td></tr></table></figure></li>
<li>避免死锁：<ul>
<li>程序设计时尽量避免(银行家算法等)</li>
<li>添加超时时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程方式"><a href="#进程方式" class="headerlink" title="进程方式"></a>进程方式</h3><p>需要<code>multiprocessing</code>模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">p = multiprocessing.Process(target=func_pointer, args=(args,))</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>由于是进程，所有可以在shell中查看<code>ps -aux</code>，也可以进行任何进程操作<ul>
<li>但是耗费的资源也比线程大</li>
</ul>
</li>
<li>进程间是互相独立的，进程间如何通信呢？<ul>
<li>队列，直接在内存中操作<ul>
<li><strong>multiprocessing.Queue()</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q = multiprocessing.Queue()</span><br><span class="line">q.put(arg)</span><br><span class="line">q.get()</span><br><span class="line">q.get_nowait()</span><br><span class="line">q.full()</span><br><span class="line">q.empty()</span><br></pre></td></tr></table></figure></li>
<li>当队列为空时get方法会阻塞，get_nowait方法会引发异常来告诉你队列为空</li>
<li>如果队列满了put方法会阻塞</li>
</ul>
</li>
<li>使用队列来减少进程的耦合(解耦)<ul>
<li>进程A往queue填数据，只需关注写</li>
<li>进程B从queue取数据，只需关注读</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h4><p>一个可以容纳很多进程的特殊容器。它 <strong>重复利用进程池里的进程</strong> ，因为进程并非越多越好，会增加操作系统调度的压力。进程池减轻了进程创建和销毁的负担。</p>
<ul>
<li>进程池创建<ul>
<li><code>from multiprocessing import Pool</code></li>
<li><code>po = Pool(n)</code>，设置最对创建的个数，这里是n<ul>
<li>可以往里添加无数个，但最对同时运行n个进程，其他存起来</li>
</ul>
</li>
<li>添加到进程池：<code>po.apply_async(func_pointer, (args,))</code></li>
<li>进程池关闭<code>po.close()</code></li>
<li><code>po.join()</code>等到进程池中所有子进程执行完成， <strong>join必须放在close之后</strong><ul>
<li>因为使用进程池不会阻塞主进程，所以可能子进程还没结束，主进程先结束了，导致所以子进程结束</li>
</ul>
</li>
</ul>
</li>
<li>进程池里的任务产生的异常不会产生错误信息</li>
<li>显示进度<ul>
<li>通过队列在进程间通信，子进程完成后写入队列，主进程从队列读，统计<ul>
<li><strong>进程的队列要使用 <code>multiprocessing.Manager().Queue()</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="协程方式"><a href="#协程方式" class="headerlink" title="协程方式"></a>协程方式</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li>可迭代<ul>
<li><code>isinstance(ar, Iterable)</code></li>
<li>必须实现<code>__iter__</code>方法， <strong>返回一个迭代器</strong> ，<code>return Iterator(self)</code>，如果这个类本身是个迭代器(实现了<code>__next__</code>)则可以返回self</li>
</ul>
</li>
<li>迭代器<ul>
<li><code>isinstance(ar, Iterator)</code></li>
<li>必须实现<code>__iter__</code>方法和 <strong><code>__next__</code>方法</strong></li>
<li>使用<code>raise StopIteration</code>来表示迭代结束</li>
<li><code>iter(Iterable)</code>方法气质其实调用了类的<code>__iter__()</code>，返回类的迭代器，for in就是调用了<code>__iter__()</code>获得迭代器的</li>
<li><code>next(Iterator)</code>方法调用迭代器的<code>__next__()</code>方法</li>
<li>转换成list转化成tuple也是使用了迭代器</li>
</ul>
</li>
</ul>
<p>迭代器储存生成这个数据的方式，而不是生成这个数据的结果。占用极小的内存空间</p>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是一种特殊的迭代器</p>
<ul>
<li>列表式创建生成器：<code>nums = (x for x in range(10))</code><ul>
<li>不同于<code>nums = [x for x in range(10)]</code>直接返回结果，生成器返回生成数据的方式</li>
</ul>
</li>
<li>函数变成生成器<ul>
<li>使用<code>yield</code>返回生成器对象<ul>
<li>yield相当于返回值后把函数暂停，下次使用将从上一次的位置继续向下走</li>
<li>获取生成器return的结果，一般捕获异常，<code>except StopIteration as ret</code>，然后使用<code>ret.value</code>取得返回值</li>
</ul>
</li>
</ul>
</li>
<li>通过<code>send</code>启动生成器：<code>gen.send(args)</code><ul>
<li>同一会执行一次<code>__next__</code>，但区别于<code>next</code>，<code>send</code>能往里传参数</li>
<li><code>ret = yield x</code>，由于<code>yield x</code>返回给外面，没有返回值，所以<code>ret=None</code>。send传递的参数args使得<code>ret=args</code><ul>
<li>一般用于更新状态</li>
</ul>
</li>
<li>第一次迭代使用send会出错</li>
</ul>
</li>
</ul>
<h4 id="使用yield实现多任务"><a href="#使用yield实现多任务" class="headerlink" title="使用yield实现多任务"></a>使用yield实现多任务</h4><p>使用yield把普通函数转化成生成器，这样对于一个含有无限循环的函数，每轮yield后就会暂停，让下一行代码执行。这就实现了用函数实现并行。</p>
<p>但不同于操作系统级的并行(上下文切换开销相当大)，这样的多任务就像使用一个函数一样简单。</p>
<p>开销：$进程&gt;线程&gt;协程$</p>
<p>但这样存在一个问题，如果有100个这样的函数要写100个调用？这时需要使用<code>gevent</code></p>
<p>geven是一个基于协程的并发库</p>
<ul>
<li><code>greenlet</code>：对yield进行了封装<ul>
<li>创建greenlet对象：<code>gr1 = greenlet(func_pointer)</code>，对函数进行封装，传入普通函数就行，不需要yield返回了。</li>
<li>切换：<code>gr1.switch()</code>切换到gr1(封装的函数)<ul>
<li>如果在函数1中<code>switch</code>到函数2，函数2switch到函数1，就和yield效果一样</li>
</ul>
</li>
</ul>
</li>
<li><code>gevent</code>：对greenlet进行封装<ul>
<li>创建：<code>g1 = gevent.spawn(func, arg1, arg2, ...)</code></li>
<li>特点：遇到<code>gevent.sleep()</code>会切换，greenlet遇到延时会等待<ul>
<li>因此在结尾写上<code>g1.join()</code>(等待g1执行完成，实现了geven.sleep)，使它遇到了延时，它就自动切换执行</li>
<li><code>geven.joinall([list])</code>，把所有geven对象放入列表就会等待列表内所有</li>
</ul>
</li>
<li><code>monkey.patch_all()</code>，是否所有的延时都要手动换成<code>geven.sleep</code>？<ul>
<li>使用<code>monkey.patch_all()</code>它会自动将延时换成<code>geven.sleep</code>，包括网络延时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>报文格式</p>
<ul>
<li>请求行<ul>
<li>方法 URL 版本</li>
<li>包含一系列必要信息</li>
</ul>
</li>
<li>首部行(optional)<ul>
<li>首部字段: 值</li>
<li>相当于指定配置</li>
</ul>
</li>
<li>空行<ul>
<li>通过空行来分割头和body</li>
<li>浏览器通过<code>\r\n</code>解析换行</li>
</ul>
</li>
<li>实体主体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- 请求行 ---</span><br><span class="line">GET &#x2F;some&#x2F;dir HTTP&#x2F;1.1</span><br><span class="line">--- 首部行 ---</span><br><span class="line">Host: www.some.com           # 指明对象所在的主机, 该首部行的Web高速缓存所要求的</span><br><span class="line">Connection: close            # 非持续连接</span><br><span class="line">User-agent: Mozilla&#x2F;5.0      # 发送请求的浏览器类型</span><br><span class="line"># 还会有很多的配置，首部行是连续的，如果遇到空行则说明首部行结束，进入body</span><br></pre></td></tr></table></figure>

<p>当请求一个页面的时候，返回html，html不会有图片(css、视频或且它等)的数据但会有图片的超链接。浏览器解析到超链接会自动发送一个新的请求，因此可以从一个请求中生出很多个请求。</p>
<ul>
<li>多进程web服务器<ul>
<li>因为子进程会复制父进程的资源，所有子进程里close了父进程里还有close</li>
</ul>
</li>
<li>多线程web服务器<ul>
<li>如果是使用多线程Thread，不会复制父进程资源，子线程里close了父进程就不需要close了</li>
</ul>
</li>
<li>不论是多进程还是多线程，都要创建一个子进程/线程，如果有很多人同时请求服务(如双11)开销相当大</li>
<li>使用协程的web服务器<ul>
<li><ol>
<li>使用gevent</li>
</ol>
</li>
<li><ol start="2">
<li>非阻塞方式使用socket实现单进程单线程监听多个套接字<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s.setblocking(<span class="literal">False</span>)  <span class="comment"># 使用非阻塞方式</span></span><br><span class="line">client_socket_list = list()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       new_socket, new_addr = s.accept() </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">        print(ret)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_socket.setblocking(<span class="literal">False</span>)  <span class="comment"># 新socket使用非阻塞方式</span></span><br><span class="line">        client_socket_list.append(new_socket)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> client_socket <span class="keyword">in</span> client_socket_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            recv_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">            print(ret)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> recv_data:</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 对方关闭了</span></span><br><span class="line">                client_socket.close()</span><br><span class="line">                client_socket_list.remove(client_socket)</span><br></pre></td></tr></table></figure>
<ul>
<li>但这么做列表越大效率越低</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><ul>
<li>长连接<ul>
<li>用同一个连接获取数据</li>
<li>http1.1</li>
</ul>
</li>
<li>短连接<ul>
<li>获取一个数据建立一个连接</li>
<li>http1.0</li>
</ul>
</li>
</ul>
<p>我们之前每一轮都关闭连接，虽然说是HTTP1.1，实际我们一直用短连接的方式传输</p>
<p>短连接模式，浏览器通过接受close知道包的内容范围。但如果使用长连接，连接不close，浏览器如何知道包的范围？</p>
<p>使用长连接，需要在header中标注<code>Content-Length</code>，告诉浏览器包的长度，这样浏览器在获取全部内容后主动断开连接，服务器再断开。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>在单进程单线程服务多用户的实例中，使用列表把所有连接存储起来。但这样随着列表变大，效率将变低。因为需要拷贝fc(文件描述符)到内核的内存空间，这样轮循+拷贝的方式效率相当低。</p>
<p>epoll有个特殊的内存空间，操作系统和应用程序共用。在这个内存中的所有要监听的套接字检测时不采用轮循而是方式事件通知的方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> select  <span class="comment"># 引入模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建epoll对象</span></span><br><span class="line">epl = select.epoll()  <span class="comment"># 创建这样的共享内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将监听套接字对应的fd注册到epoll</span></span><br><span class="line">epl.register(your_socket.fileno(), <span class="comment"># fileno()返回fd</span></span><br><span class="line">            select.EPOLLIN)  <span class="comment"># EPOLLIN表示监听是否有输入</span></span><br><span class="line"></span><br><span class="line">epl.poll()  <span class="comment"># 默认阻塞，知道OS检测到数据到来，通过事件通知的方式告诉程序，才会解阻塞</span></span><br><span class="line"><span class="comment"># 返回列表，一次通知多个[(fd, event), (套接字对应的文件描述符, 对应的事件)]</span></span><br></pre></td></tr></table></figure>

<h2 id="python提高"><a href="#python提高" class="headerlink" title="python提高"></a>python提高</h2><h3 id="GIL-全局解释器锁"><a href="#GIL-全局解释器锁" class="headerlink" title="GIL(全局解释器锁)"></a>GIL(全局解释器锁)</h3><p>保证多线程程序同一时间只有一个线程在执行。多个线程先强锁。</p>
<p>c语言写的python解释器存在GIL。</p>
<p>一面试题</p>
<blockquote>
<p>描述python GIL的概念，以及它对python多线程的影响。编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否比单线程性能有提升，并解释原因</p>
</blockquote>
<p>参考答案</p>
<blockquote>
<ul>
<li><ol>
<li>python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython解释器，难以移除GIL</li>
</ol>
</li>
<li><ol start="2">
<li>GIL：全局解释器锁。每个线程在执行的过程都需要先抢GIL，保证同一时刻只有一个线程可以执行</li>
</ol>
</li>
<li><ol start="3">
<li>线程释放GIL锁的情况：在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GIL python3.x使用计时器(执行时间到达阀值后，当前线程释放GIL)或python2.x的tickels计数到100</li>
</ol>
</li>
<li><ol start="4">
<li>python使用多进程可以利用多核CPU资源</li>
</ol>
</li>
<li><ol start="5">
<li>多线程爬取性能有提升，因为遇到IO阻塞(如网络)会自动释放GIL锁</li>
</ol>
</li>
</ul>
</blockquote>
<p>IO密集型程序适合用多线程</p>
<h3 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h3><p>赋值语句在python中一般都是引用</p>
<ul>
<li>深拷贝<code>copy.deepcopy</code><ul>
<li><code>import copy</code></li>
<li><code>b = copy.deepcopy(a)</code></li>
<li><code>id(a) != id(b)</code></li>
<li>如果拷贝的是元祖，且元祖里有可变的数据，设元祖a，则deepcopy结果<code>id(a)!=id(b)</code></li>
</ul>
</li>
<li>浅拷贝<code>copy.copy</code><ul>
<li><code>import copy</code></li>
<li><code>b = copy.copy(a)</code></li>
<li><code>id(a) != id(b)</code></li>
<li>但是如果拷贝的是元祖，且元祖里只有普通数据(不可变的)，设元祖a，则copy结果<code>id(a)==id(b)</code><ul>
<li>因为元祖是不可变类型，增删改都没用所以拷贝有什么用，所有就不拷贝</li>
</ul>
</li>
</ul>
</li>
<li>切片也是浅拷贝</li>
<li>字典<code>key: value</code>，value是指向别处的引用</li>
<li>浅拷贝和深拷贝的区别  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">c = [a, b]  <span class="comment"># c中的a、b都是引用，引用指向两个列表</span></span><br><span class="line">d = copy.deepcopy(c)</span><br><span class="line">e = copy.copy(c)</span><br><span class="line"><span class="comment"># 虽然id(c)!=id(e)但是e中的[1, 2]、[3, 4]仍是a、b的引用，仅仅是把c的东西原封不动复制到e</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="私有化"><a href="#私有化" class="headerlink" title="私有化"></a>私有化</h3><p>不同于面向对象的语言，python没有public、private等关键字。</p>
<ul>
<li>xx：共有变量</li>
<li>_x：单前置下划线，私有化属性或方法，<code>from somemodule import *</code>不会导入<code>_x</code>变量，类和对象子类可以访问</li>
<li>__xx：双前置下划线，私有化属性或方法，避免与子类中的属性冲突，无法在外部直接访问(名字重整所以访问不到)</li>
<li>__xx__：双前后下划线，用户名字空间的魔法对象属性，非私有</li>
<li>xx_：单后置下划线，用于避免与python关键词的冲突</li>
</ul>
<h3 id="import问题"><a href="#import问题" class="headerlink" title="import问题"></a>import问题</h3><p>程序执行时添加新的模块路径</p>
<p><code>sys.path</code>是个储存了模块路径的列表，因此可以使用列表操作改变搜索路径的优先级以及添加新路径</p>
<h4 id="重新导入模块问题"><a href="#重新导入模块问题" class="headerlink" title="重新导入模块问题"></a>重新导入模块问题</h4><p>import会防止模块重复导入，如果在程序执行期间修改了模块，即使使用import再次导入，修改的模块不会更新。需要使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"></span><br><span class="line">reload(somemodule)  <span class="comment"># 使用这种方式在不退出程序的情况下重新导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是对于from aa import bb这样的需求没有办法</span></span><br></pre></td></tr></table></figure>


<h4 id="多模块导入问题"><a href="#多模块导入问题" class="headerlink" title="多模块导入问题"></a>多模块导入问题</h4><p>在大型项目中一般会把很长的代码拆分成很多小的模块，这时模块间的数据传递就需要注意。一般把公共数据放在一个模块，这样方便访问、修改。</p>
<p><code>import aa</code>，<code>aa.bb = a</code>和<code>from aa import bb</code>，<code>bb=a</code>的区别</p>
<ul>
<li><code>import aa</code>使aa指向模块，则<code>aa.bb = a</code>是对模块aa的bb赋值，会改变aa中bb的值</li>
<li><code>from aa import bb</code>使得变量bb <strong>指向</strong> 模块aa中的同名变量bb，如果使用<code>bb = a</code>使得bb的指向改变，不会改变aa中的bb的值</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="多继承以及MRO顺序"><a href="#多继承以及MRO顺序" class="headerlink" title="多继承以及MRO顺序"></a>多继承以及MRO顺序</h4><ul>
<li>调用父类方法的方式<ul>
<li><ol>
<li>通过父类的名字调用<ul>
<li>缺点是会根据类递归的调用，无形中造成资源浪费。如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class A:</span><br><span class="line">    __init__(self):</span><br><span class="line">        new_socket</span><br><span class="line">Class B(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        A.__init__(self)</span><br><span class="line">Class C(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        A.__init__(self)</span><br><span class="line">Class D(B, C):</span><br><span class="line">    __init__(self):</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        C.__init__(self) </span><br><span class="line"><span class="comment"># B和C的init分别调用A的init导致多创建一个socket，造成浪费</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>通过<code>super().xxx</code>调用<ul>
<li>不是更具类递归的调用，而是根据<code>ClassName.__mro__</code>中的顺序调用，保证了每个类只调用一次</li>
<li>如果多继承了多个同名方法，则根据<code>ClassName.__mro__</code>中的顺序决定super().xxx调用的是哪个(先后顺序)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class A:</span><br><span class="line">    __init__(self):</span><br><span class="line">        new_socket</span><br><span class="line">Class B(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        supter.__init__(self)</span><br><span class="line">Class C(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        super.__init__(self)</span><br><span class="line">Class D(B, C):</span><br><span class="line">    __init__(self):</span><br><span class="line">        super().__init__(self)</span><br><span class="line"><span class="comment"># 其中print(D.__mro__)=(D, B, C, A, object)</span></span><br><span class="line"><span class="comment"># 那么如果从D开始，如果父类都有调用super，则会根据mro中的顺序调用，即D、B、C、A</span></span><br></pre></td></tr></table></figure></li>
<li><code>super(ClassName, self)</code>，会从ClassName往后开始调用，如<code>super(B, self)</code>则顺序是B、C、A。默认从当前类开始</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><ul>
<li><code>func(a, *args, **kwargs)</code><ul>
<li>一个<code>*</code>号以元祖的形式传递参数，变量名是args，<code>*</code>号只是告诉编译器</li>
<li>两个<code>*</code>号以字典的形式传递参数，变量名是kwargs<ul>
<li><strong>接收关键字参数</strong> ：如<code>func(1, 2, 3, 4, age=&#39;12&#39;, name=&#39;ring&#39;)</code><ul>
<li>args=(2, 3, 4)</li>
<li>kwargs={‘age’: ‘12’, ‘name’: ‘ring’}</li>
</ul>
</li>
<li>需要注意的是如果传的是一个字典，它并不是关键字参数，而是一个字典(一个整体)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="静态方法和属性方法"><a href="#静态方法和属性方法" class="headerlink" title="静态方法和属性方法"></a>静态方法和属性方法</h4><ul>
<li>类对象和实例对象<ul>
<li>创建一个对象会从模板类中调用<code>__new__</code>分配内存空间，<code>__init__</code>初始化内存空间，<code>__class__</code>指向创建这个实例对象的类对象</li>
<li>对于公有的方法、属性存储在类对象中<ul>
<li>如方法<code>__inti__(self)</code>就不必每个实例都有一份，放在类对象中即可</li>
</ul>
</li>
<li>对于特有的方法、属性存储在类对象中<ul>
<li>如初始化name=ring，那么对于这个实例的name是ring，别的实例有所区别</li>
</ul>
</li>
</ul>
</li>
<li>类方法、实例方法、静态方法<ul>
<li>实例方法：一般的方法<ul>
<li>很难修改类属性，若<code>obj.class_state=&quot;xx&quot;</code>原来<code>class_state</code>是一个类属性。这个方法将导致实例里面新增一个名为<code>class_state</code>的属性<ul>
<li>要修改也是可以的<code>obj.__class__.class_state=&quot;xx&quot;</code>就可以修改<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">        <span class="comment"># 实例方法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span>  <span class="comment"># 默认传实例对象的引用self</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    ```  </span><br><span class="line">* 类方式：用`@classmethod`装饰</span><br><span class="line">    ``` python</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">        @classmethod  # 类方法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(cls)</span>:</span>  <span class="comment"># python解释器默认把类对象引用cls传入</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>可以修改类属性</li>
</ul>
</li>
<li>静态方法：用<code>@staticmethod</code>装饰<ul>
<li>相当于在类外定义一个函数， <strong>不让python解释权默认传入类对象或实例对象</strong> 。写在类中是为例在不同类中区分开来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="property属性"><a href="#property属性" class="headerlink" title="property属性"></a>property属性</h4><ul>
<li>用装饰器创建<ul>
<li>让代码更简洁，调用一个函数像取值、赋值一样</li>
<li>在普通方法前用<code>@property</code>修饰，如。把调用方法改成”调用属性”，但实际还是调用方法，只是可读性更高  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 必须返回一个值，且参数只有self</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.func  <span class="comment"># 可以通过a.func调用，而不用a.func()</span></span><br></pre></td></tr></table></figure></li>
<li>新式类(继承object，python3默认继承)中有3中property装饰器  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>   <span class="comment"># 获取值</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 要同名，且传入新值value</span></span><br><span class="line">        print(<span class="string">"some"</span>)  <span class="comment"># 设置值</span></span><br><span class="line">    <span class="comment"># 如可以调用xxx.func = 100</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"some"</span>)  <span class="comment"># 删除值</span></span><br><span class="line">    <span class="comment"># 如可以调用del xxx.func</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过类属性创建<ul>
<li><code>property(arg1, arg2, arg3, arg4)</code><ul>
<li>参数1是方法名，调用<code>对象.属性</code>时自动触发执行</li>
<li>(可选)参数2是方法名，调用<code>对象.属性=xx</code>时自动触发执行</li>
<li>(可选)参数3是方法名，调用<code>del 对象.属性</code>时自动触发执行</li>
<li>(可选)参数4是字符串，调用<code>对象.属性.__doc__</code>时此参数是该属性的描述信息<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    FUNC = property(func)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.FUNC</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="修改私有属性"><a href="#修改私有属性" class="headerlink" title="修改私有属性"></a>修改私有属性</h4><p>私有属性(在以<code>__</code>开头的变量)之所以无法访问是因为python悄悄改了变量名。如把<code>__func</code>改成了<code>_className__func</code>。所以使用这个改后的名就可以访问私有属性。这机制叫做名字重整。</p>
<h4 id="魔法属性-方法"><a href="#魔法属性-方法" class="headerlink" title="魔法属性/方法"></a>魔法属性/方法</h4><ul>
<li><code>__doc__</code>和<code>help()</code><ul>
<li>使用<code>var.__doc__</code>或<code>help(var)</code>可以查看写在开头的描述</li>
</ul>
</li>
<li><code>__module__</code>和<code>__class__</code><ul>
<li><code>__class__</code>表示当前操作的对象的类是什么</li>
<li><code>__module__</code>表示当前操作的对象是在哪个模块</li>
</ul>
</li>
<li><code>__init__</code><ul>
<li><strong>初始化</strong> 方法，创建类对象时自动触发执行</li>
</ul>
</li>
<li><code>__del__</code><ul>
<li>对象释放时，自动触发执行</li>
</ul>
</li>
<li><code>__call__</code><ul>
<li>对象后面加括号，触发执行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = classA()</span><br><span class="line">obj()   <span class="comment"># obj.__call__()</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>__dict__</code><ul>
<li>类或对象的所有属性</li>
</ul>
</li>
<li><code>__str__</code><ul>
<li>如果一个类中定义了<code>__str__</code>方法，那么打印对象时，默认输出改方法的返回值</li>
</ul>
</li>
<li><code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem</code><ul>
<li>如果类中实现了这3个方法，则可以当字典用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(key)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(key)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(key)</span><br><span class="line"></span><br><span class="line">odj = A()</span><br><span class="line">res = obj[<span class="string">'k1'</span>]   <span class="comment"># __getitem__</span></span><br><span class="line">obj[<span class="string">'k2'</span>] = <span class="string">'abc'</span> <span class="comment"># __setitem__</span></span><br><span class="line"><span class="keyword">del</span> obj[<span class="string">'k3'</span>]     <span class="comment"># __delitem__</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>__getslice__</code>、<code>__setslice__</code>、<code>__delslice__</code><ul>
<li>如果类中实现了这3个方法，则可以用于分片操作，如列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setslice__</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delslice__</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">odj = A()</span><br><span class="line">obj[<span class="number">-1</span>:<span class="number">1</span>]            <span class="comment"># __getslice__</span></span><br><span class="line">obj[<span class="number">0</span>:<span class="number">1</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># __setslice__</span></span><br><span class="line"><span class="keyword">del</span> obj[<span class="number">0</span>:<span class="number">2</span>]         <span class="comment"># __delslice__</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h4 id="with与上下文管理器"><a href="#with与上下文管理器" class="headerlink" title="with与上下文管理器"></a>with与上下文管理器</h4><p>使用with打开文件能够保证最终文件都会关闭。如果采用传统的<code>f = open()</code>则需要try-catch辅助。with是一种更简洁的写法。</p>
<ul>
<li>上下文管理器<ul>
<li>任何实现了<code>__enter__()</code>和<code>__exit__()</code>方法的对象都可称之为上下文管理器。</li>
<li><code>__enter__()</code>返回资源对象</li>
<li><code>__exit__()</code>处理一些清理工作</li>
</ul>
</li>
</ul>
<p>当一个对象实现了上下文管理器，就可以使用with语句了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> obj(args) <span class="keyword">as</span> f:  </span><br><span class="line">    <span class="comment"># obj()创建实例对象</span></span><br><span class="line">    <span class="comment"># with自动调用了obj(上下文管理器)的__enter__方法，enter的返回值赋给f</span></span><br><span class="line">    <span class="comment"># 如果产生了异常，将自动调用__exit__方法</span></span><br></pre></td></tr></table></figure>


<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>多层函数嵌套、往往内部函数用到外部函数的变量，一个特殊的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(a*x + b)</span><br><span class="line">    <span class="keyword">return</span> solve</span><br><span class="line"></span><br><span class="line">ans = func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 创造单独空间，包含参数a, b和solve函数。a, b相当于solve的全局变量</span></span><br><span class="line"><span class="comment"># 类似类，但比类开销小</span></span><br><span class="line">ans(<span class="number">0</span>)</span><br><span class="line">ans(<span class="number">1</span>)</span><br><span class="line">ans(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x  <span class="comment"># 告诉解释器x不是solve中的，否则由于x=10的存在。会导致解释器认为x这个局部变量在声明前使用</span></span><br><span class="line">        print(x)</span><br><span class="line">        x = <span class="number">10</span>  </span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> solve</span><br></pre></td></tr></table></figure>


<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>有时候我们需要进行一下重复的过程, 比如计算函数用时. 如果我们直接把逻辑写在函数内部, 逻辑混乱且可读性不高。这时我们就可以使用装饰器</p>
<h4 id="装饰器的基本实现过程"><a href="#装饰器的基本实现过程" class="headerlink" title="装饰器的基本实现过程"></a>装饰器的基本实现过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  # 等价于test=set_func(test)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<h4 id="有参数的装饰器实现过程"><a href="#有参数的装饰器实现过程" class="headerlink" title="有参数的装饰器实现过程"></a>有参数的装饰器实现过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(a)</span>:</span>  <span class="comment"># 参数100会传到这</span></span><br><span class="line">        func(a)</span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h4 id="不定参数的装饰器实现过程"><a href="#不定参数的装饰器实现过程" class="headerlink" title="不定参数的装饰器实现过程"></a>不定参数的装饰器实现过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 参数会传到这，这里的星号是告诉解释器</span></span><br><span class="line"></span><br><span class="line">        func(*args, **kwargs)  <span class="comment"># 这里的星号是拆包!!!，否则就是一个列表、一个字典</span></span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(age, num, *args, &amp;&amp;kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h4 id="带有返回值的装饰器实现"><a href="#带有返回值的装饰器实现" class="headerlink" title="带有返回值的装饰器实现"></a>带有返回值的装饰器实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 比包里调用，返回出去</span></span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(age, num, *args, &amp;&amp;kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h4 id="给装饰器的参数"><a href="#给装饰器的参数" class="headerlink" title="给装饰器的参数"></a>给装饰器的参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">option</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> call_func</span><br><span class="line">    <span class="keyword">return</span> set_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@option(args)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(age, num, *args, &amp;&amp;kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>装饰器需要一个函数指针，即@后跟函数名，由于option(args)不符合，所以先向下执行option(args)，返回的函数指针。@心满意足，用来装饰test函数</p>
<h4 id="多个装饰器对同一个函数进行装饰"><a href="#多个装饰器对同一个函数进行装饰" class="headerlink" title="多个装饰器对同一个函数进行装饰"></a>多个装饰器对同一个函数进行装饰</h4><p>先装下面的后装上面的。理解上面的实现过程。</p>
<p>执行效果是先执行上面的再执行下面的。所以装饰的顺序和想要的逻辑执行顺序相同即可。</p>
<h4 id="使用类当作装饰器"><a href="#使用类当作装饰器" class="headerlink" title="使用类当作装饰器"></a>使用类当作装饰器</h4><p>原理同闭包。只是变量名指向的不是函数，而是实例对象。</p>
<p>然后使用<code>变量名()</code>调用的是<code>实例对象.__call__()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.func()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>p116~p150</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/23/universe/python/python_hack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/23/universe/python/python_hack/" class="post-title-link" itemprop="url">python hack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-23 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-23T00:00:00+08:00">2020-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-27 19:09:14" itemprop="dateModified" datetime="2020-06-27T19:09:14+08:00">2020-06-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Scapy使用"><a href="#Scapy使用" class="headerlink" title="Scapy使用"></a>Scapy使用</h2><p>需要root权限</p>
<p>scapy可以帮助我们铸造各种包，我们利用这些包可以实现我们想要的目的。如扫描等</p>
<ul>
<li><code>sr</code>: Send ans Receive </li>
</ul>
<p>网络包有很多不同的参数，不需要死记硬背，只需用时看以下就行。如不知道ARP需要什么参数，可以采用如下，就可以知道</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = Ether()/ARP()</span><br><span class="line">a.show()</span><br></pre></td></tr></table></figure>

<p>不知道scapy的类有那些方法时，可以使用<code>type(arg)</code>来查看类，然后网上查找。</p>
<h2 id="扫描探测"><a href="#扫描探测" class="headerlink" title="扫描探测"></a>扫描探测</h2><h3 id="ARP扫描-PING扫描"><a href="#ARP扫描-PING扫描" class="headerlink" title="ARP扫描/PING扫描"></a>ARP扫描/PING扫描</h3><p>ARP协议完成IP地址和MAC地址的转换，询问目的机的MAC地址</p>
<p>通过ping扫描或arp扫描可以知道那些地址上有活动主机</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pkt = IP(dst=<span class="string">'47.96.226.37'</span>, ttl=<span class="number">1</span>, id=<span class="number">168</span>)/ICMP(id=<span class="number">188</span>, seq=<span class="number">1</span>)</span><br><span class="line">result = srp(pkt)  <span class="comment"># 得到 [收到的,未收到的]</span></span><br><span class="line">result[<span class="number">0</span>].res[x][y].getlayer(ARP).fields[<span class="string">'key'</span>]  <span class="comment"># res产生清单，很多元祖啊；getlayer是将二进制转换为字典，fields获取对应的值，缺省的获取整个字典</span></span><br><span class="line"><span class="comment"># 这个结构需要有所了解</span></span><br></pre></td></tr></table></figure>


<h3 id="TCP扫描"><a href="#TCP扫描" class="headerlink" title="TCP扫描"></a>TCP扫描</h3><p>利用tcp协议，扫描tcp的开放端口。发送SYN包，回复SYN ACK就说明端口开放 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/Major/OS/Operating_Systems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/Major/OS/Operating_Systems/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-12 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-12T00:00:00+08:00">2020-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-09 19:37:14" itemprop="dateModified" datetime="2020-07-09T19:37:14+08:00">2020-07-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>shell对外暴露的接口，操作系统对外提供服务</p>
<p>特征</p>
<ul>
<li>并发<ul>
<li>同时存在多个运行的程序</li>
</ul>
</li>
<li>共享<ul>
<li>操作系统控制如何”同时”访问</li>
<li>文件互斥</li>
</ul>
</li>
<li>虚拟<ul>
<li>让每个用户/程序都觉得有一个计算机专门为它提供服务</li>
</ul>
</li>
<li>异步<ul>
<li>程序执行不是一贯到底的，向前推进的速度有系统调度</li>
<li>但是只要环境相同，每次运行的结果一定相同</li>
</ul>
</li>
<li>相互联系也相互区别</li>
</ul>
<ul>
<li>Microkernel:微内核架构设计<ul>
<li>只放基本的功能</li>
<li>文件管理、网路协议栈等都是放在外围以服务的形式存在，服务和服务之间通过内核的消息传递机制</li>
<li>相互隔离，很灵活，小巧</li>
<li>代价就是性能</li>
</ul>
</li>
<li>外核设计<ul>
<li>内核分成两块，<ul>
<li>Exokernel(外核)与硬件打交道：完成硬件功能的复制。</li>
<li>建立在exokernel之上，跟具体应用打交道，再通过它访问exokernel，来访问硬件<ul>
<li>可对应用进行相应的设计，使得速度更快</li>
<li>完成应用隔离</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>虚拟机</li>
</ul>
<h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><ul>
<li>计算机启动</li>
</ul>
<p>os存放在硬盘中，需要bootload将它放入内存。bootloader又由bios负责放入内存。</p>
<ul>
<li>bios提供各种支持：检测外设，初始化检查，把bootloader放入内存，让它执行</li>
<li>bootloader：加载os，从硬盘到内存</li>
</ul>
<p>应用间接与外设打交道，之所以应用不能直接访问外设是因为应用是不可信任的，而操作系统是可信任的;另一方面操作系统外为上层提供一致的接口，使得上层应用不用关注底层细节，通用可移植，提高效率。由此设计一下三个基本概念</p>
<ul>
<li><p>三个基本概念</p>
<ul>
<li>中断<ul>
<li>产生的源头：外设产生</li>
<li>处理的时间:异步事件，不会知道什么时候产生</li>
<li>响应：持续，对应用程序是透明的</li>
</ul>
</li>
<li>异常<ul>
<li>产生的源头：应用意想不到的行为</li>
<li>处理的时间：同步，一定在某个特定的指令可以产生，可以确定时间</li>
<li>响应：杀死或重新执行</li>
</ul>
</li>
<li>系统调用<ul>
<li>产生的源头：应用请求操作系统提供服务</li>
<li>处理的时间：同步或异步(返回点有可能是异步的)</li>
<li>响应：等待和持续</li>
</ul>
</li>
</ul>
</li>
<li><p>中断和异常的处理过程</p>
<ul>
<li>中断码<ul>
<li>查表</li>
</ul>
</li>
<li>保存和恢复<ul>
<li>程序执行过程中被中断，需要保存当前处理状态，便于恢复后继续执行</li>
</ul>
</li>
</ul>
</li>
<li><p>异常处理过程</p>
<ul>
<li>保存现场</li>
<li>异常处理<ul>
<li>异常编号，相应处理</li>
</ul>
</li>
<li>恢复现场</li>
</ul>
</li>
<li><p>系统调用过程</p>
<ul>
<li>访问系统调用接口</li>
<li>用户态切到内核态，控制权交给操作系统<ul>
<li>用户态：可执行权限低</li>
<li>内核态：可执行任何指令</li>
</ul>
</li>
<li>处理完成后返回成功失败</li>
</ul>
</li>
</ul>
<h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h2><h3 id="计算机体系结构及内存分层体系"><a href="#计算机体系结构及内存分层体系" class="headerlink" title="计算机体系结构及内存分层体系"></a>计算机体系结构及内存分层体系</h3><p>…</p>
<h3 id="地址空间与地址生成"><a href="#地址空间与地址生成" class="headerlink" title="地址空间与地址生成"></a>地址空间与地址生成</h3><ul>
<li>地址空间<ul>
<li>物理地址空间<ul>
<li>硬件支持的地址空间</li>
</ul>
</li>
<li>逻辑地址空间<ul>
<li>一个运行打程序所拥有的内存范围</li>
</ul>
</li>
</ul>
</li>
<li>地址空间生成<ul>
<li>cpu会根据逻辑地址查找物理地址，对应对应关系储存在MMU的表示映射关系的区域</li>
<li>CPU执行某条指令时，ALU根据指令的内容发送请求，携带逻辑地址。CPU中的MMU查找MMU对应的物理地址</li>
<li>逻辑地址和物理地址的联系又操作系统生成</li>
</ul>
</li>
<li>检查地址的安全<ul>
<li>确保每个程序访问的地址空间</li>
</ul>
</li>
</ul>
<h3 id="连续内存分配：内存碎片与分区的动态分配"><a href="#连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="连续内存分配：内存碎片与分区的动态分配"></a>连续内存分配：内存碎片与分区的动态分配</h3><ul>
<li><p>外碎片</p>
<ul>
<li>分配单元之间的未使用内存</li>
</ul>
</li>
<li><p>内碎片</p>
<ul>
<li>在分配单元中的碎片</li>
</ul>
</li>
<li><p>简单的内存管理方法</p>
<ul>
<li>当一个程序准许运行在内存中时，分配一个连续的区间</li>
<li>分配一个连续的内存区间给运行的程序以访问数据</li>
</ul>
</li>
<li><p>分配策略</p>
<ul>
<li>首次适配算法<ul>
<li>碰到的第一个能够满足需求的空闲块，分配给程序</li>
<li>需求<ul>
<li>按照地址排序的空闲地址块列表</li>
<li>重新分配需要检查，看是否有空闲块能够合并</li>
</ul>
</li>
<li>优势<ul>
<li>简单</li>
<li>易于把大的空闲块留在结尾</li>
</ul>
</li>
<li>劣势<ul>
<li>容易产生外碎片</li>
<li>不确定性</li>
</ul>
</li>
</ul>
</li>
<li>最优适配算法<ul>
<li>寻找最适合的空闲块</li>
<li>需求<ul>
<li>按照大小排序的空闲地址块列表</li>
<li>重新分配需要检查，看是否有空闲块能够合并</li>
</ul>
</li>
<li>优势<ul>
<li>避免了把大的空闲块拆散</li>
<li>最小化外部碎片的产生</li>
<li>比较简单</li>
</ul>
</li>
<li>劣势<ul>
<li>重新分配慢</li>
<li>外碎片拆得很细，使得将来的利用可能性小</li>
<li>易产生很多没用的小碎片</li>
</ul>
</li>
</ul>
</li>
<li>最差适配算法<ul>
<li>与最优相反，找差距最大的空闲块</li>
<li>需求<ul>
<li>按照大小排序的空闲地址块列表</li>
<li>重新分配需要检查，看是否有空闲块能够合并</li>
</ul>
</li>
<li>优势<ul>
<li>分配时中等尺寸时效果最小</li>
</ul>
</li>
<li>劣势<ul>
<li>易于破碎大的空间，以致于(将来需要时)大分区无法被分配</li>
<li>重新分配慢</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="连续内存分配：压缩式与交换式碎片整理"><a href="#连续内存分配：压缩式与交换式碎片整理" class="headerlink" title="连续内存分配：压缩式与交换式碎片整理"></a>连续内存分配：压缩式与交换式碎片整理</h3><ul>
<li>压缩式碎片整理<ul>
<li>重置程序以合并孔洞</li>
<li>要求所有程序是动态可重置的</li>
<li>思考：<ul>
<li>何时重置</li>
<li>开销</li>
</ul>
</li>
</ul>
</li>
<li>交换式碎片整理(swaping)<ul>
<li>运行程序需要更多的内存</li>
<li>把硬盘当作内存的备份(虚拟内存)，将等待需求较长的程序挪到硬盘腾出内存</li>
<li>抢占等待的程序&amp;回收他们的内存</li>
<li>思考<ul>
<li>那些程序交换</li>
<li>何时换入换出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-4"><a href="#Part-4" class="headerlink" title="Part 4"></a>Part 4</h2><h3 id="非连续内存分配：分段"><a href="#非连续内存分配：分段" class="headerlink" title="非连续内存分配：分段"></a>非连续内存分配：分段</h3><ul>
<li><p>连续内存分配的缺点</p>
<ul>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片和内碎片的问题</li>
</ul>
</li>
<li><p>为什么需要非连续内存分配(优点)</p>
<ul>
<li>一个程序的物理地址空间是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码和数据</li>
<li>支持动态加载和动态链接</li>
</ul>
</li>
<li><p>非连续分配的缺点</p>
<ul>
<li>管理开销：如何建立虚拟地址和物理地址之间的转换<ul>
<li>软件方案</li>
<li>硬件方案<ul>
<li>分段</li>
<li>分页</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分段</p>
<ul>
<li>段访问机制<ul>
<li>程序访问内存需要一个二维数组(段号s，段内偏移addr)</li>
</ul>
</li>
<li>分段的寻址方案<ul>
<li>虚拟内存通过某种映射联系到物理地址</li>
<li>需要一个段表，操作系统建立</li>
<li>需要直到段的大小，防止偏移地址超出范围</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="非连续内存分配：页表"><a href="#非连续内存分配：页表" class="headerlink" title="非连续内存分配：页表"></a>非连续内存分配：页表</h3><p>页表其实就是一个大数组，每个运行的程序都有一个页表，每个页表有(page num, offset)</p>
<ul>
<li><p>属于程序运行状态，会动态变化</p>
</li>
<li><p>PIBR：页表基址寄存器</p>
</li>
<li><p>页表内容</p>
<ul>
<li>Flag标志位<ul>
<li>dirty bit：是否合法</li>
<li>resident bit：物理地址中是否存在</li>
<li>clock/reference bit</li>
</ul>
</li>
<li>帧号frame num：f</li>
</ul>
</li>
<li><p>CPU通过页号和偏移寻址到对应的页表项，把帧号和偏移组合形成物理地址</p>
</li>
<li><p>分页机制的性能问题：</p>
<ul>
<li>访问一个内存单元需要两次内存地址访问<ul>
<li>一次获取表项</li>
<li>一次访问数据</li>
</ul>
</li>
<li>页表可能很大，而且为了隔离每个程序要有自己的页表</li>
<li>页表空间大，因此访问效率页会有问题</li>
</ul>
</li>
<li><p>解决办法</p>
<ul>
<li>缓存近期访问的页帧转换表项(TLB)<ul>
<li>TLB使用关联内存实现，具备快速访问性能</li>
<li>如果TLB命中，物理页号可以很快获取</li>
<li>如果TLB未命中TLB miss，对应的表项被更新到TLB中<ul>
<li>多数编程(访问)的局部性可以降低TLB miss</li>
</ul>
</li>
</ul>
</li>
<li>间接访问</li>
</ul>
</li>
</ul>
<h3 id="非连续内存分配：页表-二级、多级页表"><a href="#非连续内存分配：页表-二级、多级页表" class="headerlink" title="非连续内存分配：页表-二级、多级页表"></a>非连续内存分配：页表-二级、多级页表</h3><p>速度问题解决了，空间上如何解决？那就需要页表分级</p>
<p>以二级页表举例，把一块大的页表分成两块，把大的page num分成两块：p1、p2。<br>通过一级表[p1]找到二级表的地址，在用二级表地址做索引，二级表[p2]找到frame num就可以找到物理地址。</p>
<p>整个过程多了寻址，导致开销增大，但是通过分级，当物理地址不存在时(在一级表就可以得出)，从而二级表不必保存这部分内容。以时间换空间。</p>
<p>多级页表同理</p>
<h3 id="非连续内存分配：页表-反向页表"><a href="#非连续内存分配：页表-反向页表" class="headerlink" title="非连续内存分配：页表-反向页表"></a>非连续内存分配：页表-反向页表</h3><p>前面所讲的页表的大小都和逻辑地址空间的大小有对应关系，逻辑空间寻址的范围越大，页表越多。</p>
<ul>
<li>大地址空间的问题：<ul>
<li>有大地址空间(64bits)，向前映射页表变得繁琐</li>
<li>不是让页表与逻辑空间的大小对应，而是让页表与物理地址空间大小对应</li>
</ul>
</li>
</ul>
<p>有什么办法使得页表项和逻辑地址空间没有那么大的关系，尽量和物理地址空间大小有关？这就是反向页表的想法。</p>
<p>前面都是以逻辑页号来索引页表(一个大数组)，能否用页帧号(物理页号)来查找对应的逻辑页的页号呢？这样就能省很多空间。</p>
<p>基于哈希查找的方案</p>
<h2 id="Part-5"><a href="#Part-5" class="headerlink" title="Part 5"></a>Part 5</h2><h3 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h3><p>理想中的存储器：更大、更快、更便宜的非易失性存储器</p>
<h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><ul>
<li>目标<ul>
<li>在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区储存管理配合</li>
</ul>
</li>
<li>原理<ul>
<li>把程序按照自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按照时间先后来运行<ul>
<li>必要部分(常用功能)的代码和数据常驻内存</li>
<li>可选部分(不常用功能)在其他程序模块中实现，平时存放在外存中，在需要时才装入内存</li>
<li>不存在调用关系的模块不必同时装入到内存，从而可以 <strong>相互覆盖</strong> 即这些模块共享一个分区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul>
<li>目标<ul>
<li>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源</li>
</ul>
</li>
<li>方法<ul>
<li>将暂时不能运行的程序送到外存，从而获得空闲内存空间</li>
<li>操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out)，而将外存中的某个进程的地址空间读入内存中(换入swap in)。换入换出内容的大小为整个程序的地址空间</li>
</ul>
</li>
<li>存在的问题<ul>
<li>交换的时机：只当内存空间不够或有不够的危险时换出</li>
<li>交换区的大小：必须足够大以存放所有用户进程的所有内存映像的拷贝</li>
<li>程序换入时的重定位：最好采用动态地址映射的方法</li>
</ul>
</li>
</ul>
<h3 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h3><ul>
<li><p>上面方法的不足</p>
<ul>
<li>覆盖技术：需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担</li>
<li>交换技术：以进程作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销</li>
</ul>
</li>
<li><p>虚存技术的目标：</p>
<ul>
<li>像覆盖技术那样，但做的更好，由操作系统完成，不需要程序员的干涉</li>
<li>像交换技术那样，但做的更好，只对进程的部分内容在内存和外存之间进行交换</li>
</ul>
</li>
<li><p>原理：利用程序的局部性</p>
</li>
<li><p>基本特征：</p>
<ul>
<li>大的用户空间：与外存相结合</li>
<li>部分交换：不同于交换技术，可以部分交换</li>
<li>不连续：物理内存分配不连续，虚拟地址空间使用不连续</li>
</ul>
</li>
<li><p>虚拟技术-虚拟页式内存管理</p>
<ul>
<li>基本思路：<ul>
<li>当程序需要调入内存运行时，不是将程序的所有页都装入内存，而是只装如部分页，就可启动程序而运行</li>
<li>在运行的过程中，如果发现运行的程序或要访问的数据不再内存，则发出缺页中断请求，系统在处理这个中断时，将外存中相应的页调入内存，使得程序能够运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为了事先虚拟页式内存管理，需要在页表项中多加几位：</p>
<table>
<thead>
<tr>
<th>逻辑页号</th>
<th>访问位</th>
<th>修改位</th>
<th>保护位</th>
<th>驻留位</th>
<th>物理页帧号</th>
</tr>
</thead>
</table>
<ul>
<li>驻留位<ul>
<li>表示改页是内存还是外存，如果为1,表示在内存中，可以访问，否则导致缺页中断</li>
</ul>
</li>
<li>保护位<ul>
<li>表示允许对该页做何种类型的访问，如只读、只写等</li>
</ul>
</li>
<li>修改位<ul>
<li>表示页在内存中是否修改过，当系统回收改物理页时，根据此位来决定是否把它的内存写回到外存(跟新外存的数据)</li>
</ul>
</li>
<li>访问位<ul>
<li>表明是否访问过。用于置换算法</li>
</ul>
</li>
</ul>
<h2 id="Part-6"><a href="#Part-6" class="headerlink" title="Part 6"></a>Part 6</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><ul>
<li><p>功能</p>
<ul>
<li>当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换</li>
</ul>
</li>
<li><p>目标</p>
<ul>
<li>尽可能减少页面换入换出的次数</li>
</ul>
</li>
<li><p>最优页面置换算法</p>
<ul>
<li>思路：当缺页发生时，选择等待时间最长的那个(将来长一段时间不会发生)，作为置换页面</li>
<li>这一种情况实际无法实现的原因是操作系统无法知道每个页面等待多长时间以后消失。所以只能尽可能接近，作为参考来比较其他算法</li>
</ul>
</li>
</ul>
<h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h3><ul>
<li>思路<ul>
<li>选择在内存中驻留时间最长的页面并淘汰之。即维护一个链表，链表记录所有的逻辑页，链首表示驻留时间最长。缺页时把链首淘汰，把新页添加到链尾</li>
</ul>
</li>
<li>性能较差，并且有Belady现象<ul>
<li>Belady现象<ul>
<li>在采用FIFO算法时，有时出现分配的物理页数增加，缺页率反而提高的异常现象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h3><ul>
<li>思路<ul>
<li>缺页发生时，替换最久未被使用的页，并淘汰之</li>
<li>利用局部性原理</li>
</ul>
</li>
<li>需要记录使用时间的先后顺序，开销较大。两种可能的实现方法：<ul>
<li>维护链表</li>
<li>堆栈，最新的压到栈顶，但是要查找一遍把已经存在的剔除</li>
</ul>
</li>
</ul>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>时钟页面置换算法，LRU的近似，对FIFO的一种改进。</p>
<ul>
<li>基本思路<ul>
<li>需要用到表项当中的访问位。当一个页面被装入内存时，把该位初始化为0。如果这个页面被访问到，则把该位置置为1</li>
<li>把各个页面组织成环形链表，指针指向最老的页面</li>
<li>当缺页发生时，考虑指针指向的最老的页面，如果它的访问位为0，则淘汰。如果访问位为1，则把它置为0,然后指针往下寻找</li>
</ul>
</li>
</ul>
<h3 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h3><p>时钟页面置换算法的访问并没有区分读还是写。实际中如果执行了写操作dirty bit会置为1，如果只是读dirty bit是0。那么dirty bit有什么用呢？</p>
<p>如果进行的是写操作，那么需要同时写到内存和硬盘(数据一致)。如果是只进行读操作，由于内容并没有改变，只需释放内存，然后换入即可。这种使用两个bit的算法就是二次机会法。</p>
<p>used bit、dirty bit的转变规则如下</p>
<table>
<thead>
<tr>
<th>如果</th>
<th>则</th>
</tr>
</thead>
<tbody><tr>
<td>used | dirty</td>
<td>used | dirty</td>
</tr>
<tr>
<td>0     0</td>
<td>替换的页</td>
</tr>
<tr>
<td>0     1</td>
<td>0     0</td>
</tr>
<tr>
<td>1     0</td>
<td>0     0</td>
</tr>
<tr>
<td>1     1</td>
<td>0     1</td>
</tr>
</tbody></table>
<h3 id="最不常用算法-LFU"><a href="#最不常用算法-LFU" class="headerlink" title="最不常用算法(LFU)"></a>最不常用算法(LFU)</h3><ul>
<li>基本思路<ul>
<li>缺页发生时，淘汰访问次数最少的页面</li>
</ul>
</li>
<li>维护计数器、顺序</li>
</ul>
<h3 id="局部页面替换算法的问题、工作集模型"><a href="#局部页面替换算法的问题、工作集模型" class="headerlink" title="局部页面替换算法的问题、工作集模型"></a>局部页面替换算法的问题、工作集模型</h3><p>如果局部性原理不成立，则各种置换算法效果没有区别。如果局部性原理成立，则可以通过工作集模型来表现。</p>
<ul>
<li><strong>工作集</strong> ：一个进程当前正在使用了逻辑页面集合，可以用一个二元函数$W(t, \Delta)$来表示<ul>
<li>t是当前的执行时刻</li>
<li>$\Delta$称为工作集窗口，即一个定长的页面访问的时间窗口</li>
<li>$W(t, \Delta)=$在当前时刻t之前的$\Delta$时间窗口当中的所有页面所组成的集合(随着t的变化， 该集合页不断地变化)</li>
<li>$|W(t, \Delta)|$值工作集的大小，即页面数目(不同页面的个数)</li>
</ul>
</li>
<li><strong>常驻集</strong> ：当前时刻，进程实际驻留在内存的页面集合<ul>
<li>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配进程的物理页的数目，以及所采用的页面置换算法</li>
<li>当常驻集的大小达到某个数目之后，在给他分配更多的物理页面，缺页率页不会明显下降</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    t: 0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line">pages: a c d c b a a b b d b</span><br><span class="line"></span><br><span class="line">若Delta&#x3D;4, t&#x3D;5, 则</span><br><span class="line">工作集大小&#x3D;4(dcba)</span><br><span class="line"></span><br><span class="line">若Delta&#x3D;3, t&#x3D;8, 则</span><br><span class="line">工作集大小&#x3D;2(abb)</span><br></pre></td></tr></table></figure>


<h3 id="全局置换算法"><a href="#全局置换算法" class="headerlink" title="全局置换算法"></a>全局置换算法</h3><p>把眼光放到整个系统的所有程序，而不仅仅是专注一个程序的页面置换。程序之间物理页需求不同，操作系统可以进行动态调节。</p>
<ul>
<li>缺页率页面置换算法<ul>
<li>可变分配策略：常驻集大小可变。如每个进程刚开始的时候，先根据程序大小给它分配一定数目的物理页面，然而在程序运行中，再动态调节常驻集大小<ul>
<li>当一个缺页中断发生时，被置换的页面可以是在其他进程当中。各个并发进程竞争地使用物理页面</li>
<li>优缺点：性能较好，但增加了系统开销</li>
<li>具体实现：可以使用缺页率算法来到动态调整常驻集大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-7"><a href="#Part-7" class="headerlink" title="Part 7"></a>Part 7</h2><h3 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h3><ul>
<li>进程控制块：操作系统管理控制进程所需的信息集合<ul>
<li>操作系统用 <strong>PCB(Process Control Block)</strong> 来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志<ul>
<li>进程的创建：为该进程生成一个PCB</li>
<li>进程的终止：回收它的PCB</li>
<li>进程的组织管理：通过PCB的组织管理来实现</li>
</ul>
</li>
<li>PCB含有以下三大类信息<ul>
<li>进程的标识信息</li>
<li>处理机状态信息</li>
<li>进程控制信息</li>
</ul>
</li>
<li>PCB的组织方式<ul>
<li>链表：经常有动态插入删除的操作系统</li>
<li>索引表(数组)：不常有动态插入删除的操作系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的生命周期原理"><a href="#进程的生命周期原理" class="headerlink" title="进程的生命周期原理"></a>进程的生命周期原理</h3><ul>
<li>进程创建<ul>
<li>引起进程创建的3个主要事件<ul>
<li>系统初始化</li>
<li>用户请求创建一个新进程</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
</li>
</ul>
</li>
<li>进程运行<ul>
<li>一个就绪的进程开始运行</li>
</ul>
</li>
<li>进程等待<ul>
<li>一个进程没有就绪，就进入等待，让其他进程先执行</li>
</ul>
</li>
<li>进程唤醒<ul>
<li>等待的进程就绪</li>
</ul>
</li>
<li>进程结束</li>
</ul>
<h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><ul>
<li>进程挂起<ul>
<li>进程没有占用内存空间，叫做进程挂起</li>
<li>阻塞挂起状态：进程在外存并等待某时间的提出</li>
<li>就绪挂起状态：进程在外存，但只要进入内存即可运行</li>
</ul>
</li>
<li>状态队列把进程管理起来<ul>
<li>一个队列只存一种状态的进程</li>
</ul>
</li>
</ul>
<h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>线程就是进程中的一条执行流程</p>
<ul>
<li>特性<ul>
<li>线程间可以并发执行</li>
<li>线程间共享相同的地址空间</li>
</ul>
</li>
<li>优点<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各个线程之间可以并发地执行</li>
<li>各个线程之间可以共享相同地址空间和文件等资源</li>
</ul>
</li>
<li>缺点<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>
<li>如：浏览器如果使用一个页面一个进程，则该页面崩溃不会影响其他页面</li>
</ul>
</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式</p>
<ul>
<li>用户线程：在用户空间实现<ul>
<li>在用户空间实现的线程机制不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理</li>
<li>操作系统只能感知到线程所属的进程</li>
<li>缺点：<ul>
<li>如果一个线程发起系统调用而阻塞，则整个进程进入等待。因为操作系统只能感知到进程，所以操作系统阻塞了进程，导致所有的线程阻塞</li>
<li>当一个线程开始运行后，除非它主动交出CPU的使用权，否则它所在的进程当中的其他线程将无法使用。因为用户进程没有打断线程的特权</li>
<li>由于时间分片分配给进程，故与其他进程比，在多个线程执行时，每个线程得到的时间片少，执行会慢。</li>
</ul>
</li>
</ul>
</li>
<li>内核线程：在内核中实现</li>
<li>轻量级进程：在内核中实现，支持用户线程<ul>
<li>内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程有一个单独的内核线程来支持</li>
</ul>
</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>各个进程共享CPU资源，不同时刻进程需要切换，让别的进程能够执行。这个切换过程称为进程的上下文切换。</p>
<h2 id="Part-8"><a href="#Part-8" class="headerlink" title="Part 8"></a>Part 8</h2><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul>
<li>FCFS：先来先服务</li>
<li>SPN(SJF) SRT：短进程优先 短剩余时间优先<ul>
<li>可抢占，导致长进程可能一直得不到执行</li>
</ul>
</li>
<li>HRRN：最高响应比优先<ul>
<li>$R=(w+s)/s$，w是等待时间，s是执行时间。不可抢占，一定程度防止了长进程得不到执行的问题</li>
</ul>
</li>
<li>Round Robin：轮循<ul>
<li>各个进程轮流占用CPU</li>
<li>会引入额外的上下文切换开销，时间片太小切换太频繁，时间片太大等待时间太久</li>
</ul>
</li>
<li>Multilevel Feedback Queue：多级反馈队列<ul>
<li>不同级别队列可以采用不同的调度方案，根据进程特点划分</li>
</ul>
</li>
<li>Fair Share Scheduling：公平共享调度</li>
</ul>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><ul>
<li>实时系统<ul>
<li>定义：正确性依赖于其时间和功能两方面的一种操作系统。即因为是实时的，如果不能在规定时间完成，则失去时效性</li>
<li>强实时系统<ul>
<li>需要在保证的时间内完成重要的任务，必须完成</li>
</ul>
</li>
<li>弱实时系统<ul>
<li>要求重要的进程优先级更高，尽量完成，非必须</li>
</ul>
</li>
<li>性能指标<ul>
<li>时间约束的及时性(deadline)</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>主要特征：时间约束的可预测性</li>
</ul>
</li>
</ul>
<h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3><p>举个例子：设优先级$T1&gt;T2&gt;T3$，T3先执行并访问一块共享资源(上锁)，但还没解锁CPU就调度去执行T1。当T1也要访问这共享资源时，要等T3使用完毕(解锁)。但这时由于T2优先级高于T3，T2想要执行了，抢占了CPU，那么T1的执行时间被T2延长了。</p>
<ul>
<li>解决办法<ul>
<li>优先级继承<ul>
<li>低优先级任务继承高优先级任务的优先级依赖于他们共享的资源，即在上面这个例子中，由于T1要等待T3访问完毕，所以T3的优先级得到动态的提升和T1一样。</li>
</ul>
</li>
<li>优先级天花板<ul>
<li>资源的优先级和所有可能锁定该资源的任务中优先级最高的那个任务的优先级相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-9"><a href="#Part-9" class="headerlink" title="Part 9"></a>Part 9</h2><h3 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h3><ul>
<li>临界区：进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时不会被执行的代码区域</li>
<li>互斥：访问临界区的进程只有一个</li>
<li>死锁：两个或以上的进程，在互相等待完成待定任务</li>
<li>饥饿：一个可执行进程持续得不到执行</li>
<li>原子操作：一次不存在中断或者失败的执行(不可在”分”的最小单位，原子)</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>并发存在的问题：同时对一个数据进行写入操作会存在问题，因为写入操作大致可分为这么几个步骤：读取数据、操作数据、写入数据。由于cpu在线程间切换，如果操作数据后切换到另一个进程，然后才写入数据，将导致问题。</p>
<p>为了解决上面的并发问题，引入互斥锁机制，使得共享的数据一次只能一个进程操作，其他需要等待正在使用的进程使用结束</p>
<ul>
<li>上锁操作执行顺序(也存在上下文切换)问题:<ul>
<li>方案一：<ul>
<li><ol>
<li>判断是否操作共享资源</li>
</ol>
</li>
<li><ol start="2">
<li>判断是否有锁</li>
</ol>
</li>
<li><ol start="3">
<li>上锁</li>
</ol>
</li>
<li>存在问题，如果A先执行1、2，然后切换到B。B也会成功执行1、2进入3的区域。这时A和B都可以执行3，并没有起到锁的保护机制：只让一个进程操作</li>
</ul>
</li>
<li>方案二：<ul>
<li><ol>
<li>上锁</li>
</ol>
</li>
<li><ol start="2">
<li>判断是否有锁</li>
</ol>
</li>
<li><ol start="3">
<li>判断是否操作共享资源</li>
</ol>
</li>
<li>存在问题，A执行了1二话不说先上锁，然后切换到B。B也二话不说先上锁，这时A和B都被对方锁住，谁都不会执行</li>
<li>这种由于进程切换导致谁都不执行的现象称为饥饿</li>
</ul>
</li>
<li>方案三：使用临界区</li>
</ul>
</li>
</ul>
<h3 id="临界区的创建"><a href="#临界区的创建" class="headerlink" title="临界区的创建"></a>临界区的创建</h3><ul>
<li>禁用硬件中断<ul>
<li>虽然在临界区中执行时不会被随意切换了，但对于外设的事件也得不到相应</li>
<li>而且对于多核CPU，要屏蔽所有CPU的相应中断能力，所在多CPU情况下无法解决互斥问题</li>
</ul>
</li>
<li>基于软件的解决方法<ul>
<li>设有两个线程T0、T1,它们的结构通常为<code>while(1){进入临界区;执行临界区代码;退出临界区}</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;  <span class="comment">// 指示该谁进入临界区</span></span><br><span class="line"><span class="keyword">bool</span> flag[];  <span class="comment">// 指示进程是否准备好进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 进入临界区的代码</span></span><br><span class="line">    flag[i] = TRUE;</span><br><span class="line">    <span class="built_in">turn</span> = j;</span><br><span class="line">    <span class="keyword">while</span>(flag[j]&amp;&amp;<span class="built_in">turn</span>==j);</span><br><span class="line">        <span class="comment">//操作</span></span><br><span class="line">    <span class="comment">// 退出临界区的代码</span></span><br><span class="line">    flag[i] = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>更高级的抽象：基于硬件的一些原子操作<ul>
<li>Test-and-Set：这是一条完成读和写的机器指令<ul>
<li><ol>
<li>从内存读值</li>
</ol>
</li>
<li><ol start="2">
<li>测试该值是否为1(返回bool)</li>
</ol>
</li>
<li><ol start="3">
<li>内存值设置为1</li>
</ol>
</li>
</ul>
</li>
<li>交换exchange<ul>
<li>交换两个内存中的值</li>
</ul>
</li>
<li>上面两条指令都是原子操作，不会被切换、中断</li>
<li>缺点：<ul>
<li>忙等消耗处理器时间</li>
<li>当进程离开临界区并且多个进程在等待的时候可能导致饥饿(抢lock抢不到)</li>
<li>死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程也要求，那么高优先级进程会获得处理器并等待临界区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-10"><a href="#Part-10" class="headerlink" title="Part 10"></a>Part 10</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>抽象数据类型<ul>
<li>一个整形(sem)，两个原子操作</li>
<li>P()：sem减1,如果sem&lt;0，等待，否则继续</li>
<li>V()：sem加1,如果sem&lt;=0(说明有有一些进程在等待)，唤醒一个等待的P</li>
</ul>
</li>
</ul>
<h4 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h4><ul>
<li>信号量是整数</li>
<li>信号量的被保护的变量<ul>
<li>初始化完成后，唯一改变一个信号量的值的方法是通过P()和V()</li>
<li>操作必须是原子</li>
</ul>
</li>
<li>P()能够阻塞，V()不会阻塞</li>
<li>我们假定信号量是”公平的”<ul>
<li>没有线程被阻塞在P()仍然堵塞V()被无限频繁调用(在同一信号量)</li>
</ul>
</li>
<li>两种类型信号量<ul>
<li>二进制信号量：可以是0或1</li>
<li>一般/计数信号量：可是任何非负数<ul>
<li>允许多个执行P操作的进程进入后续操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex-&gt;P()</span><br><span class="line">临界区</span><br><span class="line">mutex-&gt;V()</span><br></pre></td></tr></table></figure>


<h4 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h4><p>基本结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::P()&#123;</span><br><span class="line">    sem--;</span><br><span class="line">    <span class="keyword">if</span>(sem&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        把这个线程放入等待队列q;</span><br><span class="line">        block(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::V()&#123;</span><br><span class="line">    sem++;</span><br><span class="line">    <span class="keyword">if</span>(sem&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        从等待队列中取出一个线程t</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>building</p>
<ul>
<li>目的：分离互斥和条件同步的关注</li>
<li>什么是管程：<ul>
<li>一个锁：指定临界区</li>
<li>0或多个条件变量：等待/通知信号量用于管理并发访问共享数据</li>
</ul>
</li>
<li>一般方法<ul>
<li>收集在对象/模块中的相关共享数据</li>
<li>定义方法来访问共享数据</li>
</ul>
</li>
</ul>
<h2 id="Part-11"><a href="#Part-11" class="headerlink" title="Part 11"></a>Part 11</h2><p> <strong>IIII</strong> </p>
<h3 id="死锁的特征"><a href="#死锁的特征" class="headerlink" title="死锁的特征"></a>死锁的特征</h3><ul>
<li>互斥：在一个时间只能有一个进程使用资源</li>
<li>持有并等待：进程保持至少一个资源正在等待获取其他进程持有的额外资源</li>
<li>不抢占：一个资源只能被进程自愿释放</li>
<li>循环等待：一个等一个的环，但有环不一定有死锁</li>
</ul>
<h3 id="死锁处理办法"><a href="#死锁处理办法" class="headerlink" title="死锁处理办法"></a>死锁处理办法</h3><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>死锁出现我们将死锁出现的某个条件打破是不是就解决了?</p>
<ul>
<li>打破占用并等待<ul>
<li>一次占用所有所需的资源否则就不拿资源，是不是就防止了其他进程插足<ul>
<li>缺点是资源利用率低，可能发生饥饿</li>
</ul>
</li>
</ul>
</li>
<li>打破不抢占<ul>
<li>过于极端，导致被抢占的进程无法正常运行</li>
</ul>
</li>
<li>打破循环等待<ul>
<li>对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请</li>
</ul>
</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>申请资源时进行判断是否会出现死锁。需要操作系统提供一些额外的先验信息：</p>
<ul>
<li>最简单的方法如：每个进程声明它可能需要的每个类型资源的最大数目</li>
<li>限制提供与分配的资源数量，不能超过个某个最大需求</li>
<li>死锁避免算法动态检查资源分配状态，以确保永远不会有一个环形等待状态<ul>
<li>但是有环并不一定有死锁</li>
</ul>
</li>
</ul>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><blockquote>
<p>有人找银行家贷款，银行家判断是否能够贷款收回，能收回才放贷。</p>
</blockquote>
<ul>
<li>前提条件<ul>
<li>多个进程实例</li>
<li>每个进程必须最大限度利用资源</li>
<li>当一个进程请求资源，得不到就不等待</li>
<li>当一个进程得到所有的资源就必须在一定的时间内释放</li>
</ul>
</li>
</ul>
<p>基于上述条件，银行家算法通过寻找允许每个进程获得的最大资源并结束的进程理想执行时序，来决定是否安全。不存在满足要求的执行时序状态都是不安全的。</p>
<ul>
<li><p>数据结构</p>
<ul>
<li>n = 进程数量，m = 资源类型数量</li>
<li>Max(总需求量)：n x m矩阵。Max[i, j] = k表示，进程$P_i$最多请求资源类型$R_j$的实例个数为k</li>
<li>Available(空闲量)：长度为m的向量。Available[j] = k表示有k个$R_j$类型的资源可用</li>
<li>Allocation[i, j](已分配)</li>
<li>Need[i, j](未来需要量)</li>
<li>Need[i, j] = Max[i, j] - Allocation[i, j]</li>
</ul>
</li>
<li><ol>
<li>初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; work和finish分别是长度为m和n的向量</span><br><span class="line">work &#x3D; Available  &#x2F;&#x2F; 当前剩余</span><br><span class="line">finish[i] &#x3D; false for i in range(n) &#x2F;&#x2F; 线程i没结束</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>判断能否申请到：找到need比work小的进程i<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 要求</span><br><span class="line">(a) finish[i] &#x3D; false</span><br><span class="line">(b) need_i &lt;&#x3D; work</span><br></pre></td></tr></table></figure>
<ul>
<li>没找到跳转到4</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>申请到后认为进程可以正常结束<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 进程i的资源要求量小于当前的剩余空闲资源量</span><br><span class="line">work &#x3D; work + allocation  &#x2F;&#x2F; 回收</span><br><span class="line">finish[i] &#x3D; true</span><br></pre></td></tr></table></figure>
<ul>
<li>跳转到2</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>如果步骤2找不到这样的进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if finish[i] &#x3D;&#x3D; true for all i  &#x2F;&#x2F; 表明安全状态</span><br><span class="line">    可以分配</span><br><span class="line">else 不应该分配</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h4 id="死锁检测和死锁恢复"><a href="#死锁检测和死锁恢复" class="headerlink" title="死锁检测和死锁恢复"></a>死锁检测和死锁恢复</h4><ul>
<li>死锁检测<ul>
<li>维护等待图<ul>
<li>节点是进程</li>
<li>$P_i \rightarrow P_j$：Pi等待Pj</li>
</ul>
</li>
<li>定期调用检测算法来搜索图中是否存在循环</li>
<li>算法需要$n^2$次操作，n是图中定点的数目</li>
<li>开销比较大</li>
</ul>
</li>
<li>死锁恢复<ul>
<li>终止所有的死锁进程<ul>
<li>比较暴力</li>
</ul>
</li>
<li>在一个时间内终止一个进程直到死锁消除<ul>
<li>基于进程的优先级</li>
<li>基于进程运行需要的时间</li>
<li>基于进程的资源占用</li>
<li>基于进程需要的资源</li>
<li>基于进程需要被终止的数目</li>
<li>基于进程是交互还是批处理</li>
</ul>
</li>
<li>资源抢占</li>
</ul>
</li>
</ul>
<h3 id="IPC-进程间通信-Inter-Process-Communication"><a href="#IPC-进程间通信-Inter-Process-Communication" class="headerlink" title="IPC(进程间通信:Inter-Process Communication)"></a>IPC(进程间通信:Inter-Process Communication)</h3><ul>
<li>直接通信<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个连接存在<ul>
<li>打破进程间的隔离</li>
</ul>
</li>
</ul>
</li>
<li>间接通信<ul>
<li>定向从消息队列接收消息</li>
</ul>
</li>
<li>信号<ul>
<li>类似与中断信号，但在IPC中是基于软件的信号</li>
<li>实现：<ul>
<li>在程序中编写handler负责处理操作系统发出的信号</li>
<li>收到信号后操作系统把本来应该向下执行的地址改为信号处理函数的入口地址</li>
</ul>
</li>
<li>进程可以接收、可以忽略</li>
<li>不足是信号不传参数，只是信号(某种标记)</li>
</ul>
</li>
<li>管道pipe<code>a | b</code><ul>
<li>用于数据交换，通过父进程帮子进程建立好通道</li>
<li>把a的输出放入缓冲区buffer，把这个缓冲区的内容当作b的输入</li>
</ul>
</li>
<li>消息队列<ul>
<li>不同于管道<ul>
<li>没有父子关系</li>
<li>管道里数据是一种字节流，不是一种结构化的数据</li>
</ul>
</li>
</ul>
</li>
<li>共享内存<ul>
<li>一种直接通信方式，共享内存</li>
<li>优点：快速，方便的共享数据</li>
<li>缺点：必须同步数据访问，需要同步互斥机制</li>
</ul>
</li>
</ul>
<h2 id="Part-12"><a href="#Part-12" class="headerlink" title="Part 12"></a>Part 12</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><ul>
<li>内核跟踪每个进程打开的文件<ul>
<li>操作系统为每个进程维护一个打开文件表</li>
<li>一个打开文件描述符是这个表中的索引</li>
</ul>
</li>
<li>需要元数据来管理打开文件<ul>
<li>文件指针：指向最近一次读写位置，每个打开这个文件的进程都有这个指针</li>
<li>文件打开计数器：记录文件打开的次数。当最后一个进程关闭了文件时，允许将其从打开文件表中移除</li>
<li>文件磁盘位置：缓存数据访问信息</li>
<li>访问权限</li>
</ul>
</li>
</ul>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>目录好比一个集合，这个集合里有很多文件。集合用何种数据结构实现取决于文件系统的设计。可以采取传统的数组形式、、链表形式、也可采取哈希表形式或者更复杂的形式。</p>
<h4 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h4><ul>
<li>多个文件名关联同一个文件<ul>
<li>硬连接：多个文件指向一个文件<ul>
<li>删除一个文件将减少文件的引用计数，只有引用计数为0时才会删除一个文件</li>
</ul>
</li>
<li>软连接：以”快捷方式”指向其他文件<ul>
<li>删除真实文件后会留下的快捷方式将指向空</li>
</ul>
</li>
<li>通过存储真实文件的逻辑名称来实现</li>
</ul>
</li>
<li>别名机制潜在的循环<ul>
<li>对目录的别名：子目录是父目录的一个引用</li>
<li>这将导致查找文件时检索路径出现死循环</li>
</ul>
</li>
</ul>
<h4 id="文件系统类别"><a href="#文件系统类别" class="headerlink" title="文件系统类别"></a>文件系统类别</h4><ul>
<li>磁盘文件系统<ul>
<li>文件存储在数据存储设备上，如磁盘</li>
<li>例如：FAT、NTFS、ext3/4等</li>
</ul>
</li>
<li>数据库文件系统<ul>
<li>文件根据其特征是可寻址(辨识)的</li>
</ul>
</li>
<li>日志文件系统<ul>
<li>记录文件系统的修改/时间</li>
</ul>
</li>
<li>网络/分布式文件系统</li>
<li>特殊/虚拟文件系统</li>
</ul>
<h4 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h4><p>文件系统的种类繁多，如果让操作系统针对不同的文件系统编写应用程序，这显然是很复杂的。所有操作系统把复杂的东西抽象成简单的接口提供给用于，用户只需访问简单的接口，就可以应对不同的文件系统。</p>
<p>虚拟文件系统是一个内存中的概念，通过虚拟文件系统层，屏蔽了底层文件各种系统的差异，从而应用程序可以访问不同类型的文件系统。</p>
<ul>
<li><p>分层结构</p>
<ul>
<li>上层：虚拟(逻辑)文件系统</li>
<li>底层：特定文件系统模块</li>
</ul>
</li>
<li><p>目的</p>
<ul>
<li>对多有不同文件系统的抽象</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li>提供相同的文件和文件系统接口</li>
<li>管理所有文件和文件系统关联的数据结构</li>
<li>高效查询例程，遍历文件系统</li>
<li>与特定文件系统模块的交互</li>
</ul>
</li>
<li><p>基本结构</p>
<ul>
<li>卷控制块<ul>
<li>每个文件系统一个</li>
<li>文件系统详细信息</li>
<li>块、块大小、空余块、计数/指针等</li>
</ul>
</li>
<li>文件控制块<ul>
<li>每个文件一个</li>
<li>文件详细信息</li>
<li>权限、拥有者、大小等信息</li>
</ul>
</li>
<li>目录节点<ul>
<li>每个目录项一个(目录和文件)</li>
<li>将目录项数据结构及树形布局编码成树形数据结构</li>
<li>指向文件控制块、父节点、项目列表等</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="./static/dir_node_struct.png"/>


<h3 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h3><ul>
<li>将文件控制块读入内存</li>
<li>相关信息放入打开文件表</li>
<li>把打开文件表表项的索引返回给应用程序<ul>
<li>基于索引找到系统层面的打开文件表。由于可能多个程序打开同一个文件，所以都索引到系统文件表(只有一项)就ok</li>
<li>系统文件表由索引到目录/文件</li>
<li>如：访问文件，那么文件的信息会包含文件出现在什么地方(disk位置)，然后由偏移量指出，转换成disk扇区的编号</li>
<li>然后就可对扇区内容读写</li>
</ul>
</li>
</ul>
<h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h3><p>当要写入文件时，要对文件的数据空间进行管理(增减)。分配方式有如下几种</p>
<ul>
<li>连续分配<ul>
<li>文件头指定起始块和长度</li>
<li>位置/分配策略<ul>
<li>最先分配、最佳分配</li>
</ul>
</li>
<li>优势<ul>
<li>文件读取表现号</li>
<li>高效的顺序和随机访问</li>
</ul>
</li>
<li>劣势，同数组的劣势<ul>
<li>文件增长问题，可能需要调整后面一系列文件，或者把自己移动到别处，但这样又造成碎片问题</li>
<li>碎片</li>
</ul>
</li>
</ul>
</li>
<li>链式分配<ul>
<li>文件以数据块链表方式储存</li>
<li>文件头包含了到第一块和最后一块的指针</li>
<li>优点<ul>
<li>创建、增减很容易</li>
<li>没有碎片</li>
</ul>
</li>
<li>缺点<ul>
<li>不可能进行真正的随机访问</li>
<li>可靠性：如突然断电一个链被破坏…</li>
</ul>
</li>
</ul>
</li>
<li>索引分配<ul>
<li>为每个文件建立一个名为 <strong>索引数据块</strong> 的非数据数据块<ul>
<li>到文件数据块的指针列表</li>
</ul>
</li>
<li>文件头包含了索引数据块</li>
<li>优点<ul>
<li>创建、增减容易</li>
<li>没有碎片</li>
<li>支持直接访问</li>
</ul>
</li>
<li>缺点<ul>
<li>当文件很小时，存储开销比例大</li>
<li>如何处理大文件？一个索引块能够描述的数据块的个数是有限的<ul>
<li>分级处理，但是引入很多(索引)开销，和链被破坏的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h3><p>对空闲空间的管理。有如下几种管理方式</p>
<ul>
<li>用位图代表空闲数据块列表<ul>
<li><code>11110001110011</code>每个位就可表示扇区是否被分配<ul>
<li>如果i=0表明数据块i是空闲的</li>
</ul>
</li>
<li>使用简单，但是可能会是一个big vector<ul>
<li>如160G的disk需要5MB的bit表示，可以将这5M读取到内存</li>
<li>然而如果空闲空间中均匀分布，那么在找到0之前需要扫描n/r。n表示磁盘数据块的总数，r表示空闲块数目</li>
</ul>
</li>
<li>需要保护数据一致性：储存在内存的位图需要和硬盘的位图一致<ul>
<li>解决办法：先在硬盘位图上修改，再分配，在修改内存的位图。不会出现数据丢失的情况</li>
</ul>
</li>
</ul>
</li>
<li>链式列表</li>
<li>分组列表</li>
</ul>
<h3 id="多磁盘管理-RAID"><a href="#多磁盘管理-RAID" class="headerlink" title="多磁盘管理-RAID"></a>多磁盘管理-RAID</h3><p>通常磁盘通过分区来最大限度减小寻道时间</p>
<ul>
<li>分区：不同分区可以是不同的文件系统</li>
<li>卷：把多个磁盘变成一个卷来管理，这就可以把一个文件系统扩展到，多个磁盘</li>
</ul>
<p><strong>RAID：冗余磁盘阵列</strong> 。早期的磁盘容易坏，那么能不能用多个磁盘来储存一个文件系统的内容来保证可靠性呢？raid由此提出。后来raid又可以用来提升磁盘访问的吞吐量，提高访问速度。</p>
<ul>
<li>实现<ul>
<li>在操作系统内存：储存/卷管理。软raid</li>
<li>raid硬件控制器。硬raid</li>
</ul>
</li>
<li>raid0：提高吞吐量<ul>
<li>每个磁盘的独立的，可以并行的对数据进行访问，提升吞吐量</li>
</ul>
</li>
<li>raid1：提高可靠性<ul>
<li>每个磁盘的独立的，可以并行的操作</li>
</ul>
</li>
<li>raid4：即提高性能又增加可靠性<ul>
<li>如：使用一块Parity Disk的盘存储校验码，其他盘可以做并行操作。这样当一块盘的数据坏时可以反推出损坏的数据</li>
</ul>
</li>
<li>raid5：raid4中Parity Disk的读写非常频繁，开销大<ul>
<li>把校验块均匀的分配在不同的disk中，开销均匀、访问并行</li>
<li><img src="./static/raid5.png"/>


</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/10/universe/att_vs_Intel_assembly_language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/universe/att_vs_Intel_assembly_language/" class="post-title-link" itemprop="url">AT&T与Intel汇编语言的比较</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-10T00:00:00+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-15 10:27:35" itemprop="dateModified" datetime="2020-07-15T10:27:35+08:00">2020-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GCC采用的是AT&amp;T的汇编格式，也叫GAS(Gnu Assembler)格式;微软采用Intel的汇编格式</p>
<h2 id="寄存器命名"><a href="#寄存器命名" class="headerlink" title="寄存器命名"></a>寄存器命名</h2><ul>
<li>ATT的汇编格式中，寄存器名前要加上”%”前缀</li>
<li>Inter格式中不用</li>
</ul>
<h2 id="操作数的顺序"><a href="#操作数的顺序" class="headerlink" title="操作数的顺序"></a>操作数的顺序</h2><ul>
<li>ATT目标操作数在源操作数的右边</li>
<li>Intel目标操作数在源操作数的左边</li>
<li>正好相反</li>
</ul>
<table>
<thead>
<tr>
<th>AT&amp;T</th>
<th>Intel</th>
</tr>
</thead>
<tbody><tr>
<td>movl %eax, %abx</td>
<td>mov ebx,eax</td>
</tr>
</tbody></table>
<h2 id="常数-立即数的格式"><a href="#常数-立即数的格式" class="headerlink" title="常数/立即数的格式"></a>常数/立即数的格式</h2><ul>
<li>ATT的汇编格式中，立即数要加上”$”前缀</li>
<li>Inter格式中不用</li>
</ul>
<h2 id="操作符长度标识"><a href="#操作符长度标识" class="headerlink" title="操作符长度标识"></a>操作符长度标识</h2><ul>
<li>ATT汇编格式中操作符的后缀”b”, “w”, “l”分别表示操作数为字节(byte, 8位)、字(word, 16位)、长字(long, 32位)</li>
<li>Intel中操作数长度会根据寄存器长度而定，也可用”byte ptr”、”word ptr”等前缀来表示</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><table>
<thead>
<tr>
<th>AT&amp;T</th>
<th>Intel</th>
</tr>
</thead>
<tbody><tr>
<td>imm32(basepointer,indexpointer,indexscale)</td>
<td>[base+indexpointer*indexscale+imm32]</td>
</tr>
</tbody></table>
<p>两种寻址效果都是：<code>imm32 + basepointer + indexpointer*indexscale</code></p>
<h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><ul>
<li><p>ATT汇编格式中，绝对跳转和调用指令(jump/call)的操作数前要加上”*“作为前缀</p>
<ul>
<li>远程跳转指令和远程子程序调用指令的操作码在ATT中为”ljump”和”lcall”</li>
<li>对应的返回指令为<code>lret</code></li>
</ul>
</li>
<li><p>Intel中不用</p>
<ul>
<li>远程跳转指令和远程子程序调用指令的操作码在Intel中为”jmp far”和”call far”</li>
<li>对应的返回指令为<code>ret</code></li>
</ul>
</li>
<li><p>ATT的汇编格式中，跳转指令有点特殊</p>
<ul>
<li>直接跳转，即跳转目标作为指令的一部分编码，如<code>ljump $a</code></li>
<li>间接跳转，即目标从寄存器或储存器位置中读出的。写法在”*“后面跟一个操作数指示符<ul>
<li><code>ljump *%eax</code>用寄存器%eax中的值作为目标</li>
<li><code>ljump *(%eax)</code>用寄存器%eax中的值作为读入地址，从存储器中读出跳转目标</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/Major/circuit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/Major/circuit/" class="post-title-link" itemprop="url">电路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-07T00:00:00+08:00">2020-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="半导体的工作原理"><a href="#半导体的工作原理" class="headerlink" title="半导体的工作原理"></a>半导体的工作原理</h2><p>半导体的材料一般是电子不多不少(不易获得也不易失去)的，如:硅(4最外层4电子)</p>
<p>电子多，说明核带正电多，对电子吸引力强; 电子少，说明核带正电少，对电子吸引力弱。</p>
<h3 id="晶体二极管"><a href="#晶体二极管" class="headerlink" title="晶体二极管"></a>晶体二极管</h3><p>纯硅电子不易得也不易失，我们称之为 <strong>本征半导体</strong> 。如果我们在硅中加入一点磷(最外层5电子)，则将不是在最外出4电子的基础上多了一个电子。这时这个电子将相对”自由”。这个整体带的电子比稳定的4电子多，我们就叫它N型半导体(Negetive)。</p>
<p>如果我们在本征半导体参入堋(最外层3个电子)，整体将变得渴望1个电子，我们将这个空的地方(为到达4电子)称为空穴。这些空穴有渴望电子的能力。相对4电子结构，空穴是Positive的，因此称为P型半导体。</p>
<p>采用特殊的技术，把P型半导体和N型半导体(P、N整体都是中性，别被PN误导)拼接在一起。那么由于P型半导体的空穴浓度高，N型半导体的空穴浓度低，空穴就会从P扩散到N;同理N型半导体的电子扩散到P型半导体，就像液体中的扩散一样。但扩散不会一直发生，当N中的空穴变多，变得带正电，P中的电子变多，变得带负电，形成电场。</p>
<p>随着电场的形成，电场将试图将P的电子拉到N，随着P的电子减少，电场减弱，扩散又发生，最后扩散和电场达到动态平衡。</p>
<ul>
<li>如果我们向N区通正电，新增的电场与内部的电场方向一致，电场将会变强。虽然仍会处于动态平衡，但是电场抑制了粒子移动，从而阻断电流。</li>
<li>如果我们向P区通整点，N区通负电，将压缩内电场，电子的束缚将变小从而导通电流</li>
<li>于是晶体二极管就诞生了</li>
</ul>
<h3 id="晶体三极管"><a href="#晶体三极管" class="headerlink" title="晶体三极管"></a>晶体三极管</h3><p>晶体三极管结构如下：</p>
<table>
<thead>
<tr>
<th>外</th>
<th>N</th>
<th>P</th>
<th>N</th>
<th>内</th>
</tr>
</thead>
<tbody><tr>
<td>通电电极</td>
<td>+</td>
<td>+</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>位置</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<p>每个PN接触面会形成PN节，一般0.7V的电压会导通PN节。</p>
<p>如果1号位和2号位电压大于0.7V，就通电了。需要注意的是，设计时，1号位故意参杂很多5电子元素，使得电子浓度很高;而2号位的半导体很薄，很难一次消耗掉这些涌入的电子;当2号涌入了很多电子又无法消耗，那么就打破了2号和3号的动态平衡。而且3号设计得很大电子浓度低，2号扩散过来的电子很快会被3号收集。又因为3号通的正电，电子得到了一个快速的泄洪通道，迅速通过电源正极。</p>
<p>这样一来，我们可以认为2号和3号通电了。又因为2号电子来自1号，所以1号也和3号通电了。</p>
<p>2号极小的信号改变就会导致1号电子涌入的巨大变化，从而引起1号与3号之间电流的巨大变化。</p>
<ul>
<li>1号连接负极，称为发射极</li>
<li>2号相当于阀门，操作这原始信号，称为基极</li>
<li>3号收集电子，称为集电极</li>
</ul>
<h3 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管"></a>场效应管</h3><p>将两个N型半导体浸如一个大的P型半导体中，两个N型半导体分别接入正极和负极，P型半导体接入正极，但与正极间隔这一个电容。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>N</th>
<th>P</th>
<th>N</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>通电电极</td>
<td>P</td>
<td>-</td>
<td>+电容</td>
<td>+</td>
<td>P</td>
</tr>
<tr>
<td>位置</td>
<td>P</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>P</td>
</tr>
<tr>
<td></td>
<td>P</td>
<td>P</td>
<td>P</td>
<td>P</td>
<td>P</td>
</tr>
</tbody></table>
<ul>
<li>1号由电源不断提供电子</li>
<li>2号不断吸引电子，但不会快速消耗电子</li>
<li>3号快速消耗电子</li>
</ul>
<p>由于2号电子处聚集了大量电子，3号消耗了很多电子，于是P型半导体由于电子聚集的位置与3号N型半导体由于电子消耗，半导体的类型发生了改变。即2号与3号之间，2号成了N型，3号成了P型，电子将扩散到3号并被快速消耗。又由于1号源源不断提供电子，不断涌向2号。于是1号和3号在2号的控制下形成了通电回路。</p>
<ul>
<li>1号提供电子，称为源极</li>
<li>2号像栅栏一样控制电路导通，称为栅极<ul>
<li>栅极的正负控制这电路的通阻，如果用01表示同断，那么计算机科学就开始了</li>
</ul>
</li>
<li>3号称为漏极</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
