<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/Major/OS/Operating_Systems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/12/Major/OS/Operating_Systems/" itemprop="url">操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-12T00:00:00+08:00">
                2020-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>shell对外暴露的接口，操作系统对外提供服务</p>
<p>特征</p>
<ul>
<li>并发<ul>
<li>同时存在多个运行的程序</li>
</ul>
</li>
<li>共享<ul>
<li>操作系统控制如何”同时”访问</li>
<li>文件互斥</li>
</ul>
</li>
<li>虚拟<ul>
<li>让每个用户/程序都觉得有一个计算机专门为它提供服务</li>
</ul>
</li>
<li>异步<ul>
<li>程序执行不是一贯到底的，向前推进的速度有系统调度</li>
<li>但是只要环境相同，每次运行的结果一定相同</li>
</ul>
</li>
<li>相互联系也相互区别</li>
</ul>
<ul>
<li>Microkernel:微内核架构设计<ul>
<li>只放基本的功能</li>
<li>文件管理、网路协议栈等都是放在外围以服务的形式存在，服务和服务之间通过内核的消息传递机制</li>
<li>相互隔离，很灵活，小巧</li>
<li>代价就是性能</li>
</ul>
</li>
<li>外核设计<ul>
<li>内核分成两块，<ul>
<li>Exokernel(外核)与硬件打交道：完成硬件功能的复制。</li>
<li>建立在exokernel之上，跟具体应用打交道，再通过它访问exokernel，来访问硬件<ul>
<li>可对应用进行相应的设计，使得速度更快</li>
<li>完成应用隔离</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>虚拟机</li>
</ul>
<h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><ul>
<li>计算机启动</li>
</ul>
<p>os存放在硬盘中，需要bootload将它放入内存。bootloader又由bios负责放入内存。</p>
<ul>
<li>bios提供各种支持：检测外设，初始化检查，把bootloader放入内存，让它执行</li>
<li>bootloader：加载os，从硬盘到内存</li>
</ul>
<p>应用间接与外设打交道，之所以应用不能直接访问外设是因为应用是不可信任的，而操作系统是可信任的;另一方面操作系统外为上层提供一致的接口，使得上层应用不用关注底层细节，通用可移植，提高效率。由此设计一下三个基本概念</p>
<ul>
<li><p>三个基本概念</p>
<ul>
<li>中断<ul>
<li>产生的源头：外设产生</li>
<li>处理的时间:异步事件，不会知道什么时候产生</li>
<li>响应：持续，对应用程序是透明的</li>
</ul>
</li>
<li>异常<ul>
<li>产生的源头：应用意想不到的行为</li>
<li>处理的时间：同步，一定在某个特定的指令可以产生，可以确定时间</li>
<li>响应：杀死或重新执行</li>
</ul>
</li>
<li>系统调用<ul>
<li>产生的源头：应用请求操作系统提供服务</li>
<li>处理的时间：同步或异步(返回点有可能是异步的)</li>
<li>响应：等待和持续</li>
</ul>
</li>
</ul>
</li>
<li><p>中断和异常的处理过程</p>
<ul>
<li>中断码<ul>
<li>查表</li>
</ul>
</li>
<li>保存和恢复<ul>
<li>程序执行过程中被中断，需要保存当前处理状态，便于恢复后继续执行</li>
</ul>
</li>
</ul>
</li>
<li><p>异常处理过程</p>
<ul>
<li>保存现场</li>
<li>异常处理<ul>
<li>异常编号，相应处理</li>
</ul>
</li>
<li>恢复现场</li>
</ul>
</li>
<li><p>系统调用过程</p>
<ul>
<li>访问系统调用接口</li>
<li>用户态切到内核态，控制权交给操作系统<ul>
<li>用户态：可执行权限低</li>
<li>内核态：可执行任何指令</li>
</ul>
</li>
<li>处理完成后返回成功失败</li>
</ul>
</li>
</ul>
<h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h2><h3 id="计算机体系结构及内存分层体系"><a href="#计算机体系结构及内存分层体系" class="headerlink" title="计算机体系结构及内存分层体系"></a>计算机体系结构及内存分层体系</h3><p>…</p>
<h3 id="地址空间与地址生成"><a href="#地址空间与地址生成" class="headerlink" title="地址空间与地址生成"></a>地址空间与地址生成</h3><ul>
<li>地址空间<ul>
<li>物理地址空间<ul>
<li>硬件支持的地址空间</li>
</ul>
</li>
<li>逻辑地址空间<ul>
<li>一个运行打程序所拥有的内存范围</li>
</ul>
</li>
</ul>
</li>
<li>地址空间生成<ul>
<li>cpu会根据逻辑地址查找物理地址，对应对应关系储存在MMU的表示映射关系的区域</li>
<li>CPU执行某条指令时，ALU根据指令的内容发送请求，携带逻辑地址。CPU中的MMU查找MMU对应的物理地址</li>
<li>逻辑地址和物理地址的联系又操作系统生成</li>
</ul>
</li>
<li>检查地址的安全<ul>
<li>确保每个程序访问的地址空间</li>
</ul>
</li>
</ul>
<h3 id="连续内存分配：内存碎片与分区的动态分配"><a href="#连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="连续内存分配：内存碎片与分区的动态分配"></a>连续内存分配：内存碎片与分区的动态分配</h3><ul>
<li><p>外碎片</p>
<ul>
<li>分配单元之间的未使用内存</li>
</ul>
</li>
<li><p>内碎片</p>
<ul>
<li>在分配单元中的碎片</li>
</ul>
</li>
<li><p>简单的内存管理方法</p>
<ul>
<li>当一个程序准许运行在内存中时，分配一个连续的区间</li>
<li>分配一个连续的内存区间给运行的程序以访问数据</li>
</ul>
</li>
<li><p>分配策略</p>
<ul>
<li>首次适配算法<ul>
<li>碰到的第一个能够满足需求的空闲块，分配给程序</li>
<li>需求<ul>
<li>按照地址排序的空闲地址块列表</li>
<li>重新分配需要检查，看是否有空闲块能够合并</li>
</ul>
</li>
<li>优势<ul>
<li>简单</li>
<li>易于把大的空闲块留在结尾</li>
</ul>
</li>
<li>劣势<ul>
<li>容易产生外碎片</li>
<li>不确定性</li>
</ul>
</li>
</ul>
</li>
<li>最优适配算法<ul>
<li>寻找最适合的空闲块</li>
<li>需求<ul>
<li>按照大小排序的空闲地址块列表</li>
<li>重新分配需要检查，看是否有空闲块能够合并</li>
</ul>
</li>
<li>优势<ul>
<li>避免了把大的空闲块拆散</li>
<li>最小化外部碎片的产生</li>
<li>比较简单</li>
</ul>
</li>
<li>劣势<ul>
<li>重新分配慢</li>
<li>外碎片拆得很细，使得将来的利用可能性小</li>
<li>易产生很多没用的小碎片</li>
</ul>
</li>
</ul>
</li>
<li>最差适配算法<ul>
<li>与最优相反，找差距最大的空闲块</li>
<li>需求<ul>
<li>按照大小排序的空闲地址块列表</li>
<li>重新分配需要检查，看是否有空闲块能够合并</li>
</ul>
</li>
<li>优势<ul>
<li>分配时中等尺寸时效果最小</li>
</ul>
</li>
<li>劣势<ul>
<li>易于破碎大的空间，以致于(将来需要时)大分区无法被分配</li>
<li>重新分配慢</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="连续内存分配：压缩式与交换式碎片整理"><a href="#连续内存分配：压缩式与交换式碎片整理" class="headerlink" title="连续内存分配：压缩式与交换式碎片整理"></a>连续内存分配：压缩式与交换式碎片整理</h3><ul>
<li>压缩式碎片整理<ul>
<li>重置程序以合并孔洞</li>
<li>要求所有程序是动态可重置的</li>
<li>思考：<ul>
<li>何时重置</li>
<li>开销</li>
</ul>
</li>
</ul>
</li>
<li>交换式碎片整理(swaping)<ul>
<li>运行程序需要更多的内存</li>
<li>把硬盘当作内存的备份(虚拟内存)，将等待需求较长的程序挪到硬盘腾出内存</li>
<li>抢占等待的程序&amp;回收他们的内存</li>
<li>思考<ul>
<li>那些程序交换</li>
<li>何时换入换出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-4"><a href="#Part-4" class="headerlink" title="Part 4"></a>Part 4</h2><h3 id="非连续内存分配：分段"><a href="#非连续内存分配：分段" class="headerlink" title="非连续内存分配：分段"></a>非连续内存分配：分段</h3><ul>
<li><p>连续内存分配的缺点</p>
<ul>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片和内碎片的问题</li>
</ul>
</li>
<li><p>为什么需要非连续内存分配(优点)</p>
<ul>
<li>一个程序的物理地址空间是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码和数据</li>
<li>支持动态加载和动态链接</li>
</ul>
</li>
<li><p>非连续分配的缺点</p>
<ul>
<li>管理开销：如何建立虚拟地址和物理地址之间的转换<ul>
<li>软件方案</li>
<li>硬件方案<ul>
<li>分段</li>
<li>分页</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分段</p>
<ul>
<li>段访问机制<ul>
<li>程序访问内存需要一个二维数组(段号s，段内偏移addr)</li>
</ul>
</li>
<li>分段的寻址方案<ul>
<li>虚拟内存通过某种映射联系到物理地址</li>
<li>需要一个段表，操作系统建立</li>
<li>需要直到段的大小，防止偏移地址超出范围</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="非连续内存分配：页表"><a href="#非连续内存分配：页表" class="headerlink" title="非连续内存分配：页表"></a>非连续内存分配：页表</h3><p>页表其实就是一个大数组，每个运行的程序都有一个页表，每个页表有(page num, offset)</p>
<ul>
<li><p>属于程序运行状态，会动态变化</p>
</li>
<li><p>PIBR：页表基址寄存器</p>
</li>
<li><p>页表内容</p>
<ul>
<li>Flag标志位<ul>
<li>dirty bit：是否合法</li>
<li>resident bit：物理地址中是否存在</li>
<li>clock/reference bit</li>
</ul>
</li>
<li>帧号frame num：f</li>
</ul>
</li>
<li><p>CPU通过页号和偏移寻址到对应的页表项，把帧号和偏移组合形成物理地址</p>
</li>
<li><p>分页机制的性能问题：</p>
<ul>
<li>访问一个内存单元需要两次内存地址访问<ul>
<li>一次获取表项</li>
<li>一次访问数据</li>
</ul>
</li>
<li>页表可能很大，而且为了隔离每个程序要有自己的页表</li>
<li>页表空间大，因此访问效率页会有问题</li>
</ul>
</li>
<li><p>解决办法</p>
<ul>
<li>缓存近期访问的页帧转换表项(TLB)<ul>
<li>TLB使用关联内存实现，具备快速访问性能</li>
<li>如果TLB命中，物理页号可以很快获取</li>
<li>如果TLB未命中TLB miss，对应的表项被更新到TLB中<ul>
<li>多数编程(访问)的局部性可以降低TLB miss</li>
</ul>
</li>
</ul>
</li>
<li>间接访问</li>
</ul>
</li>
</ul>
<h3 id="非连续内存分配：页表-二级、多级页表"><a href="#非连续内存分配：页表-二级、多级页表" class="headerlink" title="非连续内存分配：页表-二级、多级页表"></a>非连续内存分配：页表-二级、多级页表</h3><p>速度问题解决了，空间上如何解决？那就需要页表分级</p>
<p>以二级页表举例，把一块大的页表分成两块，把大的page num分成两块：p1、p2。<br>通过一级表[p1]找到二级表的地址，在用二级表地址做索引，二级表[p2]找到frame num就可以找到物理地址。</p>
<p>整个过程多了寻址，导致开销增大，但是通过分级，当物理地址不存在时(在一级表就可以得出)，从而二级表不必保存这部分内容。以时间换空间。</p>
<p>多级页表同理</p>
<h3 id="非连续内存分配：页表-反向页表"><a href="#非连续内存分配：页表-反向页表" class="headerlink" title="非连续内存分配：页表-反向页表"></a>非连续内存分配：页表-反向页表</h3><p>前面所讲的页表的大小都和逻辑地址空间的大小有对应关系，逻辑空间寻址的范围越大，页表越多。</p>
<ul>
<li>大地址空间的问题：<ul>
<li>有大地址空间(64bits)，向前映射页表变得繁琐</li>
<li>不是让页表与逻辑空间的大小对应，而是让页表与物理地址空间大小对应</li>
</ul>
</li>
</ul>
<p>有什么办法使得页表项和逻辑地址空间没有那么大的关系，尽量和物理地址空间大小有关？这就是反向页表的想法。</p>
<p>前面都是以逻辑页号来索引页表(一个大数组)，能否用页帧号(物理页号)来查找对应的逻辑页的页号呢？这样就能省很多空间。</p>
<p>基于哈希查找的方案</p>
<h2 id="Part-5"><a href="#Part-5" class="headerlink" title="Part 5"></a>Part 5</h2><h3 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h3><p>理想中的存储器：更大、更快、更便宜的非易失性存储器</p>
<h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><ul>
<li>目标<ul>
<li>在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区储存管理配合</li>
</ul>
</li>
<li>原理<ul>
<li>把程序按照自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按照时间先后来运行<ul>
<li>必要部分(常用功能)的代码和数据常驻内存</li>
<li>可选部分(不常用功能)在其他程序模块中实现，平时存放在外存中，在需要时才装入内存</li>
<li>不存在调用关系的模块不必同时装入到内存，从而可以 <strong>相互覆盖</strong> 即这些模块共享一个分区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul>
<li>目标<ul>
<li>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源</li>
</ul>
</li>
<li>方法<ul>
<li>将暂时不能运行的程序送到外存，从而获得空闲内存空间</li>
<li>操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out)，而将外存中的某个进程的地址空间读入内存中(换入swap in)。换入换出内容的大小为整个程序的地址空间</li>
</ul>
</li>
<li>存在的问题<ul>
<li>交换的时机：只当内存空间不够或有不够的危险时换出</li>
<li>交换区的大小：必须足够大以存放所有用户进程的所有内存映像的拷贝</li>
<li>程序换入时的重定位：最好采用动态地址映射的方法</li>
</ul>
</li>
</ul>
<h3 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h3><ul>
<li><p>上面方法的不足</p>
<ul>
<li>覆盖技术：需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担</li>
<li>交换技术：以进程作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销</li>
</ul>
</li>
<li><p>虚存技术的目标：</p>
<ul>
<li>像覆盖技术那样，但做的更好，由操作系统完成，不需要程序员的干涉</li>
<li>像交换技术那样，但做的更好，只对进程的部分内容在内存和外存之间进行交换</li>
</ul>
</li>
<li><p>原理：利用程序的局部性</p>
</li>
<li><p>基本特征：</p>
<ul>
<li>大的用户空间：与外存相结合</li>
<li>部分交换：不同于交换技术，可以部分交换</li>
<li>不连续：物理内存分配不连续，虚拟地址空间使用不连续</li>
</ul>
</li>
<li><p>虚拟技术-虚拟页式内存管理</p>
<ul>
<li>基本思路：<ul>
<li>当程序需要调入内存运行时，不是将程序的所有页都装入内存，而是只装如部分页，就可启动程序而运行</li>
<li>在运行的过程中，如果发现运行的程序或要访问的数据不再内存，则发出缺页中断请求，系统在处理这个中断时，将外存中相应的页调入内存，使得程序能够运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为了事先虚拟页式内存管理，需要在页表项中多加几位：</p>
<table>
<thead>
<tr>
<th>逻辑页号</th>
<th>访问位</th>
<th>修改位</th>
<th>保护位</th>
<th>驻留位</th>
<th>物理页帧号</th>
</tr>
</thead>
</table>
<ul>
<li>驻留位<ul>
<li>表示改页是内存还是外存，如果为1,表示在内存中，可以访问，否则导致缺页中断</li>
</ul>
</li>
<li>保护位<ul>
<li>表示允许对该页做何种类型的访问，如只读、只写等</li>
</ul>
</li>
<li>修改位<ul>
<li>表示页在内存中是否修改过，当系统回收改物理页时，根据此位来决定是否把它的内存写回到外存(跟新外存的数据)</li>
</ul>
</li>
<li>访问位<ul>
<li>表明是否访问过。用于置换算法</li>
</ul>
</li>
</ul>
<h2 id="Part-6"><a href="#Part-6" class="headerlink" title="Part 6"></a>Part 6</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><ul>
<li><p>功能</p>
<ul>
<li>当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换</li>
</ul>
</li>
<li><p>目标</p>
<ul>
<li>尽可能减少页面换入换出的次数</li>
</ul>
</li>
<li><p>最优页面置换算法</p>
<ul>
<li>思路：当缺页发生时，选择等待时间最长的那个(将来长一段时间不会发生)，作为置换页面</li>
<li>这一种情况实际无法实现的原因是操作系统无法知道每个页面等待多长时间以后消失。所以只能尽可能接近，作为参考来比较其他算法</li>
</ul>
</li>
</ul>
<h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h3><ul>
<li>思路<ul>
<li>选择在内存中驻留时间最长的页面并淘汰之。即维护一个链表，链表记录所有的逻辑页，链首表示驻留时间最长。缺页时把链首淘汰，把新页添加到链尾</li>
</ul>
</li>
<li>性能较差，并且有Belady现象<ul>
<li>Belady现象<ul>
<li>在采用FIFO算法时，有时出现分配的物理页数增加，缺页率反而提高的异常现象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h3><ul>
<li>思路<ul>
<li>缺页发生时，替换最久未被使用的页，并淘汰之</li>
<li>利用局部性原理</li>
</ul>
</li>
<li>需要记录使用时间的先后顺序，开销较大。两种可能的实现方法：<ul>
<li>维护链表</li>
<li>堆栈，最新的压到栈顶，但是要查找一遍把已经存在的剔除</li>
</ul>
</li>
</ul>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>时钟页面置换算法，LRU的近似，对FIFO的一种改进。</p>
<ul>
<li>基本思路<ul>
<li>需要用到表项当中的访问位。当一个页面被装入内存时，把该位初始化为0。如果这个页面被访问到，则把该位置置为1</li>
<li>把各个页面组织成环形链表，指针指向最老的页面</li>
<li>当缺页发生时，考虑指针指向的最老的页面，如果它的访问位为0，则淘汰。如果访问位为1，则把它置为0,然后指针往下寻找</li>
</ul>
</li>
</ul>
<h3 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h3><p>时钟页面置换算法的访问并没有区分读还是写。实际中如果执行了写操作dirty bit会置为1，如果只是读dirty bit是0。那么dirty bit有什么用呢？</p>
<p>如果进行的是写操作，那么需要同时写到内存和硬盘(数据一致)。如果是只进行读操作，由于内容并没有改变，只需释放内存，然后换入即可。这种使用两个bit的算法就是二次机会法。</p>
<p>used bit、dirty bit的转变规则如下</p>
<table>
<thead>
<tr>
<th>如果</th>
<th>则</th>
</tr>
</thead>
<tbody><tr>
<td>used | dirty</td>
<td>used | dirty</td>
</tr>
<tr>
<td>0     0</td>
<td>替换的页</td>
</tr>
<tr>
<td>0     1</td>
<td>0     0</td>
</tr>
<tr>
<td>1     0</td>
<td>0     0</td>
</tr>
<tr>
<td>1     1</td>
<td>0     1</td>
</tr>
</tbody></table>
<h3 id="最不常用算法-LFU"><a href="#最不常用算法-LFU" class="headerlink" title="最不常用算法(LFU)"></a>最不常用算法(LFU)</h3><ul>
<li>基本思路<ul>
<li>缺页发生时，淘汰访问次数最少的页面</li>
</ul>
</li>
<li>维护计数器、顺序</li>
</ul>
<h3 id="局部页面替换算法的问题、工作集模型"><a href="#局部页面替换算法的问题、工作集模型" class="headerlink" title="局部页面替换算法的问题、工作集模型"></a>局部页面替换算法的问题、工作集模型</h3><p>如果局部性原理不成立，则各种置换算法效果没有区别。如果局部性原理成立，则可以通过工作集模型来表现。</p>
<ul>
<li><strong>工作集</strong> ：一个进程当前正在使用了逻辑页面集合，可以用一个二元函数$W(t, \Delta)$来表示<ul>
<li>t是当前的执行时刻</li>
<li>$\Delta$称为工作集窗口，即一个定长的页面访问的时间窗口</li>
<li>$W(t, \Delta)=$在当前时刻t之前的$\Delta$时间窗口当中的所有页面所组成的集合(随着t的变化， 该集合页不断地变化)</li>
<li>$|W(t, \Delta)|$值工作集的大小，即页面数目(不同页面的个数)</li>
</ul>
</li>
<li><strong>常驻集</strong> ：当前时刻，进程实际驻留在内存的页面集合<ul>
<li>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配进程的物理页的数目，以及所采用的页面置换算法</li>
<li>当常驻集的大小达到某个数目之后，在给他分配更多的物理页面，缺页率页不会明显下降</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    t: 0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line">pages: a c d c b a a b b d b</span><br><span class="line"></span><br><span class="line">若Delta&#x3D;4, t&#x3D;5, 则</span><br><span class="line">工作集大小&#x3D;4(dcba)</span><br><span class="line"></span><br><span class="line">若Delta&#x3D;3, t&#x3D;8, 则</span><br><span class="line">工作集大小&#x3D;2(abb)</span><br></pre></td></tr></table></figure>


<h3 id="全局置换算法"><a href="#全局置换算法" class="headerlink" title="全局置换算法"></a>全局置换算法</h3><p>把眼光放到整个系统的所有程序，而不仅仅是专注一个程序的页面置换。程序之间物理页需求不同，操作系统可以进行动态调节。</p>
<ul>
<li>缺页率页面置换算法<ul>
<li>可变分配策略：常驻集大小可变。如每个进程刚开始的时候，先根据程序大小给它分配一定数目的物理页面，然而在程序运行中，再动态调节常驻集大小<ul>
<li>当一个缺页中断发生时，被置换的页面可以是在其他进程当中。各个并发进程竞争地使用物理页面</li>
<li>优缺点：性能较好，但增加了系统开销</li>
<li>具体实现：可以使用缺页率算法来到动态调整常驻集大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-7"><a href="#Part-7" class="headerlink" title="Part 7"></a>Part 7</h2><h3 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h3><ul>
<li>进程控制块：操作系统管理控制进程所需的信息集合<ul>
<li>操作系统用 <strong>PCB(Process Control Block)</strong> 来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志<ul>
<li>进程的创建：为该进程生成一个PCB</li>
<li>进程的终止：回收它的PCB</li>
<li>进程的组织管理：通过PCB的组织管理来实现</li>
</ul>
</li>
<li>PCB含有以下三大类信息<ul>
<li>进程的标识信息</li>
<li>处理机状态信息</li>
<li>进程控制信息</li>
</ul>
</li>
<li>PCB的组织方式<ul>
<li>链表：经常有动态插入删除的操作系统</li>
<li>索引表(数组)：不常有动态插入删除的操作系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的生命周期原理"><a href="#进程的生命周期原理" class="headerlink" title="进程的生命周期原理"></a>进程的生命周期原理</h3><ul>
<li>进程创建<ul>
<li>引起进程创建的3个主要事件<ul>
<li>系统初始化</li>
<li>用户请求创建一个新进程</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
</li>
</ul>
</li>
<li>进程运行<ul>
<li>一个就绪的进程开始运行</li>
</ul>
</li>
<li>进程等待<ul>
<li>一个进程没有就绪，就进入等待，让其他进程先执行</li>
</ul>
</li>
<li>进程唤醒<ul>
<li>等待的进程就绪</li>
</ul>
</li>
<li>进程结束</li>
</ul>
<h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><ul>
<li>进程挂起<ul>
<li>进程没有占用内存空间，叫做进程挂起</li>
<li>阻塞挂起状态：进程在外存并等待某时间的提出</li>
<li>就绪挂起状态：进程在外存，但只要进入内存即可运行</li>
</ul>
</li>
<li>状态队列把进程管理起来<ul>
<li>一个队列只存一种状态的进程</li>
</ul>
</li>
</ul>
<h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>线程就是进程中的一条执行流程</p>
<ul>
<li>特性<ul>
<li>线程间可以并发执行</li>
<li>线程间共享相同的地址空间</li>
</ul>
</li>
<li>优点<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各个线程之间可以并发地执行</li>
<li>各个线程之间可以共享相同地址空间和文件等资源</li>
</ul>
</li>
<li>缺点<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>
<li>如：浏览器如果使用一个页面一个进程，则该页面崩溃不会影响其他页面</li>
</ul>
</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式</p>
<ul>
<li>用户线程：在用户空间实现<ul>
<li>在用户空间实现的线程机制不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理</li>
<li>操作系统只能感知到线程所属的进程</li>
<li>缺点：<ul>
<li>如果一个线程发起系统调用而阻塞，则整个进程进入等待。因为操作系统只能感知到进程，所以操作系统阻塞了进程，导致所有的线程阻塞</li>
<li>当一个线程开始运行后，除非它主动交出CPU的使用权，否则它所在的进程当中的其他线程将无法使用。因为用户进程没有打断线程的特权</li>
<li>由于时间分片分配给进程，故与其他进程比，在多个线程执行时，每个线程得到的时间片少，执行会慢。</li>
</ul>
</li>
</ul>
</li>
<li>内核线程：在内核中实现</li>
<li>轻量级进程：在内核中实现，支持用户线程<ul>
<li>内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程有一个单独的内核线程来支持</li>
</ul>
</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>各个进程共享CPU资源，不同时刻进程需要切换，让别的进程能够执行。这个切换过程称为进程的上下文切换。</p>
<h2 id="Part-8"><a href="#Part-8" class="headerlink" title="Part 8"></a>Part 8</h2><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul>
<li>FCFS：先来先服务</li>
<li>SPN(SJF) SRT：短进程优先 短剩余时间优先<ul>
<li>可抢占，导致长进程可能一直得不到执行</li>
</ul>
</li>
<li>HRRN：最高响应比优先<ul>
<li>$R=(w+s)/s$，w是等待时间，s是执行时间。不可抢占，一定程度防止了长进程得不到执行的问题</li>
</ul>
</li>
<li>Round Robin：轮循<ul>
<li>各个进程轮流占用CPU</li>
<li>会引入额外的上下文切换开销，时间片太小切换太频繁，时间片太大等待时间太久</li>
</ul>
</li>
<li>Multilevel Feedback Queue：多级反馈队列<ul>
<li>不同级别队列可以采用不同的调度方案，根据进程特点划分</li>
</ul>
</li>
<li>Fair Share Scheduling：公平共享调度</li>
</ul>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><ul>
<li>实时系统<ul>
<li>定义：正确性依赖于其时间和功能两方面的一种操作系统。即因为是实时的，如果不能在规定时间完成，则失去时效性</li>
<li>强实时系统<ul>
<li>需要在保证的时间内完成重要的任务，必须完成</li>
</ul>
</li>
<li>弱实时系统<ul>
<li>要求重要的进程优先级更高，尽量完成，非必须</li>
</ul>
</li>
<li>性能指标<ul>
<li>时间约束的及时性(deadline)</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>主要特征：时间约束的可预测性</li>
</ul>
</li>
</ul>
<h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3><p>举个例子：设优先级$T1&gt;T2&gt;T3$，T3先执行并访问一块共享资源(上锁)，但还没解锁CPU就调度去执行T1。当T1也要访问这共享资源时，要等T3使用完毕(解锁)。但这时由于T2优先级高于T3，T2想要执行了，抢占了CPU，那么T1的执行时间被T2延长了。</p>
<ul>
<li>解决办法<ul>
<li>优先级继承<ul>
<li>低优先级任务继承高优先级任务的优先级依赖于他们共享的资源，即在上面这个例子中，由于T1要等待T3访问完毕，所以T3的优先级得到动态的提升和T1一样。</li>
</ul>
</li>
<li>优先级天花板<ul>
<li>资源的优先级和所有可能锁定该资源的任务中优先级最高的那个任务的优先级相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-9"><a href="#Part-9" class="headerlink" title="Part 9"></a>Part 9</h2><h3 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h3><ul>
<li>临界区：进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时不会被执行的代码区域</li>
<li>互斥：访问临界区的进程只有一个</li>
<li>死锁：两个或以上的进程，在互相等待完成待定任务</li>
<li>饥饿：一个可执行进程持续得不到执行</li>
<li>原子操作：一次不存在中断或者失败的执行(不可在”分”的最小单位，原子)</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>并发存在的问题：同时对一个数据进行写入操作会存在问题，因为写入操作大致可分为这么几个步骤：读取数据、操作数据、写入数据。由于cpu在线程间切换，如果操作数据后切换到另一个进程，然后才写入数据，将导致问题。</p>
<p>为了解决上面的并发问题，引入互斥锁机制，使得共享的数据一次只能一个进程操作，其他需要等待正在使用的进程使用结束</p>
<ul>
<li>上锁操作执行顺序(也存在上下文切换)问题:<ul>
<li>方案一：<ul>
<li><ol>
<li>判断是否操作共享资源</li>
</ol>
</li>
<li><ol start="2">
<li>判断是否有锁</li>
</ol>
</li>
<li><ol start="3">
<li>上锁</li>
</ol>
</li>
<li>存在问题，如果A先执行1、2，然后切换到B。B也会成功执行1、2进入3的区域。这时A和B都可以执行3，并没有起到锁的保护机制：只让一个进程操作</li>
</ul>
</li>
<li>方案二：<ul>
<li><ol>
<li>上锁</li>
</ol>
</li>
<li><ol start="2">
<li>判断是否有锁</li>
</ol>
</li>
<li><ol start="3">
<li>判断是否操作共享资源</li>
</ol>
</li>
<li>存在问题，A执行了1二话不说先上锁，然后切换到B。B也二话不说先上锁，这时A和B都被对方锁住，谁都不会执行</li>
<li>这种由于进程切换导致谁都不执行的现象称为饥饿</li>
</ul>
</li>
<li>方案三：使用临界区</li>
</ul>
</li>
</ul>
<h3 id="临界区的创建"><a href="#临界区的创建" class="headerlink" title="临界区的创建"></a>临界区的创建</h3><ul>
<li>禁用硬件中断<ul>
<li>虽然在临界区中执行时不会被随意切换了，但对于外设的事件也得不到相应</li>
<li>而且对于多核CPU，要屏蔽所有CPU的相应中断能力，所在多CPU情况下无法解决互斥问题</li>
</ul>
</li>
<li>基于软件的解决方法<ul>
<li>设有两个线程T0、T1,它们的结构通常为<code>while(1){进入临界区;执行临界区代码;退出临界区}</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;  <span class="comment">// 指示该谁进入临界区</span></span><br><span class="line"><span class="keyword">bool</span> flag[];  <span class="comment">// 指示进程是否准备好进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 进入临界区的代码</span></span><br><span class="line">    flag[i] = TRUE;</span><br><span class="line">    <span class="built_in">turn</span> = j;</span><br><span class="line">    <span class="keyword">while</span>(flag[j]&amp;&amp;<span class="built_in">turn</span>==j);</span><br><span class="line">        <span class="comment">//操作</span></span><br><span class="line">    <span class="comment">// 退出临界区的代码</span></span><br><span class="line">    flag[i] = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>更高级的抽象：基于硬件的一些原子操作<ul>
<li>Test-and-Set：这是一条完成读和写的机器指令<ul>
<li><ol>
<li>从内存读值</li>
</ol>
</li>
<li><ol start="2">
<li>测试该值是否为1(返回bool)</li>
</ol>
</li>
<li><ol start="3">
<li>内存值设置为1</li>
</ol>
</li>
</ul>
</li>
<li>交换exchange<ul>
<li>交换两个内存中的值</li>
</ul>
</li>
<li>上面两条指令都是原子操作，不会被切换、中断</li>
<li>缺点：<ul>
<li>忙等消耗处理器时间</li>
<li>当进程离开临界区并且多个进程在等待的时候可能导致饥饿(抢lock抢不到)</li>
<li>死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程也要求，那么高优先级进程会获得处理器并等待临界区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-10"><a href="#Part-10" class="headerlink" title="Part 10"></a>Part 10</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>抽象数据类型<ul>
<li>一个整形(sem)，两个原子操作</li>
<li>P()：sem减1,如果sem&lt;0，等待，否则继续</li>
<li>V()：sem加1,如果sem&lt;=0(说明有有一些进程在等待)，唤醒一个等待的P</li>
</ul>
</li>
</ul>
<h4 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h4><ul>
<li>信号量是整数</li>
<li>信号量的被保护的变量<ul>
<li>初始化完成后，唯一改变一个信号量的值的方法是通过P()和V()</li>
<li>操作必须是原子</li>
</ul>
</li>
<li>P()能够阻塞，V()不会阻塞</li>
<li>我们假定信号量是”公平的”<ul>
<li>没有线程被阻塞在P()仍然堵塞V()被无限频繁调用(在同一信号量)</li>
</ul>
</li>
<li>两种类型信号量<ul>
<li>二进制信号量：可以是0或1</li>
<li>一般/计数信号量：可是任何非负数<ul>
<li>允许多个执行P操作的进程进入后续操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex-&gt;P()</span><br><span class="line">临界区</span><br><span class="line">mutex-&gt;V()</span><br></pre></td></tr></table></figure>


<h4 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h4><p>基本结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::P()&#123;</span><br><span class="line">    sem--;</span><br><span class="line">    <span class="keyword">if</span>(sem&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        把这个线程放入等待队列q;</span><br><span class="line">        block(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::V()&#123;</span><br><span class="line">    sem++;</span><br><span class="line">    <span class="keyword">if</span>(sem&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        从等待队列中取出一个线程t</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>building</p>
<ul>
<li>目的：分离互斥和条件同步的关注</li>
<li>什么是管程：<ul>
<li>一个锁：指定临界区</li>
<li>0或多个条件变量：等待/通知信号量用于管理并发访问共享数据</li>
</ul>
</li>
<li>一般方法<ul>
<li>收集在对象/模块中的相关共享数据</li>
<li>定义方法来访问共享数据</li>
</ul>
</li>
</ul>
<h2 id="Part-11"><a href="#Part-11" class="headerlink" title="Part 11"></a>Part 11</h2><p> <strong>IIII</strong> </p>
<h3 id="死锁的特征"><a href="#死锁的特征" class="headerlink" title="死锁的特征"></a>死锁的特征</h3><ul>
<li>互斥：在一个时间只能有一个进程使用资源</li>
<li>持有并等待：进程保持至少一个资源正在等待获取其他进程持有的额外资源</li>
<li>不抢占：一个资源只能被进程自愿释放</li>
<li>循环等待：一个等一个的环，但有环不一定有死锁</li>
</ul>
<h3 id="死锁处理办法"><a href="#死锁处理办法" class="headerlink" title="死锁处理办法"></a>死锁处理办法</h3><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>死锁出现我们将死锁出现的某个条件打破是不是就解决了?</p>
<ul>
<li>打破占用并等待<ul>
<li>一次占用所有所需的资源否则就不拿资源，是不是就防止了其他进程插足<ul>
<li>缺点是资源利用率低，可能发生饥饿</li>
</ul>
</li>
</ul>
</li>
<li>打破不抢占<ul>
<li>过于极端，导致被抢占的进程无法正常运行</li>
</ul>
</li>
<li>打破循环等待<ul>
<li>对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请</li>
</ul>
</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>申请资源时进行判断是否会出现死锁。需要操作系统提供一些额外的先验信息：</p>
<ul>
<li>最简单的方法如：每个进程声明它可能需要的每个类型资源的最大数目</li>
<li>限制提供与分配的资源数量，不能超过个某个最大需求</li>
<li>死锁避免算法动态检查资源分配状态，以确保永远不会有一个环形等待状态<ul>
<li>但是有环并不一定有死锁</li>
</ul>
</li>
</ul>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><blockquote>
<p>有人找银行家贷款，银行家判断是否能够贷款收回，能收回才放贷。</p>
</blockquote>
<ul>
<li>前提条件<ul>
<li>多个进程实例</li>
<li>每个进程必须最大限度利用资源</li>
<li>当一个进程请求资源，得不到就不等待</li>
<li>当一个进程得到所有的资源就必须在一定的时间内释放</li>
</ul>
</li>
</ul>
<p>基于上述条件，银行家算法通过寻找允许每个进程获得的最大资源并结束的进程理想执行时序，来决定是否安全。不存在满足要求的执行时序状态都是不安全的。</p>
<ul>
<li><p>数据结构</p>
<ul>
<li>n = 进程数量，m = 资源类型数量</li>
<li>Max(总需求量)：n x m矩阵。Max[i, j] = k表示，进程$P_i$最多请求资源类型$R_j$的实例个数为k</li>
<li>Available(空闲量)：长度为m的向量。Available[j] = k表示有k个$R_j$类型的资源可用</li>
<li>Allocation[i, j](已分配)</li>
<li>Need[i, j](未来需要量)</li>
<li>Need[i, j] = Max[i, j] - Allocation[i, j]</li>
</ul>
</li>
<li><ol>
<li>初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; work和finish分别是长度为m和n的向量</span><br><span class="line">work &#x3D; Available  &#x2F;&#x2F; 当前剩余</span><br><span class="line">finish[i] &#x3D; false for i in range(n) &#x2F;&#x2F; 线程i没结束</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>判断能否申请到：找到need比work小的进程i<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 要求</span><br><span class="line">(a) finish[i] &#x3D; false</span><br><span class="line">(b) need_i &lt;&#x3D; work</span><br></pre></td></tr></table></figure>
<ul>
<li>没找到跳转到4</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>申请到后认为进程可以正常结束<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 进程i的资源要求量小于当前的剩余空闲资源量</span><br><span class="line">work &#x3D; work + allocation  &#x2F;&#x2F; 回收</span><br><span class="line">finish[i] &#x3D; true</span><br></pre></td></tr></table></figure>
<ul>
<li>跳转到2</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>如果步骤2找不到这样的进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if finish[i] &#x3D;&#x3D; true for all i  &#x2F;&#x2F; 表明安全状态</span><br><span class="line">    可以分配</span><br><span class="line">else 不应该分配</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h4 id="死锁检测和死锁恢复"><a href="#死锁检测和死锁恢复" class="headerlink" title="死锁检测和死锁恢复"></a>死锁检测和死锁恢复</h4><ul>
<li>死锁检测<ul>
<li>维护等待图<ul>
<li>节点是进程</li>
<li>$P_i \rightarrow P_j$：Pi等待Pj</li>
</ul>
</li>
<li>定期调用检测算法来搜索图中是否存在循环</li>
<li>算法需要$n^2$次操作，n是图中定点的数目</li>
<li>开销比较大</li>
</ul>
</li>
<li>死锁恢复<ul>
<li>终止所有的死锁进程<ul>
<li>比较暴力</li>
</ul>
</li>
<li>在一个时间内终止一个进程直到死锁消除<ul>
<li>基于进程的优先级</li>
<li>基于进程运行需要的时间</li>
<li>基于进程的资源占用</li>
<li>基于进程需要的资源</li>
<li>基于进程需要被终止的数目</li>
<li>基于进程是交互还是批处理</li>
</ul>
</li>
<li>资源抢占</li>
</ul>
</li>
</ul>
<h3 id="IPC-进程间通信-Inter-Process-Communication"><a href="#IPC-进程间通信-Inter-Process-Communication" class="headerlink" title="IPC(进程间通信:Inter-Process Communication)"></a>IPC(进程间通信:Inter-Process Communication)</h3><ul>
<li>直接通信<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个连接存在<ul>
<li>打破进程间的隔离</li>
</ul>
</li>
</ul>
</li>
<li>间接通信<ul>
<li>定向从消息队列接收消息</li>
</ul>
</li>
<li>信号<ul>
<li>类似与中断信号，但在IPC中是基于软件的信号</li>
<li>实现：<ul>
<li>在程序中编写handler负责处理操作系统发出的信号</li>
<li>收到信号后操作系统把本来应该向下执行的地址改为信号处理函数的入口地址</li>
</ul>
</li>
<li>进程可以接收、可以忽略</li>
<li>不足是信号不传参数，只是信号(某种标记)</li>
</ul>
</li>
<li>管道pipe<code>a | b</code><ul>
<li>用于数据交换，通过父进程帮子进程建立好通道</li>
<li>把a的输出放入缓冲区buffer，把这个缓冲区的内容当作b的输入</li>
</ul>
</li>
<li>消息队列<ul>
<li>不同于管道<ul>
<li>没有父子关系</li>
<li>管道里数据是一种字节流，不是一种结构化的数据</li>
</ul>
</li>
</ul>
</li>
<li>共享内存<ul>
<li>一种直接通信方式，共享内存</li>
<li>优点：快速，方便的共享数据</li>
<li>缺点：必须同步数据访问，需要同步互斥机制</li>
</ul>
</li>
</ul>
<h2 id="Part-12"><a href="#Part-12" class="headerlink" title="Part 12"></a>Part 12</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><ul>
<li>内核跟踪每个进程打开的文件<ul>
<li>操作系统为每个进程维护一个打开文件表</li>
<li>一个打开文件描述符是这个表中的索引</li>
</ul>
</li>
<li>需要元数据来管理打开文件<ul>
<li>文件指针：指向最近一次读写位置，每个打开这个文件的进程都有这个指针</li>
<li>文件打开计数器：记录文件打开的次数。当最后一个进程关闭了文件时，允许将其从打开文件表中移除</li>
<li>文件磁盘位置：缓存数据访问信息</li>
<li>访问权限</li>
</ul>
</li>
</ul>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>目录好比一个集合，这个集合里有很多文件。集合用何种数据结构实现取决于文件系统的设计。可以采取传统的数组形式、、链表形式、也可采取哈希表形式或者更复杂的形式。</p>
<h4 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h4><ul>
<li>多个文件名关联同一个文件<ul>
<li>硬连接：多个文件指向一个文件<ul>
<li>删除一个文件将减少文件的引用计数，只有引用计数为0时才会删除一个文件</li>
</ul>
</li>
<li>软连接：以”快捷方式”指向其他文件<ul>
<li>删除真实文件后会留下的快捷方式将指向空</li>
</ul>
</li>
<li>通过存储真实文件的逻辑名称来实现</li>
</ul>
</li>
<li>别名机制潜在的循环<ul>
<li>对目录的别名：子目录是父目录的一个引用</li>
<li>这将导致查找文件时检索路径出现死循环</li>
</ul>
</li>
</ul>
<h4 id="文件系统类别"><a href="#文件系统类别" class="headerlink" title="文件系统类别"></a>文件系统类别</h4><ul>
<li>磁盘文件系统<ul>
<li>文件存储在数据存储设备上，如磁盘</li>
<li>例如：FAT、NTFS、ext3/4等</li>
</ul>
</li>
<li>数据库文件系统<ul>
<li>文件根据其特征是可寻址(辨识)的</li>
</ul>
</li>
<li>日志文件系统<ul>
<li>记录文件系统的修改/时间</li>
</ul>
</li>
<li>网络/分布式文件系统</li>
<li>特殊/虚拟文件系统</li>
</ul>
<h4 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h4><p>文件系统的种类繁多，如果让操作系统针对不同的文件系统编写应用程序，这显然是很复杂的。所有操作系统把复杂的东西抽象成简单的接口提供给用于，用户只需访问简单的接口，就可以应对不同的文件系统。</p>
<p>虚拟文件系统是一个内存中的概念，通过虚拟文件系统层，屏蔽了底层文件各种系统的差异，从而应用程序可以访问不同类型的文件系统。</p>
<ul>
<li><p>分层结构</p>
<ul>
<li>上层：虚拟(逻辑)文件系统</li>
<li>底层：特定文件系统模块</li>
</ul>
</li>
<li><p>目的</p>
<ul>
<li>对多有不同文件系统的抽象</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li>提供相同的文件和文件系统接口</li>
<li>管理所有文件和文件系统关联的数据结构</li>
<li>高效查询例程，遍历文件系统</li>
<li>与特定文件系统模块的交互</li>
</ul>
</li>
<li><p>基本结构</p>
<ul>
<li>卷控制块<ul>
<li>每个文件系统一个</li>
<li>文件系统详细信息</li>
<li>块、块大小、空余块、计数/指针等</li>
</ul>
</li>
<li>文件控制块<ul>
<li>每个文件一个</li>
<li>文件详细信息</li>
<li>权限、拥有者、大小等信息</li>
</ul>
</li>
<li>目录节点<ul>
<li>每个目录项一个(目录和文件)</li>
<li>将目录项数据结构及树形布局编码成树形数据结构</li>
<li>指向文件控制块、父节点、项目列表等</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="./static/dir_node_struct.png"/>


<h3 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h3><ul>
<li>将文件控制块读入内存</li>
<li>相关信息放入打开文件表</li>
<li>把打开文件表表项的索引返回给应用程序<ul>
<li>基于索引找到系统层面的打开文件表。由于可能多个程序打开同一个文件，所以都索引到系统文件表(只有一项)就ok</li>
<li>系统文件表由索引到目录/文件</li>
<li>如：访问文件，那么文件的信息会包含文件出现在什么地方(disk位置)，然后由偏移量指出，转换成disk扇区的编号</li>
<li>然后就可对扇区内容读写</li>
</ul>
</li>
</ul>
<h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h3><p>当要写入文件时，要对文件的数据空间进行管理(增减)。分配方式有如下几种</p>
<ul>
<li>连续分配<ul>
<li>文件头指定起始块和长度</li>
<li>位置/分配策略<ul>
<li>最先分配、最佳分配</li>
</ul>
</li>
<li>优势<ul>
<li>文件读取表现号</li>
<li>高效的顺序和随机访问</li>
</ul>
</li>
<li>劣势，同数组的劣势<ul>
<li>文件增长问题，可能需要调整后面一系列文件，或者把自己移动到别处，但这样又造成碎片问题</li>
<li>碎片</li>
</ul>
</li>
</ul>
</li>
<li>链式分配<ul>
<li>文件以数据块链表方式储存</li>
<li>文件头包含了到第一块和最后一块的指针</li>
<li>优点<ul>
<li>创建、增减很容易</li>
<li>没有碎片</li>
</ul>
</li>
<li>缺点<ul>
<li>不可能进行真正的随机访问</li>
<li>可靠性：如突然断电一个链被破坏…</li>
</ul>
</li>
</ul>
</li>
<li>索引分配<ul>
<li>为每个文件建立一个名为 <strong>索引数据块</strong> 的非数据数据块<ul>
<li>到文件数据块的指针列表</li>
</ul>
</li>
<li>文件头包含了索引数据块</li>
<li>优点<ul>
<li>创建、增减容易</li>
<li>没有碎片</li>
<li>支持直接访问</li>
</ul>
</li>
<li>缺点<ul>
<li>当文件很小时，存储开销比例大</li>
<li>如何处理大文件？一个索引块能够描述的数据块的个数是有限的<ul>
<li>分级处理，但是引入很多(索引)开销，和链被破坏的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h3><p>对空闲空间的管理。有如下几种管理方式</p>
<ul>
<li>用位图代表空闲数据块列表<ul>
<li><code>11110001110011</code>每个位就可表示扇区是否被分配<ul>
<li>如果i=0表明数据块i是空闲的</li>
</ul>
</li>
<li>使用简单，但是可能会是一个big vector<ul>
<li>如160G的disk需要5MB的bit表示，可以将这5M读取到内存</li>
<li>然而如果空闲空间中均匀分布，那么在找到0之前需要扫描n/r。n表示磁盘数据块的总数，r表示空闲块数目</li>
</ul>
</li>
<li>需要保护数据一致性：储存在内存的位图需要和硬盘的位图一致<ul>
<li>解决办法：先在硬盘位图上修改，再分配，在修改内存的位图。不会出现数据丢失的情况</li>
</ul>
</li>
</ul>
</li>
<li>链式列表</li>
<li>分组列表</li>
</ul>
<h3 id="多磁盘管理-RAID"><a href="#多磁盘管理-RAID" class="headerlink" title="多磁盘管理-RAID"></a>多磁盘管理-RAID</h3><p>通常磁盘通过分区来最大限度减小寻道时间</p>
<ul>
<li>分区：不同分区可以是不同的文件系统</li>
<li>卷：把多个磁盘变成一个卷来管理，这就可以把一个文件系统扩展到，多个磁盘</li>
</ul>
<p><strong>RAID：冗余磁盘阵列</strong> 。早期的磁盘容易坏，那么能不能用多个磁盘来储存一个文件系统的内容来保证可靠性呢？raid由此提出。后来raid又可以用来提升磁盘访问的吞吐量，提高访问速度。</p>
<ul>
<li>实现<ul>
<li>在操作系统内存：储存/卷管理。软raid</li>
<li>raid硬件控制器。硬raid</li>
</ul>
</li>
<li>raid0：提高吞吐量<ul>
<li>每个磁盘的独立的，可以并行的对数据进行访问，提升吞吐量</li>
</ul>
</li>
<li>raid1：提高可靠性<ul>
<li>每个磁盘的独立的，可以并行的操作</li>
</ul>
</li>
<li>raid4：即提高性能又增加可靠性<ul>
<li>如：使用一块Parity Disk的盘存储校验码，其他盘可以做并行操作。这样当一块盘的数据坏时可以反推出损坏的数据</li>
</ul>
</li>
<li>raid5：raid4中Parity Disk的读写非常频繁，开销大<ul>
<li>把校验块均匀的分配在不同的disk中，开销均匀、访问并行</li>
<li><img src="./static/raid5.png"/>


</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/10/universe/att_vs_Intel_assembly_language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/10/universe/att_vs_Intel_assembly_language/" itemprop="url">AT&T与Intel汇编语言的比较</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-10T00:00:00+08:00">
                2020-06-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>GCC采用的是AT&amp;T的汇编格式，也叫GAS(Gnu Assembler)格式;微软采用Intel的汇编格式</p>
<h2 id="寄存器命名"><a href="#寄存器命名" class="headerlink" title="寄存器命名"></a>寄存器命名</h2><ul>
<li>ATT的汇编格式中，寄存器名前要加上”%”前缀</li>
<li>Inter格式中不用</li>
</ul>
<h2 id="操作数的顺序"><a href="#操作数的顺序" class="headerlink" title="操作数的顺序"></a>操作数的顺序</h2><ul>
<li>ATT目标操作数在源操作数的右边</li>
<li>Intel目标操作数在源操作数的左边</li>
<li>正好相反</li>
</ul>
<table>
<thead>
<tr>
<th>AT&amp;T</th>
<th>Intel</th>
</tr>
</thead>
<tbody><tr>
<td>movl %eax, %abx</td>
<td>mov ebx,eax</td>
</tr>
</tbody></table>
<h2 id="常数-立即数的格式"><a href="#常数-立即数的格式" class="headerlink" title="常数/立即数的格式"></a>常数/立即数的格式</h2><ul>
<li>ATT的汇编格式中，立即数要加上”$”前缀</li>
<li>Inter格式中不用</li>
</ul>
<h2 id="操作符长度标识"><a href="#操作符长度标识" class="headerlink" title="操作符长度标识"></a>操作符长度标识</h2><ul>
<li>ATT汇编格式中操作符的后缀”b”, “w”, “l”分别表示操作数为字节(byte, 8位)、字(word, 16位)、长字(long, 32位)</li>
<li>Intel中操作数长度会根据寄存器长度而定，也可用”byte ptr”、”word ptr”等前缀来表示</li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><table>
<thead>
<tr>
<th>AT&amp;T</th>
<th>Intel</th>
</tr>
</thead>
<tbody><tr>
<td>imm32(basepointer,indexpointer,indexscale)</td>
<td>[base+indexpointer*indexscale+imm32]</td>
</tr>
</tbody></table>
<p>两种寻址效果都是：<code>imm32 + basepointer + indexpointer*indexscale</code></p>
<h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><ul>
<li><p>ATT汇编格式中，绝对跳转和调用指令(jump/call)的操作数前要加上”*“作为前缀</p>
<ul>
<li>远程跳转指令和远程子程序调用指令的操作码在ATT中为”ljump”和”lcall”</li>
<li>对应的返回指令为<code>lret</code></li>
</ul>
</li>
<li><p>Intel中不用</p>
<ul>
<li>远程跳转指令和远程子程序调用指令的操作码在Intel中为”jmp far”和”call far”</li>
<li>对应的返回指令为<code>ret</code></li>
</ul>
</li>
<li><p>ATT的汇编格式中，跳转指令有点特殊</p>
<ul>
<li>直接跳转，即跳转目标作为指令的一部分编码，如<code>ljump $a</code></li>
<li>间接跳转，即目标从寄存器或储存器位置中读出的。写法在”*“后面跟一个操作数指示符<ul>
<li><code>ljump *%eax</code>用寄存器%eax中的值作为目标</li>
<li><code>ljump *(%eax)</code>用寄存器%eax中的值作为读入地址，从存储器中读出跳转目标</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/Major/circuit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/07/Major/circuit/" itemprop="url">电路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-07T00:00:00+08:00">
                2020-06-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="半导体的工作原理"><a href="#半导体的工作原理" class="headerlink" title="半导体的工作原理"></a>半导体的工作原理</h2><p>半导体的材料一般是电子不多不少(不易获得也不易失去)的，如:硅(4最外层4电子)</p>
<p>电子多，说明核带正电多，对电子吸引力强; 电子少，说明核带正电少，对电子吸引力弱。</p>
<h3 id="晶体二极管"><a href="#晶体二极管" class="headerlink" title="晶体二极管"></a>晶体二极管</h3><p>纯硅电子不易得也不易失，我们称之为 <strong>本征半导体</strong> 。如果我们在硅中加入一点磷(最外层5电子)，则将不是在最外出4电子的基础上多了一个电子。这时这个电子将相对”自由”。这个整体带的电子比稳定的4电子多，我们就叫它N型半导体(Negetive)。</p>
<p>如果我们在本征半导体参入堋(最外层3个电子)，整体将变得渴望1个电子，我们将这个空的地方(为到达4电子)称为空穴。这些空穴有渴望电子的能力。相对4电子结构，空穴是Positive的，因此称为P型半导体。</p>
<p>采用特殊的技术，把P型半导体和N型半导体(P、N整体都是中性，别被PN误导)拼接在一起。那么由于P型半导体的空穴浓度高，N型半导体的空穴浓度低，空穴就会从P扩散到N;同理N型半导体的电子扩散到P型半导体，就像液体中的扩散一样。但扩散不会一直发生，当N中的空穴变多，变得带正电，P中的电子变多，变得带负电，形成电场。</p>
<p>随着电场的形成，电场将试图将P的电子拉到N，随着P的电子减少，电场减弱，扩散又发生，最后扩散和电场达到动态平衡。</p>
<ul>
<li>如果我们向N区通正电，新增的电场与内部的电场方向一致，电场将会变强。虽然仍会处于动态平衡，但是电场抑制了粒子移动，从而阻断电流。</li>
<li>如果我们向P区通整点，N区通负电，将压缩内电场，电子的束缚将变小从而导通电流</li>
<li>于是晶体二极管就诞生了</li>
</ul>
<h3 id="晶体三极管"><a href="#晶体三极管" class="headerlink" title="晶体三极管"></a>晶体三极管</h3><p>晶体三极管结构如下：</p>
<table>
<thead>
<tr>
<th>外</th>
<th>N</th>
<th>P</th>
<th>N</th>
<th>内</th>
</tr>
</thead>
<tbody><tr>
<td>通电电极</td>
<td>+</td>
<td>+</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>位置</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<p>每个PN接触面会形成PN节，一般0.7V的电压会导通PN节。</p>
<p>如果1号位和2号位电压大于0.7V，就通电了。需要注意的是，设计时，1号位故意参杂很多5电子元素，使得电子浓度很高;而2号位的半导体很薄，很难一次消耗掉这些涌入的电子;当2号涌入了很多电子又无法消耗，那么就打破了2号和3号的动态平衡。而且3号设计得很大电子浓度低，2号扩散过来的电子很快会被3号收集。又因为3号通的正电，电子得到了一个快速的泄洪通道，迅速通过电源正极。</p>
<p>这样一来，我们可以认为2号和3号通电了。又因为2号电子来自1号，所以1号也和3号通电了。</p>
<p>2号极小的信号改变就会导致1号电子涌入的巨大变化，从而引起1号与3号之间电流的巨大变化。</p>
<ul>
<li>1号连接负极，称为发射极</li>
<li>2号相当于阀门，操作这原始信号，称为基极</li>
<li>3号收集电子，称为集电极</li>
</ul>
<h3 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管"></a>场效应管</h3><p>将两个N型半导体浸如一个大的P型半导体中，两个N型半导体分别接入正极和负极，P型半导体接入正极，但与正极间隔这一个电容。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>N</th>
<th>P</th>
<th>N</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>通电电极</td>
<td>P</td>
<td>-</td>
<td>+电容</td>
<td>+</td>
<td>P</td>
</tr>
<tr>
<td>位置</td>
<td>P</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>P</td>
</tr>
<tr>
<td></td>
<td>P</td>
<td>P</td>
<td>P</td>
<td>P</td>
<td>P</td>
</tr>
</tbody></table>
<ul>
<li>1号由电源不断提供电子</li>
<li>2号不断吸引电子，但不会快速消耗电子</li>
<li>3号快速消耗电子</li>
</ul>
<p>由于2号电子处聚集了大量电子，3号消耗了很多电子，于是P型半导体由于电子聚集的位置与3号N型半导体由于电子消耗，半导体的类型发生了改变。即2号与3号之间，2号成了N型，3号成了P型，电子将扩散到3号并被快速消耗。又由于1号源源不断提供电子，不断涌向2号。于是1号和3号在2号的控制下形成了通电回路。</p>
<ul>
<li>1号提供电子，称为源极</li>
<li>2号像栅栏一样控制电路导通，称为栅极<ul>
<li>栅极的正负控制这电路的通阻，如果用01表示同断，那么计算机科学就开始了</li>
</ul>
</li>
<li>3号称为漏极</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/universe/Emacs_in_action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/29/universe/Emacs_in_action/" itemprop="url">emacs快速入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-29T00:00:00+08:00">
                2020-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Emacs细节"><a href="#Emacs细节" class="headerlink" title="Emacs细节"></a>Emacs细节</h2><ul>
<li>major mode和minor mode<ul>
<li>打开一个文件时会有默认的mode激活，这个默认的mode就是major mode</li>
<li>minor mode在配置文件中，状态栏不会显示，<code>c-h m</code>显示打开的minor mode</li>
</ul>
</li>
<li>org mode标签TODO/DONE<ul>
<li><code>c-t/c-s</code></li>
</ul>
</li>
</ul>
<h2 id="Emacs基本操作"><a href="#Emacs基本操作" class="headerlink" title="Emacs基本操作"></a>Emacs基本操作</h2><ul>
<li><p>M for meta, Alt or Command(MAC)</p>
</li>
<li><p>S for shift</p>
</li>
<li><p>C for control</p>
</li>
<li><p>s for super</p>
</li>
<li><p>Move</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>c-f</td>
<td>forward</td>
</tr>
<tr>
<td>c-b</td>
<td>backward</td>
</tr>
<tr>
<td>c-p</td>
<td>previous</td>
</tr>
<tr>
<td>c-n</td>
<td>next</td>
</tr>
<tr>
<td>c-a</td>
<td>ahead</td>
</tr>
<tr>
<td>c-e</td>
<td>end</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
<li><p>Action</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>c-w</td>
<td>cut</td>
</tr>
<tr>
<td>m-w</td>
<td>copy</td>
</tr>
<tr>
<td>c-y</td>
<td>yank(paste)</td>
</tr>
<tr>
<td>m-&lt;</td>
<td>begin of file</td>
</tr>
<tr>
<td>m-&gt;</td>
<td>end of file</td>
</tr>
<tr>
<td>c-k</td>
<td>del to end of line(kill)</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
<li><p>Edit</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>C-g</td>
<td>中断所有操作</td>
</tr>
<tr>
<td>C-x C-f</td>
<td>打开文件</td>
</tr>
<tr>
<td>C-x C-s</td>
<td>save</td>
</tr>
<tr>
<td>C-h key/var/func</td>
<td>help for key/var/func</td>
</tr>
<tr>
<td>C-x C-e</td>
<td>执行表达式，根据括号范围决定运行的指令</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
<li><p>Search</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>action</th>
</tr>
</thead>
<tbody><tr>
<td>c-s</td>
<td>search below</td>
</tr>
<tr>
<td>c-r</td>
<td>search above</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="Elisp"><a href="#Elisp" class="headerlink" title="Elisp"></a>Elisp</h2><p>括号括起来是表达式，表达式第一个参数是函数，后面是参数。如</p>
<ul>
<li><code>(+ 2 2)</code>，+的函数，结果是2+2</li>
</ul>
<p>括号也起到了代码块的作用</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>(setq var [value])</td>
<td>定义变量（赋值）</td>
</tr>
<tr>
<td>(message var)</td>
<td>格式化输出，同C</td>
</tr>
<tr>
<td>(defun func)</td>
<td>定义函数</td>
</tr>
<tr>
<td>(interactive)</td>
<td>声明函数是交互式的函数，<M-x>可以找到这个函数</td>
</tr>
<tr>
<td>(global-set-ket (kbd “<key>“) ‘func)</td>
<td>定义快捷键</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
<tr>
<td>&lt;++&gt;</td>
<td>&lt;++&gt;</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/universe/hacker_in_action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/21/universe/hacker_in_action/" itemprop="url">黑客攻防学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-21T00:00:00+08:00">
                2020-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前置知识：汇编语言</p>
<h1 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h1><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>缓冲区是一片有限的、连续的内存区域。在C语言中最常见的缓冲区是数组。</p>
<p>因为在C和C++语言中没有考虑检查缓冲区的内在边界，所以使栈溢出成为可能。当输入的数据足够大时，将会溢出缓冲区的范围，从而改写从而改写其他缓存区域。</p>
<h3 id="函数与栈"><a href="#函数与栈" class="headerlink" title="函数与栈"></a>函数与栈</h3><p>调用函数的整个过程如下</p>
<ul>
<li><ol>
<li>把函数的参数压入栈</li>
</ol>
</li>
<li><ol start="2">
<li>把函数的返回地址压入栈<ul>
<li>主程序调用子程序，子程序结束后继续上次的位置执行主程序</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>调用函数</li>
</ol>
</li>
</ul>
<p>为了使函数可以引用栈上的数据，必须改变栈底指针EBP的值，把EBP的当前值压入栈，把当前的栈顶ESP复制到EBP，函数接受后再恢复。这样我们就可以方便地引用栈地址了。</p>
<p>接着编译器计算函数的局部变量所需的地址空间和栈上的保留空间，然后从ESP减去变量的大小，为程序保留必要的空间，最后把函数的局部变量压入栈(这我们举例：数组)。结构如下：</p>
<table>
<thead>
<tr>
<th>低内存地址，栈顶</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
</tr>
<tr>
<td>EBP</td>
</tr>
<tr>
<td>RET</td>
</tr>
<tr>
<td>参数</td>
</tr>
<tr>
<td>高内存地址，栈底</td>
</tr>
</tbody></table>
<h3 id="栈上的缓冲区溢出"><a href="#栈上的缓冲区溢出" class="headerlink" title="栈上的缓冲区溢出"></a>栈上的缓冲区溢出</h3><p>由上述结构可见，如果数组很大，将会溢出，然后改写其他缓存区域。</p>
<ul>
<li>控制EIP<ul>
<li>CPU执行什么指令由CS:IP的指向决定</li>
<li>我们只要精心设计溢出的数据，这些地址将写入缓冲器并改写保留在缓冲区的EBP和RET。当系统从栈中取出RET的值并放入EIP时，这个地址指向的指令将被执行。</li>
</ul>
</li>
</ul>
<h3 id="利用漏洞获得root权限"><a href="#利用漏洞获得root权限" class="headerlink" title="利用漏洞获得root权限"></a>利用漏洞获得root权限</h3><p>我们可以攻击以root权限运行的进程，通过溢出强制它执行shell，这个shell将继承root权限。然而缓冲区只认得机器指令(opcode)。为了把opcode插入缓存区，必须吧派生的shell的C代码编译成汇编指令，然后从可读的汇编指令中提取opcode。这些被称为shellcode或opcode的代码可以注入缓冲区，并可执行。</p>
<h4 id="地址问题"><a href="#地址问题" class="headerlink" title="地址问题"></a>地址问题</h4><p>当试图执行用户提交的shellcode时，所面临的问题是找出shellcode的起始地址。(想办法使EIP指向这个地址)</p>
<p>先介绍一种使用最广的方法：猜。每个程序的栈都以同样的地址开始。(现在大多数操作系统故意变化栈地址，从而使这类的攻击变得困难)知道这个地址就可以猜测shellcode的起始地址和RET的地址。</p>
<ul>
<li>首先要知道ESP的地址，那么根据这个地址来猜测当前地址和shellcode之间的偏移距离。从而的到shellcode的起始地址</li>
<li>通过尝试输入过长数据造成溢出，从造成故障的长度来猜测RET地址</li>
<li>最后把RET地址改为shellcode的起始地址以达到执行shellcode的目的</li>
</ul>
<p><strong>例1</strong> ：简单试炼，破解以下程序，假设我们不知道被攻击程序的内部结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// victim.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="built_in">array</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果每个程序的栈都是以同样的地址开始，则固定的程序RET地址不会改变，我们可以通过溢出找出RET地址<ul>
<li><code>$ ./victim.c $(printf &quot;%0524&quot; 0)</code>利用bash快速尝试输入多个0(长数据)</li>
</ul>
</li>
<li>假设我们的shellcode有40B，上一步在524个数据时溢出，那么我们可以将上一步的长数据改成<code>shellcode+(524-len(shellcode))个0+shellcode起始地址</code><ul>
<li>这里还没获得shellcode起始地址，我们先用别的地址测试填充0的个数是否正确</li>
</ul>
</li>
</ul>
<p>building…</p>
<h4 id="NOP法"><a href="#NOP法" class="headerlink" title="NOP法"></a>NOP法</h4><p>一个个猜太过麻烦，可以选用NOP法来增加潜在的偏移量的数量。思路就是创建一大段不运行的指令区，放在shellcode前面，当执行完NOP之后，就会执行shellcode。这样就不用精确地猜到偏移量了。</p>
<h3 id="战胜不可执行栈"><a href="#战胜不可执行栈" class="headerlink" title="战胜不可执行栈"></a>战胜不可执行栈</h3><p>前面所讲的漏洞利用程序能工作，是因为可以在栈上执行指令。许多操作系统不允许在栈上执行代码。当遇到不可执行栈的时候，可以用”返回libc”方法。</p>
<p>栈溢出原理上其实是利用了EIP指针，那么如果我们可以完全EIP指针，那么就可以把任意想执行的代码放入EIP。返回libc是把控制权交给特定的动态库函数。动态库函数不在栈上，所以我们就可以绕开不可执行栈的限制。</p>
<p>为了攻击成功，需要仔细挑选动态库函数。理论上，它必须符合以下两个条件：</p>
<ul>
<li>它必须的常见的动态库函数，在绝大多数程序中出现，才便于利用</li>
<li>函数库里的函数应该给予我们很大的灵活性，以便我们能派生shell或做其他事</li>
</ul>
<p>libc就是满足条件的一个库函数。我们只要把执行流程指向想用的库函数的地址，它将被执行。</p>
<p>以下以派生shell讨论。最好用的libc函数是system()。system()接受一个参数，然后用/bin/sh/执行这个参数。根据经验主程序执行一个函数(设为func)时，参数入栈的顺序和它在代码里的顺序相反，根据这点，我们需要进行以下工作：</p>
<ul>
<li>确定system()地址<ul>
<li>主程序执行一个函数func时，call func，会把返回地址RET压入栈</li>
</ul>
</li>
<li>确定/bin/sh地址(参数地址)<ul>
<li>第一个参数位于RET之后</li>
</ul>
</li>
<li>找出exit()地址，以便干净地退出被攻击的程序</li>
</ul>
<p>用memfetch工具可以找到/bin/sh的地址，memfetch的功能是把指定进程的内存数据全部转存到一个二进制文件中，我们可以在这个文件里找/bin/sh的地址</p>
<p>破解过程如下：</p>
<ul>
<li><ol>
<li>用垃圾数据填满缓冲区和返回地址之间的空间</li>
</ol>
</li>
<li><ol start="2">
<li>用system()的地址改写返回地址</li>
</ol>
</li>
<li><ol start="3">
<li>在system()后加上exit()的地址</li>
</ol>
</li>
<li><ol start="4">
<li>再加上/bin/sh的地址</li>
</ol>
</li>
</ul>
<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>shellcode是一组可注入(机械码)的程序，可以在被攻击的程序里运行。因为shellcode要直接操作寄存器和程序的函数，所以通常用汇编语言编写并翻译为十六进制操作码。之所以叫shellcode是因为通常用这种操作来派生root权限的shell。</p>
<h3 id="理解系统调用"><a href="#理解系统调用" class="headerlink" title="理解系统调用"></a>理解系统调用</h3><p>我们想让目标程序不同于设计者预期的方式运行，而操纵程序的方法之一是强制它产生系统调用(中断)。可以通过系统调用访问特定的操作系统的函数，如接受输入、处理输出、退出进程、执行二进制文件等。</p>
<p>通过系统调用可以直接访问系统内核，即可以访问读写文件之类的低级函数。系统调用也是受保护的内核模式与用户模式之间的接口。受保护的内核模式会阻止用户的应用程序干涉或危及操作系统。当用户模式下的程序企图访问内核的内存空间时，系统将产生异常。但是，某些程序在正常运行时，需要请求一些系统级的服务，这时系统调用就作为正常用户模式和内核模式之间的接口，在保证安全的情况下尽量相应这些请求。</p>
<p>在Linux里有两种方法来执行系统调用：</p>
<ul>
<li>间接方法：C库函数(libc)</li>
<li>直接方法：汇编指令(把适当的参数加载到寄存器，然后调用中断)执行系统调用</li>
</ul>
<p>在Linux里，程序通过<code>int 0x80</code>软中断来执行系统调用。当程序在用户模式下执行<code>int 0x80</code>时，CPU切换到内核模式并执行相应的系统调用。系统调用的过程如下：</p>
<ul>
<li><ol>
<li>把系统调用编号载入EAX，通过载入编号来调用对应系统函数</li>
</ol>
</li>
<li><ol start="2">
<li>把系统调用的参数压入其它寄存器</li>
</ol>
</li>
<li><ol start="3">
<li>执行<code>int 0x80</code>指令</li>
</ol>
</li>
<li><ol start="4">
<li>CPU切换到内核模式</li>
</ol>
</li>
<li><ol start="5">
<li>执行系统函数</li>
</ol>
</li>
</ul>
<p>思考下列程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -static -o exit exit.c</span></span><br></pre></td></tr></table></figure>

<p>反汇编生成的二进制文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gdb exit</span><br><span class="line">(gdb) disas _exit</span><br><span class="line">address &lt;line&gt;: mov 0x4(%esp,1),%ebx</span><br><span class="line">address &lt;line&gt;: mov $Oxfc,%eax          ;对应的系统调用编号被放入%EAX中</span><br><span class="line">address &lt;line&gt;: int $0x80               ;通过int 0x80指令得知发生了系统调用</span><br><span class="line">address &lt;line&gt;: mov $0x1,%eax           ;对应的系统调用编号被放入%EAX中</span><br><span class="line">address &lt;line&gt;: int $0x80</span><br><span class="line">address &lt;line&gt;: hlt</span><br><span class="line">address &lt;line&gt;: nop</span><br></pre></td></tr></table></figure>

<p>exit()对应的系统调用编号是1，exit_group()对应的系统调用编号是252。在反汇编生成的代码里还有一条指令，它把系统调用的参数加载到EBX。这个参数是0，是在系统调用之前入栈的<code>mov 0x4(%esp,1),%ebx</code></p>
<p><code>int 0x80</code>指令把CPU切换到内核模式，并且执行系统调用</p>
<h3 id="为exit-系统调用写shellcode"><a href="#为exit-系统调用写shellcode" class="headerlink" title="为exit()系统调用写shellcode"></a>为exit()系统调用写shellcode</h3><blockquote>
<p>较小的shellcode可以注入更多的缓冲区，可以用来攻击更多的程序，所以要使shellcode尽量保持简单、紧凑。当攻击问题程序的时候，不仅要把shellcode复制到缓冲区，如果碰到n字节长的缓冲区，不仅要把整个shellcode复制到它里面，还要加上调用shellcode的指令，因此shellcode的长度必须小于n。基于这个原因，shellcode应尽量小。</p>
</blockquote>
<p>因为实际环境中，shellcode没有其他指令为它设置参数，所以我们要精心设计。在上面exit()例子里，通过把0放入EBX可以达到设置的目的。所以我们的shellcode应该完成以下任务：</p>
<ul>
<li><ol>
<li>把0存到EBX<ul>
<li>参数</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>把1存到EAX<ul>
<li>系统调用编号</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>执行<code>int 0x80</code>指令来产生系统调用</li>
</ol>
</li>
</ul>
<p>先用汇编指令实现这3步，的到ELF格式的二进制文件，然后从这个二进制文件中提取操作码。</p>
<ul>
<li>生成目标文件</li>
<li>链接目标文件</li>
<li>从生成的文件提取操作码</li>
</ul>
<h3 id="可注入的shellcode"><a href="#可注入的shellcode" class="headerlink" title="可注入的shellcode"></a>可注入的shellcode</h3><p>攻击时，最有可能用来保存shellcode的内存区域是为了保存用户输入而分配的缓冲区，甚至可以更进一步将，这个缓冲区就是一个数组。所以如果shellcode中有空值(0x00)的存在，当把shellcode复制到缓冲区(字符数组)的时候会出现异常，因为数组里空值是用来终止字符串的。所以我们要想办法把空值去掉，或把有空值的操作码转换成非空值的操作码。下面介绍一种方法：</p>
<ul>
<li>直接用其他具有相同功能的指令代替这些产生空值的指令</li>
</ul>
<p>如果直译，shellcode使用如下汇编指令和对应的操作码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,0       ;\xbb\x00\x00\x00\x00</span><br><span class="line">mov eax,1       ;\xb8\x00\x00\x00\x00</span><br><span class="line">int 0x80        ;\xcd\x80</span><br></pre></td></tr></table></figure>

<p>头两条是产生空值的罪魁祸首，我们可以用如下操作解决：</p>
<ul>
<li>第一条指令，我们可以用<code>xor</code>指令在不涉及空值的情况下给ebx赋值<ul>
<li><code>xor ebx ebx</code>，效果：ebx = ebx XOR ebx = 0000</li>
</ul>
</li>
<li>第二条指令汇编指令看似没有0的参与，为什么会出现空值呢？<ul>
<li>因为：这条指令使用了4B寄存器(EAX)，而我们复制了1B(1)到寄存器，默认情况下系统会自动用控制填充剩下部分</li>
<li>4B的EAX可以划分为2个2B(AX)和4个1B(AL、AH)，所以我们直接使用1B的AL就可以避免</li>
<li><code>mov al,1</code></li>
</ul>
</li>
</ul>
<h3 id="派生shell"><a href="#派生shell" class="headerlink" title="派生shell"></a>派生shell</h3><p>首先写派生shell的C程序。派生shell最方便、最快捷的方法是创建新进程。在Linux里有两种方法创建新进程：</p>
<ul>
<li><ol>
<li>通过现有进程创建它，并用它代替现有活动进程</li>
</ol>
</li>
<li><ol start="2">
<li>利用程序生成自己的副本，并在它的位置运行这个进程</li>
</ol>
</li>
</ul>
<p>下面是一个简单C程序的execve调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *cmd[<span class="number">2</span>];</span><br><span class="line">    cmd[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    cmd[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(cmd[<span class="number">0</span>], cmd, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在把它转换成原始十六进制指令，就像exit()一样。想观察execve的文档，提供的信息很有价值：</p>
<ul>
<li><code>int execve(const char* filename, char* const argv[], char* const envp[])</code></li>
<li>execve()执行filename(指针)指向的程序</li>
<li>argv是字符串数组，用来传递参数，envp是字符串数组，用来传递环境变量。argv和envp都以空指针结束</li>
</ul>
<p>执行execve()系统调用4个寄存器：1个用来保存系统调用值;3个用来保存系统调用参数。</p>
<p>在shellcode里不可以使用硬编码地址。我们希望shellcode容易移植，因此我们使用相对地址。下面介绍一种相对地址的实现方法</p>
<p>在shellcode里使用相对地址需要一些技巧。我们可以把shellcode在内存中的开始地址或shellcode的重要元素复制到寄存器，然后根据寄存器里的地址设计每条指令：</p>
<ul>
<li>shellcode以一条跳转指令开始，跳过shellcode，跳到调用指令</li>
<li>执行调用指令时，紧跟在调用指令之后的地址将被压入栈<ul>
<li>这里把想作为相对地址的基地址直接放在了调用指令之后</li>
<li>需要时可以从栈中找到地址</li>
</ul>
</li>
<li>当调用指令后，我们的的基地址将自动保存在栈上，而我们不必提前知道这个地址</li>
<li>之后，调用指令调用shellcode，执行<code>pop esi</code>把栈上的基地址送入ESI。至此就可以根据ESI的偏移量来引用shellcode里面的代码</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    jmp short GoToCall</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop esi     ;把&#39;&#x2F;bin&#x2F;sh&#39;送入esi，使用了相对地址</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">GoToCall:</span><br><span class="line">    call shellcode</span><br><span class="line">    db &#39;&#x2F;bin&#x2F;sh&#39;</span><br></pre></td></tr></table></figure>

<p>下面用真正的汇编指令替代伪代码。在编写过程中，还需要在字符串尾部保留一些占位符(这里是9B)，如下：</p>
<ul>
<li><code>/bin/shJAAAAKKKK</code></li>
</ul>
<p>这些占位符有什么用呢？我们将把系统调用所需的3个参数中的2个(将被载入ECX、EDX)保存在这些占位符里。因为字符串的第一个字节的地址保存在ESI里，所以对于替换和把这些值复制到寄存器来说，很容易就能确定它们所在内存中的位置。另外，可以通过”复制到占位符”方法，用空值有效终止这些字符串。步骤如下：</p>
<ul>
<li><ol>
<li>用xor EAX EAX的结果(空值)填充EAX</li>
</ol>
</li>
<li><ol start="2">
<li>把AL复制到紧挨着/bin/sh的字符位置(J)来终止/bin/sh字符串。<ul>
<li>因为EAX是空值，所以AL也是空值</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>得到保存在ESI里的字符串开头地址，把它复制到EBX</li>
</ol>
</li>
<li><ol start="4">
<li>把EBX里的值(字符串开头的地址)复制到AAAA占位符<ul>
<li>这是execve系统调用要求的、被执行文件的参数指针</li>
</ul>
</li>
</ol>
</li>
<li><ol start="5">
<li>用正确的偏移量吧保存在EAX中的空值复制到KKKK占位符</li>
</ol>
</li>
<li><ol start="6">
<li>把字符串的地址载入EBX</li>
</ol>
</li>
<li><ol start="7">
<li>把保存在AAAA占位符里的地址(一个指向字符串的指针)载入ECX</li>
</ol>
</li>
<li><ol start="8">
<li>把保存在KKKK占位符里的地址(一个指向空值的指针)载入EDX</li>
</ol>
</li>
<li><ol start="9">
<li>执行<code>int 0x80</code></li>
</ol>
</li>
</ul>
<p>得到汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    jmp short GoToCall</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop esi</span><br><span class="line"></span><br><span class="line">    xor eax, eax                ; 1</span><br><span class="line">    </span><br><span class="line">    mov byte [esi+7], al        ; 2</span><br><span class="line"></span><br><span class="line">    lea ebx, [esi]              ; 3</span><br><span class="line">    mov long [esi+8], ebx       ; 4</span><br><span class="line">    mov long [esi+12], eax      ; 5</span><br><span class="line">    mov byte al, 0x0b</span><br><span class="line">    mov ebx, esi</span><br><span class="line">    lea ecx, [esi + 8]</span><br><span class="line">    lea edx, [esi + 12]</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">GoToCall:</span><br><span class="line">    call shellcode</span><br><span class="line">    db &#39;&#x2F;bin&#x2F;shJAAAAKKKK&#39;</span><br></pre></td></tr></table></figure>

<p>编译并反汇编的到操作码</p>
<h2 id="格式化串漏洞"><a href="#格式化串漏洞" class="headerlink" title="格式化串漏洞"></a>格式化串漏洞</h2><p>何为格式化串：</p>
<ul>
<li><code>printf(&quot;%d %x&quot;, a, b);</code></li>
<li>printf是一个参数保存在栈上的函数，即a、b从栈中取出</li>
</ul>
<p>出现格式化串漏洞最常见的原因是，在C语言里没有处理带有可变参数的函数。</p>
<h3 id="什么是格式化串"><a href="#什么是格式化串" class="headerlink" title="什么是格式化串"></a>什么是格式化串</h3><p>当 <strong>printf系列函数</strong> 的格式化串里包含用户提交的数据时(如用户输入)，就可能出现格式化串漏洞。</p>
<p>攻击者可以提交很多格式符(而不给出对应的变量)，这样的话，栈上就没有和格式符相对应的参数，从而导致信息泄漏和执行任意代码。</p>
<p>如果我们不给格式符提供变量，将会出现奇怪的事情。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmt.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用如下形式执行<ul>
<li><code>./fmt &quot;%x %x %x %x&quot;</code></li>
</ul>
</li>
<li>就相当于用如下形式调用printf<ul>
<li><code>printf(&quot;%x %x %x %x&quot;);</code></li>
</ul>
</li>
<li>这个语句会透露出一些重要的信息：我们提供了格式符，但没提供对应的参数。printf也没有报错，而是输出一下内容：<ul>
<li><code>4015c98c 4001526c bffff944 bffff8e8</code></li>
</ul>
</li>
<li>攻击者可以利用它来获取栈上的数据</li>
</ul>
<p>有许多格式符，下面介绍一个：</p>
<ul>
<li>n，这个参数被视为指向整数指针(或整数变量)，在这个参数之前输出的字符的数量被保存到这个参数指针的地址里<ul>
<li><code>./fmt &quot;AAAAAAAAAA%n%n%n%n%n%n%n%n&quot;</code></li>
<li>%n格式符把它的参数作为内存地址，把前面输出的字符的数量写到这个地址</li>
<li>这意味着我们有机会改写某个内存地址的数据，从而控制程序的执行</li>
</ul>
</li>
</ul>
<p>利用%n格式符把控制的数据写入选择的地址。如果满足一下条件，就可以利用格式化串漏洞执行任意代码：</p>
<ul>
<li>我们能够控制参数，并可以把输出的字符的数量写入内存的任意区域</li>
<li>宽度格式符允许我们用任意长度填充输出。如：<code>&quot;%23d&quot;</code>。因此可以用选择的值改写单个字节</li>
<li>通常来说，我们可以猜测函数指针的地址，因此我们可以促成系统把提交的字符串当作代码执行</li>
</ul>
<h3 id="Building"><a href="#Building" class="headerlink" title="Building"></a>Building</h3><h3 id="格式化串技术概述"><a href="#格式化串技术概述" class="headerlink" title="格式化串技术概述"></a>格式化串技术概述</h3><ul>
<li><p>如果格式化串在栈上，当增加字符串的格式符时，可以为格式符提供参数</p>
<ul>
<li>一旦可以指定参数：</li>
<li>可以用%s从目标进程读取内存数据</li>
<li>可以用%n把输出的字符的数量写入任意地址</li>
<li>可以用宽度修饰符修改输出的字符的数量</li>
<li>可以用%hn修饰符每次写入16位数值</li>
</ul>
</li>
<li><p>直接参数访问允许多次重用同一格式化串里的栈参数，也允许直接用这些我们感兴趣的参数。直接参数访问使用$修饰符，如：</p>
<ul>
<li><code>%272$x</code>，将显示栈上第272个参数</li>
</ul>
</li>
<li><p>利用格式化串漏洞、写内存的技术，可以：</p>
<ul>
<li>改写保存的返回地址</li>
<li>改写其他特殊程序的函数指针</li>
<li>改写指向异常处理程序的指针</li>
<li>改写GOT(全局偏移表)条目</li>
<li>等等</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Web篇"><a href="#Web篇" class="headerlink" title="Web篇"></a>Web篇</h1><h2 id="解析应用程序"><a href="#解析应用程序" class="headerlink" title="解析应用程序"></a>解析应用程序</h2><ul>
<li>确定后端使用的技术<ul>
<li><ol>
<li>提取版本HTTP消息头中的版本信息，但后端程序员也可以伪造</li>
</ol>
</li>
<li><ol start="2">
<li>文件扩展名<ul>
<li>许多Web服务器将特殊的文件扩展名映射到特定的服务器组件中，不同组建处理错误的方式不同</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>目录名<ul>
<li>一些子目录名常常表示应用程序使用了相关技术</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>会话令牌<ul>
<li>许多Web服务器和Web应用程序平台默认生成的会话令牌名称会揭示其使用的技术</li>
</ul>
</li>
</ol>
</li>
<li>等等</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/18/universe/c/algorithm_tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/18/universe/c/algorithm_tips/" itemprop="url">算法技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-18T00:00:00+08:00">
                2020-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li>从结束条件开始分析</li>
</ul>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针的选择会出现在很多情况，如：快速排序算法m值的选择、列出排列组合的所有情况。</p>
<ul>
<li>一般先对数组排序，然后从边界开始就能简单的定一议二</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="判断二分图"><a href="#判断二分图" class="headerlink" title="判断二分图"></a>判断二分图</h3><p>染色，然后使用bfs或dfs遍历所有节点，不应该存在相邻节点颜色一样。</p>
<h2 id="复杂条件"><a href="#复杂条件" class="headerlink" title="复杂条件"></a>复杂条件</h2><h3 id="问题允许存在变量"><a href="#问题允许存在变量" class="headerlink" title="问题允许存在变量"></a>问题允许存在变量</h3><p>如判断一个字符串是否回文，而且允许删除一个字符。那么对于这个问题的变量就是如果要删除，是删除左边还是右边。但是主要的判断依旧是相同的<code>str[i++]==str[j--]</code>。</p>
<p>所以可以分离主要的判断程序，在主程序中使用<code>||</code>运算符来解决变量引起的讨论。如：<code>return func(删左边)||func(删右边)</code></p>
<h2 id="删除链表上第n个结点"><a href="#删除链表上第n个结点" class="headerlink" title="删除链表上第n个结点"></a>删除链表上第n个结点</h2><ul>
<li>快慢指针，当快指针的next是空的时候，慢指针刚好指到倒数第n个节点</li>
</ul>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>通常，涉及连续子数组问题的时候，我们使用前缀和来解决。</p>
<p>我们令$P[i] = A[0] + A[1] + … + A[i]$。那么每个连续子数组的和sum(i,j)就可以写成$P[j] - P[i-1]（其中 0 &lt; i &lt; j;0 &lt; i &lt; j）$的形式。</p>
<h3 id="任意范围连续元素的和"><a href="#任意范围连续元素的和" class="headerlink" title="任意范围连续元素的和"></a>任意范围连续元素的和</h3><p>两个前缀和相减就能得到任意范围连续元素的和，如前5个元素的前缀和间前3个元素的前缀和就得到4~5的和。</p>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>使用哨兵能简化我们的讨论，去掉不必要的分类讨论。如在链表中使用虚拟的头和尾，省去了分类讨论。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li>遍历一个 <strong>完整</strong> 的循环会节省很多讨论，何为完整，类似与判断波的一个完整周期</li>
</ul>
<h2 id="单向栈"><a href="#单向栈" class="headerlink" title="单向栈"></a>单向栈</h2><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><ul>
<li>计算一个数a的n次方<ul>
<li>当n是偶数，我们先计算a的n/2次方，然后平方</li>
<li>当n是奇数，我们先计算a的n-1次方，然后乘n</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/Major/assembly_language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/Major/assembly_language/" itemprop="url">汇编语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-09T00:00:00+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>地址总线<ul>
<li>CPU通过地址总线来指定存储单元，N根导线可以传送N位二进制数，可选址$2^N$个内存单元，可表示最大的数为$2^N - 1$。</li>
</ul>
</li>
<li>数据总线<ul>
<li>CPU与内存或其他器件之间的数据传输是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传输速度。如8根数据总线一次可以传送8位(一个字节)二进制数据。</li>
</ul>
</li>
<li>控制总线<ul>
<li>CPU对外部器件的控制是通过控制总线来进行的。有多少跟控制总线就意味着CPU提供了对外部器件的多少种控制。</li>
</ul>
</li>
<li>主板<ul>
<li>主板上有核心器件和一些主要部件，这些部件通过总线(地址总线、数据总线、控制总线)相连</li>
</ul>
</li>
<li>接口卡<ul>
<li>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作</li>
</ul>
</li>
<li>各类储存器芯片<ul>
<li>从读写属性上分为两类：随机储存器(RAM)和只读储存器(ROM)<ul>
<li>随机储存器可读可写，关机后储存的内容丢失</li>
<li>只读储存器只读不能写入，关机后内容不会丢失</li>
</ul>
</li>
</ul>
</li>
<li>地址空间<ul>
<li>内存地址空间的大小受CPU地址总线宽度的限制，如CPU地址总线宽度是20,可以传送$2^{20}$个不同的地址信息。可定位$2^20$个内存单元，该CPU的内存地址空间大小为1MB</li>
</ul>
</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是CPU中程序员可以用指令读写的部件。不同的CPU寄存器的个数、结构是不同的。8086CPU有14个寄存器，每个寄存器有一个名字。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>8086CPU的所有寄存器都是16位的，可以储存两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性数据，被称为 <strong>通用寄存器</strong> 。这4个寄存器可以分为两个独立使用的8位寄存器来使用:</p>
<ul>
<li>AX可分为AH和AL<ul>
<li>AX的低8位构成了AL寄存器，高8位构成了AH寄存器，后面的同理</li>
</ul>
</li>
<li>BX可分为BH和BL</li>
<li>CX可分为CH和CL</li>
<li>DX可分为DH和DL</li>
</ul>
<h3 id="几条汇编命令"><a href="#几条汇编命令" class="headerlink" title="几条汇编命令"></a>几条汇编命令</h3><table>
<thead>
<tr>
<th>汇编命令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,18</td>
<td>将18送入寄存器AX</td>
<td>AX=18</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将寄存器bx的数据送入寄存器AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax,18</td>
<td>将寄存器AX的数值加上18</td>
<td>AX=AX+18</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>将寄存器AX的数值加上寄存器BX的数值</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。</p>
<h3 id="16位结构的CPU"><a href="#16位结构的CPU" class="headerlink" title="16位结构的CPU"></a>16位结构的CPU</h3><p>特征：</p>
<ul>
<li>运算器最多可处理16位的数据</li>
<li>寄存器的最大宽度为16</li>
<li>寄存器和运算器之间的通路为16位</li>
</ul>
<h3 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h3><p>8086CPU有20位地址总线，可以传送20位地址。8086CPU又是16位结构，在内部一次性处理、传输、暂时储存的地址为16位。</p>
<p>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址</p>
<p>8086CPU读写内存的过程如下：</p>
<ul>
<li><ol>
<li>CPU中相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</li>
</ol>
</li>
<li><ol start="2">
<li>段地址和偏移地址通过内部总线接入一个称为地址加法器的部件</li>
</ol>
</li>
<li><ol start="3">
<li>地址加法器将两个16位地址合成一个20位的物理地址</li>
</ol>
</li>
<li><ol start="4">
<li>地址加法器通过内部总线20位物理地址送入输入输出控制电路</li>
</ol>
</li>
<li><ol start="5">
<li>输入输出控制电路将20位物理地址送上地址总线</li>
</ol>
</li>
<li><ol start="6">
<li>20位物理地址被地址总线传送到储存器</li>
</ol>
</li>
</ul>
<p>地址加法器采用 <strong>物理地址=段地址×16+偏移地址</strong> 的方法合成物理地址。如1230+00C8=12300+00C8=123C8(十六进制表示)</p>
<h3 id="“物理地址-段地址×16-偏移地址”的本质含义"><a href="#“物理地址-段地址×16-偏移地址”的本质含义" class="headerlink" title="“物理地址=段地址×16+偏移地址”的本质含义"></a>“物理地址=段地址×16+偏移地址”的本质含义</h3><p>本质含义是：CPU在访问内存时，用一个基础地址(段地址×16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。(有点类似计网中的网段)</p>
<h3 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h3><p>其实内存没有分段，段的划分来自于CPU，如我们可以认为地址10000H<del>100FFH的内存单元组成一个段，基础地址为10000H，段地址为1000H;我们也可以认为10000H</del>10007FH、10080H～100FFH的内存单元为两段，基础地址为10000H和10080H，段地址为1000H和1008H。</p>
<p>在编程时根据需要，将若干地址连续的内存单元看作一个段。</p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS、DS、SS、ES。</p>
<h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3><p>CS和IP是8086CPU中最关键的两个寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器。</p>
<p>在8086PC机中，设CS中内容为M，IP中内容为N，8086CPU将从内存M×16+N单元开始，读取一条命令并执行。过程如下</p>
<ul>
<li><ol>
<li>8086CPU当前状态：CS中内容为2000H，IP中内容为0000H</li>
</ol>
</li>
<li><ol start="2">
<li>内存20000H～20009H单元中存放着的机器码对应的汇编指令如下：<ul>
<li>地址：20000H～20002H，内容：B8 23 01，长度：3Byte，对应汇编指令：mov ax，0123H</li>
<li>等等</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>CS和IP寄存器的内容传入地址加法器合成物理地址20000H</li>
</ol>
</li>
<li><ol start="4">
<li>输入输出控制电路将物理地址20000H送上地址总线</li>
</ol>
</li>
<li><ol start="5">
<li>从内存20000H单元开始存放的机器指令B8 23 01通过数据总线送入CPU</li>
</ol>
</li>
<li><ol start="6">
<li>输入输出控制电路将机器指令B8 23 01送入指令缓冲器</li>
</ol>
</li>
<li><ol start="7">
<li>IP中的值根据指令长度自动增加</li>
</ol>
</li>
<li>跳转到第1步，重复这个过程</li>
</ul>
<p>CPU工作的时候把有的信息看作指令，有的信息看作数据，那CPU根据什么将内容中的信息看着指令？</p>
<ul>
<li>CPU将CS:IP指向的内存单元中的内容看作指令，因为，在任何时候，CPU将CS、IP中的内容看作指令的段地址和偏移地址，来在内存中读取指令码</li>
</ul>
<h3 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="修改CS、IP的指令"></a>修改CS、IP的指令</h3><p>在CPU中程序员能用指令读写的部件只有寄存器，程序员可以通过寄存器实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，通过改变CS、IP中的内容来控制CPU执行目前指令。</p>
<p>8086CPU大部分寄存器的值都可以通过mov指令来改变，mov指令被称为传送指令。但mov指令不能用于设置CS、IP的值，因为8086没有提供这样的功能。要改变CS、IP的内容需要的指令被称为跳转指令。一下简单介绍jmp指令。</p>
<p>若想修改CS、IP的内容，可用<code>jmp 段地址:偏移地址</code>的指令完成，如<code>jmp 2AE3:3</code>执行后<code>CS=2AE3H, IP=0003H</code>。</p>
<p>若想仅修改IP的内容，可用形如<code>jmp 某一合法寄存器</code>的指令来完成，如<code>jmp ax</code>执行后<code>IP=ax</code>。含义上好似<code>mov IP,ax</code></p>
<h2 id="寄存器-内存访问"><a href="#寄存器-内存访问" class="headerlink" title="寄存器(内存访问)"></a>寄存器(内存访问)</h2><h3 id="内存中字的储存"><a href="#内存中字的储存" class="headerlink" title="内存中字的储存"></a>内存中字的储存</h3><p><strong>字单元的概念</strong> :字单元，即存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p>
<p>以后我们称起始地址为N的字单元简称为N地址字单元。</p>
<p>例子：<br>|   |     |<br>|—|—–|<br>| 0 | 20H |<br>| 1 | 4EH |<br>| 2 | 12H |<br>| 3 | 00H |</p>
<p>0地址单元中存放的字节型数据是：20H</p>
<p>0地址字单元中存放的字型数据是：4E20H</p>
<h3 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h3><p>CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。</p>
<p><code>mov al, [0]</code>，这个指令将内存单元中的内容送入寄存器al。”[address]”表示一个内存单元，其中<code>[0]</code>中的0表示内存单元的偏移地址。执行命令时8086CPU自动读取DS中的数据为内存单元的段地址。</p>
<p>如何把一个数据送入DS寄存器呢？我们以前用过类似<code>mov ax,a</code>这样的指令来完成，但是8086CPU不支持将数据直接放入段寄存器的操作，所有需要先将数据放入一个一般寄存器，然后把一般寄存器的内容送入DS寄存器，<code>mov ds,ax</code>。</p>
<h3 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h3><p>我们用mov指令在寄存器和内存之间进行字节型数据的传送。因为8086CPU是16位结构的，也就是说一次传送一个字。只要在mov指令中给出16位寄存器就可以进行16位的数据传送了，mov指令中给出8位寄存器就进行8位数据传输。</p>
<p>例子：<br>|   |     |<br>|—|—–|<br>| 0 | 20H |<br>| 1 | 4EH |<br>| 2 | 12H |<br>| 3 | 00H |</p>
<p><code>mov ax,[1]</code>的结果是<code>ax=124EH</code></p>
<h3 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h3><p>8086CPU提供相关的指令来以栈的方式访问内存空间，这意味着基于8086编程时，可以将一段内存当作栈来使用。</p>
<p>8086CPU提供<code>push</code>和<code>pop</code>的入栈和出栈指令。<code>push ax</code>表示将寄存器ax中的数据送入栈中，<code>pop ax</code>表示从栈顶取出数据送入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。</p>
<ul>
<li>CPU如何知道哪段地址空间被当作栈来使用？push和pop时如何知道哪个单元是栈顶单元？<ul>
<li>8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。<strong>任意时刻SS:SP指向栈顶元素</strong> 。</li>
</ul>
</li>
</ul>
<p><code>push ax</code>执行时，由一下两个两步完成</p>
<ul>
<li><ol>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶单元为新的栈顶</li>
</ol>
</li>
<li><ol start="2">
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>
</ol>
</li>
</ul>
<p>因为CPU执行顺序是从地址低到高，而栈的后进先出的结构，所以push时从后方的地址开始<br>|                |    |<br>|—————-|—-|<br>| 10000H         |    |<br>| 10001H         |    |<br>| …            |    |<br>| SS:SP-&gt;1000EH | 23 |<br>| 1000FH         | 01 |</p>
<p><code>pop ax</code>的执行过程和<code>push ax</code>刚好相反：</p>
<ul>
<li><ol>
<li>将SS:SP指向的内存单元处的数据送入ax中</li>
</ol>
</li>
<li><ol start="2">
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新栈顶</li>
</ol>
</li>
</ul>
<p>栈为空时，偏移地址的计算方法：最底部的字单元的偏移地址+2，如：<br>|                        |  |<br>|————————|–|<br>| 10000H                 |  |<br>| 10001H                 |  |<br>| …                    |  |<br>| (最底部的字单元)1000EH |  |<br>| 1000FH                 |  |<br>| SP=0010H               |  |</p>
<h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><p>将一段内存当作栈段仅仅是我们编程时的一种安排</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>字在内存中存储时，要用两个地址连续的内存单元来存放</li>
<li>用mov指令访问内存单元，可以在mov指令中给出内存单元的偏移地址，此时段地址默认在DS寄存器中</li>
<li>[address]表示一个偏移地址为address的内存单元</li>
<li>在内存和寄存器之间传送数据类型时，高地址单元和高8位寄存器、低地址单元个低8位寄存器相对应</li>
<li>mov、add、sub是具有两个操作对象的指令，jmp是具有一个操作对象的指令</li>
<li>CPU不提供栈顶越界的保护，我们要自己注意</li>
</ul>
<h2 id="一个程序"><a href="#一个程序" class="headerlink" title="一个程序"></a>一个程序</h2><h3 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程"></a>一个源程序从写出到执行的过程</h3><ul>
<li>编写汇编源程序<ul>
<li>产生一个储存源程序的文本文件</li>
</ul>
</li>
<li>对源程序进行编译链接<ul>
<li>使用编译程序对源程序进行编译生成目标文件，再用链接工具对目标文件进行链接，生成可在操作系统中直接运行的可执行文件</li>
</ul>
</li>
<li>执行</li>
</ul>
<h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><h4 id="伪命令"><a href="#伪命令" class="headerlink" title="伪命令"></a>伪命令</h4><p>在汇编语言源程序中，包含两种命令，一种是汇编指令，一种是伪指令。</p>
<ul>
<li>汇编指令是有对应机械码的指令，可以被编译为机械指令，最终被CPU执行</li>
<li>伪指令没有对应的机械码，最终不被CPU执行<ul>
<li>伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作</li>
</ul>
</li>
</ul>
<h5 id="segment和ends"><a href="#segment和ends" class="headerlink" title="segment和ends"></a>segment和ends</h5><p>segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时必须要用的一对为指令。segment和ends的功能是定义一个段，一个段必须有一个名称来标识，格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">    ...</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure>

<p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到不同的段中。</p>
<h5 id="end"><a href="#end" class="headerlink" title="end"></a>end</h5><p>end是一个汇编程序的结束标记，如果碰到了伪指令end，就结束对 <strong>源程序</strong> 的编译。所以我们在写程序的时候，如果程序写完了，要在结尾出加上伪指令end。否则编译器无法知道何时结束。</p>
<p>注意，不要搞混end和ends，ends是和segment成对使用的，标记一个段的结束。而end是标记整个程序的结束。</p>
<h5 id="assume"><a href="#assume" class="headerlink" title="assume"></a>assume</h5><p>这个为指令含义为”假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</p>
<p>如下就是将一个把一个叫做code的段和cs段寄存器联系起来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    ...</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>

<h4 id="源程序中的”程序”"><a href="#源程序中的”程序”" class="headerlink" title="源程序中的”程序”"></a>源程序中的”程序”</h4><p>程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机械码，储存在可执行文件中</p>
<h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为：程序返回。</p>
<p>在程序末尾使用两条指令可以实现程序返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>


<h2 id="BX-和loop命令"><a href="#BX-和loop命令" class="headerlink" title="[BX]和loop命令"></a>[BX]和loop命令</h2><ul>
<li>用[address]表示一个内存单元时，单元的长度(类型)可以由具体指令中的其他操作对象(比如说寄存器)指出，如<code>mov al,[0]</code>这个内存单元就是一字节</li>
<li>[bx]同样也表示一个内存单元，它的偏移地址在bx中</li>
<li>loop进行循环</li>
<li>约定符号idata表示常量</li>
<li>我们将使用符号”()”来表示一个寄存器或一个内存单元中的内容</li>
</ul>
<h3 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h3><p>看看如下命令的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br></pre></td></tr></table></figure>

<p>功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA中的数据送入ax，即:(ax)=((ds)*16+(bx))</p>
<p>值得注意的是，bx是寄存器，可以使用一些指令，如：<code>inc bx</code>。就可以方便的完成某些任务，如：把每个内存单元的内容变为1。</p>
<h3 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h3><p>loop指令的格式是：loop标号，CPU执行loop指令的时候，要进行两部操作：1. (cx)=(cx)-1; 2. 判断cx中的值，不为零则跳转至标号处执行程序，否则向下执行。</p>
<p>可以看到cx中的值影响着loop指令的结果，通常我们在cx中存放循环次数</p>
<p>例：计算2^12。(N*2=N+N)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax,2</span><br><span class="line">    mov cx,11</span><br><span class="line">s:  add ax,ax</span><br><span class="line">    loop s</span><br><span class="line">    mov ax,4c00H</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行loop时(cx)先减1,然后若(cx)不为0，则跳转到s处。从上面的例子可以总结出用cx和loop配合实现循环的3个要点：</p>
<ul>
<li><ol>
<li>在cx中存放循环次数</li>
</ol>
</li>
<li><ol start="2">
<li>loop指令中的标号所标识地址要在前面</li>
</ol>
</li>
<li><ol start="3">
<li>要循环的程序段，要写在标号和loop指令中间</li>
</ol>
</li>
</ul>
<p>用cx和loop指令配合的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">    循环执行的程序段</span><br><span class="line">    loop s</span><br></pre></td></tr></table></figure>


<h3 id="loop和-bx-的联合应用"><a href="#loop和-bx-的联合应用" class="headerlink" title="loop和[bx]的联合应用"></a>loop和[bx]的联合应用</h3><p>若我们想要计算ffff:0~ffff:b单元中的元素的和，结果储存在dx中，分析：</p>
<ul>
<li><ol>
<li>dx是16位的寄存器，内存单元不能直接加到dx中，因为如果直接加会自动区一个字的大小，不满足题意</li>
</ol>
</li>
<li><ol start="2">
<li>不能用dl来做累加操作，因为dl大小不足以容纳所有内存单元的和导致进位丢失</li>
</ol>
</li>
</ul>
<p>所以我们需要引入一个16位寄存器ax作为中介，先把内存单元的内容送如al，在用ax和dx相加，通过bx和loop就可以完成。</p>
<h3 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h3><p>段地址默认在ds中，我们可以在访问的内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。如：<code>mov ax,ds:[bx]</code></p>
<h3 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h3><p>任意向一段内存空间写入内容是很危险的，因为这段内存空间可能存放着系统数据或代码。</p>
<h2 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h2><p>程序取得所需空间的方法有两种，一种是加载程序的时候为程序分配，另一种是程序在执行的过程中向系统申请。我们将介绍第一种。</p>
<p>我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。</p>
<h3 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h3><p>考虑这样一个问题，编程计算一下8个数据的和，结果存在ax寄存器中：2134h、5342h、6563h、…。如何将这些数据储存在一组地址连续的内存单元中？又在哪找到这段内存空间？</p>
<p>我们可以在程序中，定义我们希望处理的数据，这些数据会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也会被加载如内存中。这些数据自然而然地获得了储存空间。</p>
<p>具体看下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line"></span><br><span class="line">    mov ax,2345h</span><br><span class="line">    some code...</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>程序开头”dw”的含义是定义字型数据(define word)。那这些个数据在哪里呢？由于它们在代码段中，程序在运行的时候CS中存放代码段的地址，所以可以从CS中的到他们的段地址。那它们的偏移地址是多少？因为用dw定义的数据处于代码最开始，所以偏远地址为0～E。</p>
<p>但是编译、连接成可执行文件后，在系统直接运行可能出现问题，因为在程序的入口处不是我们希望执行的指令(而是一些数据)。因此，我们可以在源程序中指明程序的入口所在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line"></span><br><span class="line">    start:  mov ax,2345h   ; &lt;---- 在程序的第一条指令的前面加上标号start</span><br><span class="line"></span><br><span class="line">            some code...</span><br><span class="line">code ends</span><br><span class="line">end start       ; &lt;----</span><br></pre></td></tr></table></figure>

<p>在程序的第一条指令的前面加上标号start，这个标号在伪命令end的后面出现，用于通知编译器程序的入口在什么地方。</p>
<p>回顾可执行文件中的程序执行过程如下：</p>
<ul>
<li><ol>
<li>有其他的程序(shell等)将可执行文件中的程序加载入内存</li>
</ol>
</li>
<li><ol start="2">
<li>设置CS:IP指向程序的第一条要执行的指令(程序入口)，从而使程序得以运行</li>
</ol>
</li>
<li><ol start="3">
<li>程序结束后，返回到加载者</li>
</ol>
</li>
</ul>
<p>现在问题是，根据什么设置CPU的CS:IP指向程序的第一条要执行的指令？这一点，是由可执行文件中的描述信息指明的。可执行文件由描述信息和程序组成：程序来自源程序中的汇编指令和定义的数据;描述信息则主要是通过编译、连接程序对源程序中相关的伪指令进行处理所得到的信息。</p>
<h3 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h3><p>我们首先要有一段可当作栈的空间，可在程序中通过定义数据来获取一段空间，然后将这段空间当作栈空间来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">                            ;用dw定义8个字型数据，加载程序后将获得8个字的内存空间，这段空间可当作栈使用</span><br><span class="line"></span><br><span class="line">    start:      mov ax,cs</span><br><span class="line">                mov ss,ax</span><br><span class="line">                mov sp,20h  ;将栈顶ss:sp指向cs:20h</span><br><span class="line">                </span><br><span class="line">                some code...</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这段程序中定义了8个字型数据，它们的值都是0。这8个数据的值是多少对程序来说没有意义，只是用它们来开辟内存。</p>
<h3 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h3><p>我们在编程的时候要主要何处是数据，何处是代码，何处是栈。这样显然就有两个问题：</p>
<ul>
<li>把它们放在一个段中使程序显得混乱</li>
<li>一个段的容量是受限的，如果数据、栈和代码都放在一个段中，空间可能就不够</li>
</ul>
<p>所以用多个段来存放数据、代码和栈。我们用定义代码段一样的方法定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来获取栈空间。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 3422,2346h,5643h,3422,2346h,5643h,3422h,3422</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,20h  ;设置栈顶ss:sp指向stack:20</span><br><span class="line">        ...</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li>定义了多个段方法<ul>
<li>对于不同的段，要用不同的段名</li>
</ul>
</li>
<li>对段地址引用<ul>
<li>段名就相当于一个符号，它代表这段地址</li>
</ul>
</li>
</ul>
<h2 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h2><h3 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h3><ul>
<li>and指令：逻辑与指令，按位进行运算<ul>
<li>通过该指令可将操作对象相应位设备0，其他位不变</li>
</ul>
</li>
<li>or指令：逻辑或指令，按位进行运算<ul>
<li>通过该指令可将操作对象相应位设备1，其他位不变</li>
</ul>
</li>
</ul>
<h3 id="以字符形式给出的数据"><a href="#以字符形式给出的数据" class="headerlink" title="以字符形式给出的数据"></a>以字符形式给出的数据</h3><p>可以在汇编程序中，用’…’的方式指明数据是以字符的形式给出的，编译器将它们转化成对应的ASCII码。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    db &#39;unIX&#39;  ;; db是define binary，用一个字节储存，与dw同理</span><br><span class="line">data ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>“db ‘unIX’”就相当于”db 75H, 6EH, 49H, 58H”</p>
<h3 id="大小写转换的问题"><a href="#大小写转换的问题" class="headerlink" title="大小写转换的问题"></a>大小写转换的问题</h3><p>常规的解法是ASCII码加上或减去一个数，但是我们还没说到条件控制，该怎么办呢？寻找新的规律可以看到，就ASCII码的二进制形式来看，除了第5位外，大写字母和小写字母的其他位都一样。因此我们要了新的方法：将第5位变为0或1就能改变成大小写了。</p>
<h3 id="用-bx-idata-的方式进行数组的处理"><a href="#用-bx-idata-的方式进行数组的处理" class="headerlink" title="用[bx+idata]的方式进行数组的处理"></a>用[bx+idata]的方式进行数组的处理</h3><p>我们知道在C语言中，数组实际上就是一段连续的内存空间。假设第一个数长5个字节，第二个数组有5个字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[bx]  ;; 定位第一个数组</span><br><span class="line">mov al,[5+bx]  ;; 定位第二个数组</span><br><span class="line">;;或写成</span><br><span class="line">mov al,5[bx]</span><br></pre></td></tr></table></figure>

<p>和C语言对比：</p>
<ul>
<li>C语言<ul>
<li><code>a[i], b[i]</code></li>
</ul>
</li>
<li>汇编语言<ul>
<li><code>0[bx], 5[bx]</code></li>
</ul>
</li>
</ul>
<h3 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h3><p>si和di是8086CPU中和bx功能近似的寄存器，si和di不能分成两个8位寄存器来使用。</p>
<p>我们可以灵活使用[bx+si+idata]和[bx+di+idata]来表示一个内存单元。</p>
<p>-对于[bx+si]和[bx+di]，有指令<code>mov ax,[bx+si]</code>等，该指令也可以写出如下格式(常用)<br>    - <code>mov ax,[bx][si]</code><br>-对于[bx+si+idata]和[bx+di+idata]，有指令<code>mov ax,[bx+si+200]</code>等，该指令也可以写出如下格式(常用)<br>    - <code>mov ax,200[bx][si]</code><br>    - <code>mov ax,[bx][si].200</code><br>    - <code>mov ax,[bx].200[si]</code></p>
<h2 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h2><ul>
<li><ol>
<li>处理的数据在什么地方?</li>
</ol>
</li>
<li><ol start="2">
<li>要处理的数据有多长?</li>
</ol>
</li>
</ul>
<p>我们定义两个描述性符号：reg和sreg。reg表示寄存器;sreg表示段寄存器。</p>
<h3 id="bx、si、di和bp"><a href="#bx、si、di和bp" class="headerlink" title="bx、si、di和bp"></a>bx、si、di和bp</h3><p>前面三个寄存器已经讲过，现在来进行一下总结：</p>
<ul>
<li><ol>
<li>在8086CPU中，只有这4个寄存器可以用在[…]中来进行内存单元的寻址</li>
</ol>
</li>
<li><ol start="2">
<li>在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di</li>
</ol>
</li>
<li><ol start="3">
<li>只要在[…]中使用寄存器bp，而指令没有显性地给出段地址，段地址默认在ss中</li>
</ol>
</li>
</ul>
<h3 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h3><p>汇编语言中用3个概念来表达数据的位置：</p>
<ul>
<li>立即数(idata)<ul>
<li>对于直接包含在机器指令中的数据(执行前在CPU的指令缓冲器中)，在汇编语言中称为：立即数，在汇编指令中直接给出</li>
</ul>
</li>
<li>寄存器<ul>
<li>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名</li>
</ul>
</li>
<li>段寄存器(SA)和偏移地址(EA)<ul>
<li>指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中(如ds)</li>
</ul>
</li>
</ul>
<h3 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h3><p>8086CPU的指令，可以处理两种尺寸的数据：byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。汇编语言用以下方法处理：</p>
<ul>
<li>根据寄存器名指明要处理的数据的尺寸</li>
<li>在没有寄存器名存在的情况下，用操作符<code>X ptr</code>指明内存单元的长度，X在汇编指令中可以为word或byte<ul>
<li>如：<code>mov word ptr ds:[0],1</code></li>
</ul>
</li>
<li>其他方法<ul>
<li>这些指令默认了访问的是字单元还是字节单元，如<code>push [1000H]</code>push指令只进行字操作</li>
</ul>
</li>
</ul>
<h3 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h3><p>div是除法指令，使用div做除法时应注意以下问题：</p>
<ul>
<li>除数：有8位和16位两种，在一个reg或内存单元中</li>
<li>被除数：默认放在AX或DX和AX中<ul>
<li>如果除数是8位，被除数则为16位，默认在AX中存放</li>
<li>如果除数是16位，被除数则为32位，默认在DX和AX中存放，DX存放高16位，AX存放低16位</li>
</ul>
</li>
<li>结果<ul>
<li>如果除数为8位，则AL储存除法操作的商，AH储存除法操作的余数</li>
<li>如果除数为16位，则AX储存除法操作的商，DX储存除法操作的余数</li>
</ul>
</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br></pre></td></tr></table></figure>

<p>例：计算100001/100</p>
<p>被除数100001远大于65535，所以只能用dx和ax两个寄存器联合存放100001(32位)。除数小于255,可以在一个8位寄存器中存放。但是因为被除数是32位的，除数应该为16位，所以用一个16位的寄存器储存100.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>


<h3 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h3><p>dd是用来定义dword(double word，双字)类型数据的</p>
<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p>dup是一个操作符，在汇编语言中和db、dw、dd等一样，也是由编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0,1,2)</span><br></pre></td></tr></table></figure>

<p>定义了9个字节，相当于<code>db 0,1,2,0,1,2,0,1,2</code></p>
<p>dup的使用格式如下：</p>
<ul>
<li>db 重复的次数 dup (重复的字节型数据)</li>
<li>dw 重复的次数 dup (重复的字型数据)</li>
<li>dd 重复的次数 dup (重复的双字型数据)</li>
</ul>
<h2 id="转移指令的原理"><a href="#转移指令的原理" class="headerlink" title="转移指令的原理"></a>转移指令的原理</h2><p><strong>可以修改IP，或同时修改CS和IP的指令统称为转移指令</strong>。</p>
<p>8086CPU的转移指令行为有以下几类：</p>
<ul>
<li>只修改IP时，称为段内转移，如：<code>jmp ax</code> </li>
<li>同时修改CS和IP时，称为段间转移，如：<code>jmp 1000:0</code></li>
</ul>
<h3 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h3><p>offset是由编译器处理的符号，它的功能是取得标号的偏移地址。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start:mov ax,offset start   ;; 相当于mov ax,0</span><br><span class="line">        s:mov ax,offset s       ;; 相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面的程序中，offset操作符取得了标号start和s的偏移地址0和3。</p>
<h3 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h3><p><code>jmp short 标号</code>转到标号处执行指令</p>
<p>这种格式的jmp指令实现的是段内短转移，它对IP修改的范围为-128~127，即最多可以向前跨越128个字节，向后127个字节。指令中的”标号”是代码段中的标号，指明了指令要转移的目的地，跳转指令结束后，CD:IP应该指向标号处的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start:mov mov ax, 0   </span><br><span class="line">          jmp short s</span><br><span class="line">          add ax, 1</span><br><span class="line">        s:inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>上面的程序就跳过了<code>add ax, 1</code></p>
<p><code>jmp short</code>依据位移进行转移，也就是说CPU执行jmp指令的时候并不需要转移的目的地址，只需要转移的位移，编译器后计算jmp到标号的位移。</p>
<p><code>jmp short 标号</code>的功能为：(IP)=(IP)+8位位移</p>
<ul>
<li>8位位移=标号处的地址-jmp指令后的第一个字节的地址</li>
<li>short指明此处的位移为8位位移</li>
<li>8位位移的范围为-127~128，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
<p>还有一种与<code>jmp short</code>功能类似的指令，<code>jmp near ptr 标号</code>，它实现的是段内转移，功能为：(IP)=(IP)+16</p>
<ul>
<li>17位位移=标号处的地址-jmp指令后的第一个字节的地址</li>
<li>near ptr指明此处的位移为16位位移</li>
<li>16位位移的范围为-32768~32767，用补码表示</li>
<li>16位位移由编译程序在编译时算出</li>
</ul>
<h3 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h3><p><code>jmp far ptr 标号</code>实现的是段间转移，又称远转移，功能如下：</p>
<ul>
<li>(CS)=标号所在的段地址;(IP)=标号所在段中的偏移地址。</li>
<li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP</li>
</ul>
<h3 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h3><p>转移地址在内存中的jmp指令有两种格式：</p>
<ul>
<li><code>jmp word ptr 内存单元地址(段内地址)</code><ul>
<li>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址</li>
</ul>
</li>
<li><code>jmp dword ptr 内存单元地址(段内地址)</code><ul>
<li>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处的转移的目的偏移地址</li>
<li>(CS)=(内存单元地址+2)</li>
<li>(IP)=(内存单元地址)</li>
</ul>
</li>
</ul>
<h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是转移的目的地址。对IP的修改范围都是：-127~128</p>
<p>指令格式：<code>jcxz 标号</code>如果(cx)=0，则转移到标号处执行</p>
<ul>
<li>操作：当(cx)=0时，(IP)=(IP)+8位位移<ul>
<li>8位位移=标号处的地址-jcxz指令后的第一个字节的地址</li>
<li>8位位移的范围为-127~128，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
</li>
<li>当(cx)!=0时，什么也不做，程序向下执行</li>
</ul>
<p>用C语言的话说，<code>jcxz 标号</code>的功能相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((cx)==<span class="number">0</span>)jmp short 标号;</span><br></pre></td></tr></table></figure>


<h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是转移的目的地址。对IP的修改范围都是：-127~128</p>
<p>指令格式：<code>loop 标号</code>(cx)=(cx)-1，如果(cx)!=0，则转移到标号处执行</p>
<ul>
<li>操作：(cx)=(cx)-1;如果(cx)!=0,(IP)=(IP)+8位位移<ul>
<li>8位位移=标号处的地址-jcxz指令后的第一个字节的地址</li>
<li>8位位移的范围为-127~128，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
</li>
<li>当(cx)=0时，什么也不做，程序向下执行</li>
</ul>
<p>用C语言的话说，<code>loop 标号</code>的功能相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line"><span class="keyword">if</span>((cx)!=<span class="number">0</span>)jmp short 标号;</span><br></pre></td></tr></table></figure>


<h3 id="根据位移转移的意义"><a href="#根据位移转移的意义" class="headerlink" title="根据位移转移的意义"></a>根据位移转移的意义</h3><p>这种设计方便了程序段在内存中的浮动配置。这段程序在内存中的不同位置都可以正确执行，只需要位移，而不需要具体的地址。因为当指令不存在具体地址处时，程序执行就会出错。</p>
<h2 id="CALL和RET指令"><a href="#CALL和RET指令" class="headerlink" title="CALL和RET指令"></a>CALL和RET指令</h2><p>call和ret指令都是转移指令，它们修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序(函数)的设计</p>
<h3 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h3><ul>
<li>ret指令用栈中的数据修改IP的内容，从而实现转移。执行ret指令时，进行下面两步操作：<ul>
<li><ol>
<li>(IP)=((ss)*16+(sp))<ul>
<li>出栈</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>(sp)=(sp)+2</li>
</ol>
</li>
<li>相当于<code>pop IP</code></li>
</ul>
</li>
<li>retf指令用栈中的数据修改cs和ip的内容，从而实现转移。执行retf指令时，进行下面4步操作：<ul>
<li><ol>
<li>(IP)=((ss)*16+(sp))</li>
</ol>
</li>
<li><ol start="2">
<li>(sp)=(sp)+2</li>
</ol>
</li>
<li><ol start="3">
<li>(CS)=((ss)*16+(sp))</li>
</ol>
</li>
<li><ol start="4">
<li>(sp)=(sp)+2</li>
</ol>
</li>
<li>相当于<code>pop IP; pop CS</code></li>
</ul>
</li>
</ul>
<h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>CPU执行call指令时，进行两步操作：</p>
<ul>
<li><ol>
<li>将当前的IP或CS和IP压入栈中</li>
</ol>
</li>
<li><ol start="2">
<li>转移</li>
</ol>
</li>
</ul>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令了原理相同</p>
<p>一下介绍call指令的主要应用格式</p>
<h3 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h3><p><code>call 标号</code>，将当前的IP压入栈后，转到标号处执行指令</p>
<p>CPU执行此种格式的call指令时，进行的操作如下：</p>
<ul>
<li><ol>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<ul>
<li>入栈，栈顶指针上移</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>(IP)=(IP)+16位位移<ul>
<li>根据标号</li>
</ul>
</li>
</ol>
</li>
<li>相当于:<code>push IP;jmp near ptr 标号</code></li>
</ul>
<h3 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h3><p><code>call far ptr 标号</code>，实现的是段间转移，CPU执行这种格式的call指令时，操作如下：</p>
<ul>
<li><ol>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(CS)<br>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<ul>
<li>入栈</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>(CS)=标号所在段的段地址<br>(IP)=标号所在段中的偏移地址</li>
</ol>
</li>
<li>相当于<br><code>push CS</code><br><code>push IP</code><br><code>jmp far ptr 标号</code></li>
</ul>
<h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p>格式:<code>call 16位reg</code>。功能：</p>
<ul>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(IP)=(16位reg)</li>
<li>相当于：<br><code>push IP</code><br><code>jmp 16位reg</code></li>
</ul>
<h3 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h3><p>转移地址在内存中的call指令有两种格式：</p>
<ul>
<li><code>call word ptr 内存单元地址</code><ul>
<li>相当于：<br><code>push IP</code><br><code>jmp word ptr 内存单元地址</code></li>
</ul>
</li>
<li><code>call dword ptr 内存单元地址</code><ul>
<li>相当于：<br><code>push CS</code><br><code>push IP</code><br><code>jmp dword ptr 内存单元地址</code></li>
</ul>
</li>
</ul>
<h3 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h3><p>我们可以写一个具有一定功能的程序段，我们称之为子程序，在需要的时候用call指令转去执行。执行完后用ret指令，用栈中的数据设置IP值，从而跳到call的下一条指令继续执行。</p>
<p>这样，我们可以利用call和ret来实现子程序的机制。子程序的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号：</span><br><span class="line">    指令</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>具有子程序的源程序的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    main:</span><br><span class="line">        :</span><br><span class="line">        call sub1   ;;调用子程序1</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">    sub1:</span><br><span class="line">        :</span><br><span class="line">        call sub2</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">    sub2:</span><br><span class="line">        :</span><br><span class="line">        :</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>

<p>使用call和ret可以实现模块化设计</p>
<h3 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h3><p>mul是乘法指令，使用mul时注意以下两点：</p>
<ul>
<li><ol>
<li>两个相乘的数：两个数要么都是8位，要么都是16位<ul>
<li>如果是8位乘法，一个默认放在AL中，另一个放在8位reg或内存字节单元中</li>
<li>如果是16位乘法，一个默认在AX中，另一个放在16为reg或内存字单元中</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>结果：<ul>
<li>8位乘法结果默认放在AX中</li>
<li>16位乘法结果高位默认放在DX中，低位放在AX中</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">;; 内存单元可以用不同的寻址方式给出：</span><br><span class="line">mul byte ptr ds:[0]</span><br><span class="line">mul word ptr [bx+si+8]</span><br></pre></td></tr></table></figure>


<h3 id="参数和结果传递的问题"><a href="#参数和结果传递的问题" class="headerlink" title="参数和结果传递的问题"></a>参数和结果传递的问题</h3><p>既然知道了如何调用子程序，那应该如何储存子程序需要的参数和产生的返回值呢？</p>
<ul>
<li>显然可以用寄存器来存。</li>
</ul>
<p>那么如果有N个参数和结果，寄存器的个数是有限的，该怎么存放呢？</p>
<ul>
<li>这个时候没将批量的数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给子程序。对于批量的结果也如此的方法。</li>
</ul>
<p><strong>看下面一个例子:</strong> 设计一个子程序，将一个全是字母的字符串转换为大写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#39;conversation&#39;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    start:  mov ax,data</span><br><span class="line">            mov ds,ax</span><br><span class="line">            mov si,0        ;ds:si指向字符串所在空间的首地址</span><br><span class="line">            mov cx,12       ;cx存放字符串的长度</span><br><span class="line">            call capital    ;调用子程序，就像调用函数</span><br><span class="line"></span><br><span class="line">            mov ax,4c00h</span><br><span class="line">            int 21h</span><br><span class="line"></span><br><span class="line">    capital:and byte ptr [si],11011111b</span><br><span class="line">            inc si</span><br><span class="line">            loop capital</span><br><span class="line">            ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数</strong></p>
<h4 id="用栈来传递参数"><a href="#用栈来传递参数" class="headerlink" title="用栈来传递参数"></a>用栈来传递参数</h4><p>由调用者将要传递给子程序的参数压入栈中，子程序从栈中取得参数。</p>
<ul>
<li>编写一个函数：计算(a-b)^3，a、b为字型数据，参数为a、b</li>
<li>栈顶存放IP、后面依次是a、b(注意参数顺序)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func:   push bp         ;子程序用到寄存器bp，先保存原来的值</span><br><span class="line">        mov bp,sp</span><br><span class="line">        mov ax,[bp+4]   ;将栈中a送入ax</span><br><span class="line">        sub ax,[bp+6]   ;减栈中b的值</span><br><span class="line">        mov bp,ax</span><br><span class="line">        mul bp</span><br><span class="line">        mul bp</span><br><span class="line">        pop bp</span><br><span class="line">        ret 4</span><br></pre></td></tr></table></figure>

<p>指令<code>ret 4</code>的含义用汇编语法描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop ip      ;即返回ip，并使将栈顶指针该为调用前的值。应为这个例子的参数是两个字，所以是4.</span><br><span class="line">add sp,n</span><br></pre></td></tr></table></figure>

<p>看一下对这个函数是如何调用的，设a=3、b=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mob ax,1</span><br><span class="line">push ax</span><br><span class="line">mov ax,3    ;注意顺序</span><br><span class="line">push ax</span><br><span class="line">call func</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>低地址单元</th>
</tr>
</thead>
<tbody><tr>
<td>BP</td>
</tr>
<tr>
<td>IP</td>
</tr>
<tr>
<td>3  [bp+4]</td>
</tr>
<tr>
<td>1  [bp+6]</td>
</tr>
<tr>
<td>高地址单元</td>
</tr>
</tbody></table>
<h3 id="寄存器冲突的问题"><a href="#寄存器冲突的问题" class="headerlink" title="寄存器冲突的问题"></a>寄存器冲突的问题</h3><p>问题在于：<strong>子程序中的寄存器，很可能在组程序中也要使用，造成寄存器使用上的冲突</strong></p>
<p>我们希望：</p>
<ul>
<li>编写调用子程序的时候不必关心子程序到底使用了那些寄存器</li>
<li>编写子程序的时候不必关心调用者使用了哪些寄存器</li>
<li>不会发生寄存器冲突</li>
</ul>
<p>解决这个问题的间捷方法是，在子程序的开始将子程序中所有用到的内容保存起来，在子程序返回前恢复。可以用栈来保存寄存器中的内容</p>
<p>以后我们编写子程序的标准框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序开始: 子程序使用的寄存器入栈</span><br><span class="line">            子程序内容</span><br><span class="line">            子程序中使用的寄存器出栈</span><br><span class="line">            返回(ret、retf)</span><br></pre></td></tr></table></figure>

<p>看下面一个例子，将一个全是字母，以0结尾的字符串转换为大写的子程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">capital:    push cx  ;使用的寄存器入栈</span><br><span class="line">            push si</span><br><span class="line"></span><br><span class="line">change:     mov cl,[si]</span><br><span class="line">            mov ch,0</span><br><span class="line">            jcxz ok</span><br><span class="line">            and byte ptr [si],11011111b</span><br><span class="line">            inc si</span><br><span class="line">            jmp short change</span><br><span class="line"></span><br><span class="line">        ok: pop si  ;使用的寄存器出栈</span><br><span class="line">            pop cx</span><br><span class="line">            ret</span><br></pre></td></tr></table></figure>


<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>在CPU内部的寄存器中，有一种特殊的寄存器(不同的CPU，个数结构可能不同)具有以下3种作用：</p>
<ul>
<li>用来存储相关指令的某些执行结果</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPu的相关工作方式</li>
</ul>
<p>这种特殊的寄存器在8086CPU中，被称为 <strong>标志寄存器</strong> 。以下称为flag寄存器。</p>
<p>8086CPU的flag寄存器的结构如下：</p>
<table>
<thead>
<tr>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>OF</td>
<td>DF</td>
<td>IF</td>
<td>TF</td>
<td>SF</td>
<td>ZF</td>
<td></td>
<td>AF</td>
<td></td>
<td>PF</td>
<td></td>
<td>CF</td>
</tr>
</tbody></table>
<h3 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h3><p>flag的第6位是ZF，零标志位。它记录相关指令执行后其结果是否为0。如果结果为0,则zf=1;否则zf=0。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br><span class="line"></span><br><span class="line">;zf&#x3D;1</span><br></pre></td></tr></table></figure>

<p>在8086CPU的指令集中，有的指令执行是影响标志位寄存器的，如：add、sub、mul、div、and、or等，它们大多都是运算指令;有的指令是不影响的，如mov、push、pop等，它们大多都是传送指令。</p>
<h3 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h3><p>flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数是偶数，pf=1。否则pf=0。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br><span class="line"></span><br><span class="line">;结果是00001011b，有奇数个1，pf&#x3D;0</span><br></pre></td></tr></table></figure>


<h3 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h3><p>flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果(对于有符号数)是否为负。如果结果为负，sf=1，否则sf=0。</p>
<p>计算机通常使用补码来表示有符号数，对于无符号数SF的值没有意义，虽然相关指令影响了它的值。</p>
<h3 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h3><p>flag的第0位是CF，进位标志。一般情况下，进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p>
<p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，就是它的最高有效位。</p>
<h3 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h3><p>由于进行有符号数运算的时候，可能发生溢出造成结果错误。则CPU需要对指令执行后产生的溢出进行记录。</p>
<p>flag的第11位是OF，溢出标志。一般情况下，OF记录了有符号数运算的结果是否溢出了。如果溢出，OF=1，否则OF=0。</p>
<p>注意CF和OF的区别：CF是对无符号数有意义的标志位，OF是对无符号数有意义的标志位。</p>
<h3 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h3><p>adc是带进位加法指令，它利用了CF上记录的进位值。</p>
<ul>
<li>指令格式：<code>adc 操作对象1 操作对象2</code></li>
<li>功能：操作对象1 = 操作对象1 + 操作对象2 + CF</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax  ;1-2借位，CF&#x3D;1</span><br><span class="line">adc ax,1   ;执行后(ax)&#x3D;4&#x3D;(ax)+1+CF</span><br></pre></td></tr></table></figure>

<p>在执行adc指令的时候加上的CF的值的含义，由adc指令前的指令决定的。</p>
<p>CPU提供adc指令是有目的的，就是来进行加法的第二步运算。</p>
<p>例：计算1EF0001000H+2010001EF0H，结果放在ax(最高16位)，bx(次高16位)，cx(低16位)中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">mov cx,1000H</span><br><span class="line">add cx,1EF0H</span><br><span class="line">adc bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure>


<h3 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h3><p>sbb是带借位减法指令，它利用CF位上记录的借位值。应用思路类似adc</p>
<h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果，而是cmp指令执行后对标志寄存器产生影响。</p>
<ul>
<li>cmp指令格式：<code>cmp 操作对象1 操作对象2</code></li>
<li>功能：操作对象1-操作对象2但不保留结果，仅仅根据结算结果来对标志寄存器进行设置</li>
<li>如，<code>cmp ax,ax</code>，结果为0，那么标志寄存器：zf=1,pf=1,sf=0,cf=0,of=0。</li>
</ul>
<p>cmp的使用非常灵活，如要判断两个数相减的结果是不是负数：cmp将结果在flag中记录，通过判断sf(正负)和of(溢出)就可得知逻辑上真正结果的正负。</p>
<h3 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h3><p>除了jcxz指令之外，CPU还提供了其他条件转移指令，大多数条件转移指令通过检测相关的标志位，根据检测的结果修改IP。通常和cmp配合使用。</p>
<p>下面是常用的条件转移指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>cf=1或zf=1</td>
</tr>
</tbody></table>
<h3 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h3><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p>
<ul>
<li>df=0，每次操作后si、di递增</li>
<li>df=1，每次操作后si、di递减</li>
</ul>
<p>看下面一个串传送指令：</p>
<ul>
<li>格式：<code>movsb</code></li>
<li>功能：将ds:si指向的内存单元中的字节送入es:di中。执行movsb指令相当于进行下面几步操作<ul>
<li><ol>
<li>((es)*16+(di))=((ds)*16+(si))</li>
</ol>
</li>
<li><ol start="2">
<li>如果df=0，则(si)=(si)+1;(di)=(di)+1</li>
</ol>
</li>
<li><ol start="2">
<li>如果df=1，则(si)=(si)-1;(di)=(di)-1</li>
</ol>
</li>
</ul>
</li>
<li>相当于：<br>  <code>mov es:[di], byte ptr ds:[si]</code><br>  如果df=0：<code>inc si;inc di</code><br>  如果df=1：<code>dec si;dec di</code>  </li>
<li>传送一个字的指令是<code>movsw</code></li>
</ul>
<p>movsb和movsw进行的是串传送操作中的一个步骤，一般来说movsb和mobsw都是配合rep使用的，个是如下</p>
<ul>
<li><code>rep movsb</code><ul>
<li>类似于:<br><code>s:movsb</code><br><code>loop s</code></li>
</ul>
</li>
<li>rep的作用是根据cx的值，重复后面的串传送指令</li>
</ul>
<p>由于df位决定着串传送指令执行后，si和di是递增还是递减，所以CPU应提供对df进行设置的操作。在8086CPU中：</p>
<ul>
<li>cld指令：将标志位寄存器的df设置为0</li>
<li>std指令：将标志位寄存器的df设置为1</li>
</ul>
<h3 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h3><p>pushf的功能是将标志寄存器的值压入栈中，而popf是从栈中弹出数据，送入标志寄存器中。这也是为什么前面讲标志寄存器结构时，强调什么是第几位的原因。</p>
<p>pushf和popf，为直接访问标志寄存器提供了一种方法。</p>
<h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><p>任何一个通用CPU都具备一种能力：在执行完当前正在执行的指令之后，检测到从CPU外发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种信息称为中断信息。中断的意思是指，CPU不再接着向下执行，而是转去处理这个特殊的信息。</p>
<h3 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h3><p>当CPU内部有什么事情发生时会马上处理中断信息呢？对于8086CPU，有以下情况发生时，将产生中断信息：</p>
<ul>
<li>除法错误</li>
<li>单步执行</li>
<li>执行into指令</li>
<li>执行int指令</li>
</ul>
<p>不同的信息需要不同的处理方式。中断信息中包含识别来源的编码，8086CPU用称为中断类型码来识别信息的来源。中断类型码为一个字节，可以表示256种中断信息来源。在8086CPU中：</p>
<ul>
<li>除法错误:0</li>
<li>单步执行:1</li>
<li>执行into指令:4</li>
<li>执行int指令：该指令的格式为<code>int n</code>，n是立即数，是提供给CPU的中断类型码</li>
</ul>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>CPU收到中断信息后，需要对信息进行处理。如何处理可以由我们编程决定。我们所编写的中断信息处理程序称为中断处理程序。</p>
<p>CPU在收到中断信息后，应该转去(改变CS:IP指向)对应的中断处理程序中。中断类型码就是用来定位中断处理程序的。</p>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢？</p>
<ul>
<li>CPU通过中断向量表找到相应的中断处理程序入口地址。中断向量表就是中断处理程序入口地址的列表。</li>
</ul>
<p>CPU如何找到中断向量表？</p>
<ul>
<li>中断向量表在内存中存放，在8086CPU中，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF的1024个内存单元中存放着中断向量表。</li>
</ul>
<h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。所以在中断过程中，在设置CS:IP之前，还要将原来的CS和IP的值保存起来。与call指令调用子程序同理。</p>
<p>下面是8086CPU收到中断信息后，所引发中断的过程：</p>
<ul>
<li><ol>
<li>获取中断类型码</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈</li>
</ol>
</li>
<li><ol start="3">
<li>设置标志寄存器的第8位TF和第9位IF值为0，因为这也两个标志寄存器也可以是触发中断的因素</li>
</ol>
</li>
<li><ol start="4">
<li>CS内容入栈</li>
</ol>
</li>
<li><ol start="5">
<li>IP内容入栈</li>
</ol>
</li>
<li><ol start="6">
<li>从内存地址为<code>中断类型码*4</code>和<code>中断类型码*4+2</code>的两个字单元中读取中断处理程序的入口地址设置IP和CS</li>
</ol>
</li>
</ul>
<h3 id="中断处理程序和iret指令"><a href="#中断处理程序和iret指令" class="headerlink" title="中断处理程序和iret指令"></a>中断处理程序和iret指令</h3><p>由于CPU随时可能检测到中断信息，所以中断处理程序必须一直储存来内存的某段空间之中，而中断向量必须存储在对应的中断向量表项中。</p>
<p>中断处理程序的编写方法和子程序比较相似，步骤如下：</p>
<ul>
<li><ol>
<li>保存用到的寄存器</li>
</ol>
</li>
<li><ol start="2">
<li>处理中断</li>
</ol>
</li>
<li><ol start="3">
<li>恢复用到的寄存器</li>
</ol>
</li>
<li><ol start="4">
<li>用iret指令返回</li>
</ol>
</li>
</ul>
<p>iret指令用汇编语法描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>


<h3 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h3><p>当除法溢出的时候，产生0号中断信息，从而引发中断过程。此时，CPU将进行如下工作：</p>
<ul>
<li><ol>
<li>获取中断类型码0</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈，TF、IF设置为0</li>
</ol>
</li>
<li><ol start="3">
<li>CS、IP入栈</li>
</ol>
</li>
<li><ol start="4">
<li>(IP)=(0*4)，(CS)=(0*4+2)</li>
</ol>
</li>
</ul>
<p>那么现在的问题是，中断处理程序(我们设为do0)应该放在哪里？</p>
<ul>
<li>我们需要找到一块别的程序不会用到的内存区，将do0送入其中</li>
<li>前面说过，8086支持256个中断，但实际中并不会用到那么多。一般情况下，从0000:0200至0000:02FF的256个字节所对应的中断向量表项是空的，操作系统和其他程序都不会占用，所以我们可以使用这段空间</li>
</ul>
<p>程序框架如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  do0安装程序</span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  do0:  一些操作如:显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>可以看到，上面的程序分为两部分：</p>
<ul>
<li>安装do0，设置中断向量的程序<ul>
<li><ol>
<li>将do0的代码复制到内存0:200处</li>
</ol>
</li>
<li><ol start="2">
<li>设置中断向量表，将do0的入口地址保存到0号表项中</li>
</ol>
</li>
<li><ol start="3">
<li>返回</li>
</ol>
</li>
</ul>
</li>
<li>do0</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以使用movsb指令，将do0的代码送入0:200处。程序如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0       ;设置ds:si指向源地址</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h             ;设置es:di指向目的地址</span><br><span class="line"></span><br><span class="line">        mov cx,offset do0end-offset do0                     ;设置cs为传输长度，可利用编译器计算do0长度</span><br><span class="line"></span><br><span class="line">        cld                     ;设置传输方向为正向</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  do0:  一些操作如:显示字符串&quot;overflow!&quot;</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h3 id="do0"><a href="#do0" class="headerlink" title="do0"></a>do0</h3><p>do0程序的主要任务是显示字符串，如下</p>
<p>需要注意的是：</p>
<ul>
<li>因为do0程序随时可能被执行，而它要用到的字符串”overflow!”，所以该字符串也应该放在一段不会被覆盖的空间中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:  mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset do0       ;设置ds:si指向源地址</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h             ;设置es:di指向目的地址</span><br><span class="line"></span><br><span class="line">        mov cx,offset do0end-offset do0                     ;设置cs为传输长度，可利用编译器计算do0长度</span><br><span class="line"></span><br><span class="line">        cld                     ;设置传输方向为正向</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        设置中断向量表</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">  do0:  jmp short do0start</span><br><span class="line">        db &quot;overflow!&quot;</span><br><span class="line"></span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">         mov ds,ax</span><br><span class="line">         mov si,202h            ;设置ds:si指向字符串，因为do0主程序第一跳指令是跳转，占用两个字节，所以字符串的地址是202h</span><br><span class="line"></span><br><span class="line">         mov ax,0b800h</span><br><span class="line">         mov es,ax</span><br><span class="line">         mov di,12*160+36*2     ;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">         mov cx,9               ;设置字符串长度</span><br><span class="line">    s:   al,[si]</span><br><span class="line">         mov es:[di],al</span><br><span class="line">         inc si</span><br><span class="line">         add di,2</span><br><span class="line">         loop s</span><br><span class="line"></span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line"></span><br><span class="line">do0end: nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h3 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h3><p>0号表项的地址为0:0，其中0:0字单元存放偏移地址，0:2字单元存放段地址。程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0\*4],200h</span><br><span class="line">mov word ptr es:[0\*4+2],0</span><br></pre></td></tr></table></figure>


<h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>基本上，CPU在执行一条指令之后，如果检查到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的类型码为1，它引发的中断过程如下：</p>
<ul>
<li><ol>
<li>取得中断类型码</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈，TF、IF设置为0</li>
</ol>
</li>
<li><ol start="3">
<li>CS、IP入栈</li>
</ol>
</li>
<li><ol start="4">
<li>(IP)=(1*4), (CS)=(1*4+2)</li>
</ol>
</li>
</ul>
<p>CPU为什么要提供这样的功能呢？</p>
<ul>
<li>我们在debug的时候CPU执行一条指令后就显示各个寄存器的状态，然后等待输入</li>
</ul>
<p>当TF=1时，CPU在执行完一条指令后将引发单步中断，转去执行中断处理程序。 <strong>注意，中断处理程序也是由一条条指令组成的</strong> ，如果在执行中断处理程序之前，TF=1,则CPU执行完终端处理程序的第一条指令后，有产生单步中断，就这样死循环下去。</p>
<p>所以在进入中断处理程序之前，设置TF=0.从而避免CPU在执行中断处理程序的时候发生单步中断。</p>
<h3 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h3><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可在某些情况，即便是发生了中断，也不会响应。用一个例子说明：</p>
<p>在执行完向ss寄存器传送数据的指令后，即便发生中断，CPU也不会响应。因为ss:sp联合指向栈顶，对它们的设置应该连续完成。如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp没变，ss:sp不能指向正确的栈顶，引起错误。</p>
<h2 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h2><p>中断信息可以来自CPU的内部和外部，当CPU内部需要处理的事情发生时，将产生需要马上处理的中断信息，引发中断过程。</p>
<p>接下来将介绍另一种重要的内中断，由int指令引发的中断。</p>
<h3 id="int指令-1"><a href="#int指令-1" class="headerlink" title="int指令"></a>int指令</h3><p>int指令的格式为：<code>int n</code>，n为中断类型码，它的功能是引发中断过程。</p>
<p>CPU执行<code>int n</code>指令，相当于引发一个n号中断的中断过程，执行过程如下：</p>
<ul>
<li><ol>
<li>取中断类型码n</li>
</ol>
</li>
<li><ol start="2">
<li>标志寄存器入栈，IF=0，TF=0</li>
</ol>
</li>
<li><ol start="3">
<li>CS、IP入栈</li>
</ol>
</li>
<li><ol start="4">
<li>(IP)=(n*4)，(CS)=(n*4+2)<ul>
<li>跳转去n号中断处理程序</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>编写提供应用程序调用的中断例程，与中断处理类似：</p>
<ul>
<li>编写功能程序</li>
<li>安装程序到内存中</li>
<li>设置中断向量，将程序的入口地址保存到对应的表项中</li>
</ul>
<h3 id="对int、iret和栈的深入理解"><a href="#对int、iret和栈的深入理解" class="headerlink" title="对int、iret和栈的深入理解"></a>对int、iret和栈的深入理解</h3><p>问题：编写名为7ch的中断例程来完成loop指令的功能</p>
<p>分析：loop s的执行需要两个信息，循环的次数和到s的位移</p>
<p>例：屏幕中间显示80个”!”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start   :mov ax,0b800h</span><br><span class="line">         mov es,ax</span><br><span class="line">         mov di,160*12</span><br><span class="line"></span><br><span class="line">         mov bx,offset s-offset se      ;设置从标号se到标号s的转移位移</span><br><span class="line">         mov cx,80</span><br><span class="line">    s   :mov byte ptr es:[di],&#39;!&#39;</span><br><span class="line">         add di,2</span><br><span class="line">         int 7ch                        ;如果(cx)!&#x3D;0，转移到s处</span><br><span class="line">   se   :nop</span><br><span class="line"></span><br><span class="line">         mov ax,4c00h</span><br><span class="line">         int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>7ch中断例程如下:</p>
<ul>
<li><code>int 7ch</code>引发中断后，在中断过程中将当前的标志寄存器、CS和IP入栈</li>
<li>通过修改栈中的CS和IP就能让程序返回标号s所在的位置<ul>
<li>用标号se的偏移地址加上bx中存放的转移位移就可以得到标号s的偏移地址</li>
<li>如果7ch和主程序在同一段中，则栈中的段寄存器CS就不用修改</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  7ch   :push bp                        </span><br><span class="line">         mov bp,sp</span><br><span class="line">         dec cx</span><br><span class="line">         jcxz lpret                     ;如果cx等于0则不修改偏移地址，直接返回</span><br><span class="line">         add [bp+2],bx                  ;[bp+2]处是IP的内容，栈顶处是bp的内容，下面是se的偏移地址</span><br><span class="line">lpret   :pop bp</span><br><span class="line">         iret</span><br></pre></td></tr></table></figure>


<h3 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h3><p>在系统板的ROM中存放着一套程序，称为BIOS(基本输入输出系统)，主要包含以下几个部分：</p>
<ul>
<li>硬件系统的检测和初始化程序</li>
<li>外部中断和内部中断的中断例程</li>
<li>用于对硬件设备进行I/O操作的中断例程</li>
<li>其他和硬件系统相关的中断例程</li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>各种储存器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们当作内存来对待，把它们总地看做一个由若干储存单元组成的逻辑储存器。</p>
<p>PC机的芯片中，都有一组可以由CPU读写的寄存器，这些寄存器在物理上可能处于不同的芯片中，但是它们都在以下两点上相同：</p>
<ul>
<li>都和CPU的总线相连</li>
<li>CPU对它们进行读写的时候都通过控制总线向它们所在的芯片发出端口读写命令</li>
</ul>
<p>从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立一个统一的端口地址空间。每个端口在地址空间中都有一个地址</p>
<p>CPU可以直接读写以下3个地方的数据：</p>
<ul>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口</li>
</ul>
<p>以下讨论端口的读写</p>
<h3 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h3><p>在访问端口时，CPU通过端口地址来定位端口。因为端口所在的芯片和CPU通过总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围是0～65535</p>
<p>对端口的读写不能用mov、push、pop等内存读写指令。端口的读写指令只有两条：in和out</p>
<ul>
<li>in表示从端口读取数据</li>
<li>out表示往端口写入数据</li>
</ul>
<h4 id="访问端口"><a href="#访问端口" class="headerlink" title="访问端口"></a>访问端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h       ;从60h号端口读入一个字节</span><br></pre></td></tr></table></figure>

<p>执行时与总线相关的操作如下：</p>
<ul>
<li>CPU通过地址线将地址信息60h发出</li>
<li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</li>
<li>端口所在的芯片将60h端口中的数据通过数据线送入CPU</li>
</ul>
<p><strong>注意</strong> ，在in和out指令中，只能使用ax或al来存放从端口读入的数据或要发送到端口的数据。访问8位端口时用al，访问16位端口时用ax</p>
<p>对0～255以内的端口进行读写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h   </span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure>

<p>对256～65535的端口进行读写时，端口号放在dx中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h</span><br><span class="line">in al,dx   </span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure>


<h3 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h3><p>PC机中，有一个CMOS RAM芯片，一般简称为CMOS。有如下特征：</p>
<ul>
<li>包含一个实时钟和一个128个储存单元的RAM储存器</li>
<li>该芯片靠电池供电。所以关机后内部实时钟仍可正常工作，RAM中信息不会丢失</li>
<li>128个字节的RAM中，内部实时钟占用0～0dh单元来保存时间信息，其余大部分单元保存系统配置信息</li>
<li>该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM</li>
<li>70h为地址端口，存放要访问的CMOS RAM单元地址;71h为数据端口，存放从选定的CMOS RAM单元中读取的数据或要写入其中的数据，对CMOS操作时读写分为两步：如读CMOS RAM的2号单元<ul>
<li><ol>
<li>将2送入段偶70h</li>
</ol>
</li>
<li><ol start="2">
<li>从端口71h读出2号单元的内容</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h3><p>shl和shr是逻辑位移指令，shl是逻辑左移，shr是逻辑右移</p>
<p>以shl为例，它的功能为：</p>
<ul>
<li>将一个寄存器或内存单元中的数据向左位移</li>
<li>将最后移出的一位写入CF中</li>
<li>最低位用0补充</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1            ;将al数据左移一位</span><br><span class="line">;结果al&#x3D;10010000b， CF&#x3D;0</span><br></pre></td></tr></table></figure>

<p>如果位移数大于1时，必须将位移数放在cl中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">mov cl,2</span><br><span class="line">shl al,cl            ;将al数据左移2位</span><br><span class="line">;结果al&#x3D;00100000b， CF&#x3D;1</span><br></pre></td></tr></table></figure>

<p>逻辑左移相当于执行<code>X=X*2</code></p>
<p>shr是逻辑右移，和shl的操作相反</p>
<h3 id="CMOS-RAM中存储的时间信息"><a href="#CMOS-RAM中存储的时间信息" class="headerlink" title="CMOS RAM中存储的时间信息"></a>CMOS RAM中存储的时间信息</h3><p>在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。这6个信息的长度为1个字节。这些数据以BCD码的方式存放。</p>
<table>
<thead>
<tr>
<th>存放单元</th>
<th>0</th>
<th>2</th>
<th>4</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>秒</td>
<td>分</td>
<td>时</td>
<td>日</td>
<td>月</td>
<td>年</td>
</tr>
</tbody></table>
<p>CMOS RAM储存时间信息的单元中，储存了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。如00010100b表示14。</p>
<p><strong>实战</strong> :</p>
<p>编程：在屏幕中显示当前的月份</p>
<p>分析：这个程序主要做一下两个部分工作：</p>
<ul>
<li>从CMOS RAM的8号单元中读出当前月的BCD码<ul>
<li><ol>
<li>向地址端口70h写入要访问的单元的地址<br><code>mov al,8; out 70h,al</code></li>
</ol>
</li>
<li><ol start="2">
<li>从数据端口71h中取得指定单元中的数据<br><code>in al,71h</code></li>
</ol>
</li>
</ul>
</li>
<li>将用BCD码表示的月份用十进制的形式显示<ul>
<li>因为BCD码值=十进制码值，则BCD码值+30h=十进制对应的ASCII码</li>
<li>从CMOS RAM的8号内存单元读出的一个字节中，包含了用两个BCD码表示的两位十进制数，高4位为十为，低4位为个位<ul>
<li>取出这两个BCD码<br><code>mov ah,al</code><br><code>cl,4</code>  移位数<br><code>shr ah,cl</code>         ah中为月份的十位<br><code>and al,00001111b</code>  al中为月份的个位数</li>
<li>显示(ah)+30h和(al)+30h对应的ASCII码字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>完整程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:  mov al,8</span><br><span class="line">        out 70h,al</span><br><span class="line">        in al,71h</span><br><span class="line"></span><br><span class="line">        mov ah,al</span><br><span class="line">        mov cl,4</span><br><span class="line">        shr ah,cl</span><br><span class="line">        and al,00001111b</span><br><span class="line"></span><br><span class="line">        add ah,30h</span><br><span class="line">        add al,30h</span><br><span class="line"></span><br><span class="line">        mov bx,0b800h</span><br><span class="line">        mov es,bx</span><br><span class="line">        mov byte ptr es:[160*12+40*2],ah        ;显示月份的十位数码</span><br><span class="line">        mov byte ptr es:[160*12+40*2+2],al      ;接着显示月份的个位数码</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h2 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h2><p>要及时处理外设的输入，显然需要解决两个问题：</p>
<ul>
<li>外设的输入随时可能发生，CPU如何得知？</li>
<li>CPU从何处得到外设的输入？</li>
</ul>
<h3 id="接口芯片和端口"><a href="#接口芯片和端口" class="headerlink" title="接口芯片和端口"></a>接口芯片和端口</h3><p>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中;CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。CPU还可以向外设输出控制命令，而这些命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设设施控制。</p>
<h3 id="外中断信息"><a href="#外中断信息" class="headerlink" title="外中断信息"></a>外中断信息</h3><p>外设的输入随时可能发生，CPU如何得知？</p>
<ul>
<li>当CPU外部需要处理的事情发生时，相关的芯片将向CPU发出相应的中断信息，引发中断过程。</li>
</ul>
<p>在PC系统中，外中断源一共有以下两类：</p>
<ul>
<li>可屏蔽中断<ul>
<li>可屏蔽中断是CPU可以不响应的外中断</li>
<li>CPU是否响应可屏蔽中断看标志寄存器IF位的设置，IF=1则响应</li>
<li><code>sti</code>设置IF=1</li>
<li><code>cti</code>设置IF=0</li>
</ul>
</li>
<li>不可屏蔽中断<ul>
<li>不可屏蔽中断的中断类型码固定为2</li>
</ul>
</li>
</ul>
<h3 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h3><ul>
<li><ol>
<li>键盘输入<ul>
<li>键盘上每个键相当于一个开关，键盘中有一个芯片对键盘上每个键的开关状态进行扫描</li>
<li>按下一个键，开关接通，芯片产生一个能说明按下键的位置的扫描码。扫描码送入主板上相关接口芯片的寄存器中，该寄存器的端口地址为60h</li>
<li>松开按键时也会产生扫描码，也被送入60h端口</li>
<li>一般称按下产生的扫描码为通码，松开产生的扫描码为断码，通码的第7位为0，断码的第7位为1，即：<ul>
<li><strong>断码=通码+80h</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>引发9号中断<ul>
<li>键盘输入到达60h端口时，相关的芯片就会向CPU发出中断类型为9的可屏蔽中断信息</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>执行int 9中断例程<ul>
<li>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="编写int-9中断例程"><a href="#编写int-9中断例程" class="headerlink" title="编写int 9中断例程"></a>编写int 9中断例程</h3><p>键盘输入的处理过程：</p>
<ul>
<li><ol>
<li>键盘产生扫描码</li>
</ol>
</li>
<li><ol start="2">
<li>扫描码送入60h端口</li>
</ol>
</li>
<li><ol start="3">
<li>引发9号中断</li>
</ol>
</li>
<li><ol start="4">
<li>CPU执行int 9中断例程处理键盘输入<ul>
<li>从端口60h读入输入：<code>in al,60h</code></li>
<li>调用BIOS的int 9中断例程</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>BIOS提供的int 9中断例程已经对一些硬件细节进行了处理，我们只要在自己编写的中断例程中调用BIOS的int 9中断例程就可以自定义操作了。</p>
<p>编程：在屏幕中间依次显示a～z，按下Esc后改变显示的颜色</p>
<ul>
<li>首先为了能够看清，应该在显示一个字母后延时一段时间</li>
<li>将我们自己写的9号中断写入向量表，同时保存BIOS的int 9中断例程，以便之后调用<ul>
<li>这里将原来的int 9中断例程的偏移地址和段地址保存在ds:[0]和ds:[2]单元中</li>
</ul>
</li>
<li>模拟int来实现对我们写的新中断例程进行调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,stack</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,128</span><br><span class="line"></span><br><span class="line">        mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        push es:[9*4]</span><br><span class="line">        pop ds:[0]</span><br><span class="line">        push es:[9*4+2]</span><br><span class="line">        pop ds:[2]          ;将原来的int 9中断例程的入口地址保存在ds:0和ds:2单元中</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov ah,&#39;a&#39;</span><br><span class="line">s:      mov es:[160*12+40*2] ;显示</span><br><span class="line">        call delay</span><br><span class="line">        inc ah</span><br><span class="line">        cmp ah,&#39;z&#39;</span><br><span class="line">        jna s</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        push ds:[0]</span><br><span class="line">        pop es:[9*4]</span><br><span class="line">        push ds:[2]</span><br><span class="line">        pop es:[9*4+2]      ;将中断向量表中的int 9中断例程的入口地址恢复为原来的地址</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">delay:  push ax</span><br><span class="line">        push dx</span><br><span class="line">        mov dx,1000h</span><br><span class="line">        mov ax,0</span><br><span class="line">s1:     sub ax,1</span><br><span class="line">        sbb dx,0</span><br><span class="line">        cmp ax,0</span><br><span class="line">        jne s1</span><br><span class="line">        cmp dx,0</span><br><span class="line">        jne s1</span><br><span class="line">        pop dx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br><span class="line">; -------新int 9中断例程--------</span><br><span class="line">int9:   push ax</span><br><span class="line">        push bx</span><br><span class="line">        push es</span><br><span class="line"></span><br><span class="line">        in al,60h</span><br><span class="line"></span><br><span class="line">        pushf</span><br><span class="line">        pushf</span><br><span class="line">        pop bx</span><br><span class="line">        and bh,111111100b</span><br><span class="line">        push bx</span><br><span class="line">        popf</span><br><span class="line">        call dword ptr ds:[0]   ;对int指令进行模拟，调用原来的int 9中断例程</span><br><span class="line"></span><br><span class="line">        cmp al,1</span><br><span class="line">        jne int9ret</span><br><span class="line"></span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        inc byte ptr es:[160*12+40*2+1] ;段地址控制的文本显示的信息，改变颜色</span><br><span class="line"></span><br><span class="line">int9ret:pop es</span><br><span class="line">        pop bx</span><br><span class="line">        pop ax</span><br><span class="line">        iret</span><br><span class="line">code ens</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


<h2 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h2><h3 id="描述了单元长度的标号"><a href="#描述了单元长度的标号" class="headerlink" title="描述了单元长度的标号"></a>描述了单元长度的标号</h3><p>之前的程序中，标号仅仅表示了内存单元的地址。但是我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示此单元是一个字节单元，还是双字单元。如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    a db 1, 2, 3, 4, 5, 6, 7, 8         ;a、b后面没有&quot;:&quot;，它们是同时描述内存地址和单元长度的标号</span><br><span class="line">    b dw 0                              ;标号a描述了地址code:0，以后的单元都是字节单元;标号b表述了地址code:8，以后的字单元</span><br><span class="line"></span><br><span class="line">start:  mov si,0</span><br><span class="line">        mov cx,8</span><br><span class="line">s:      mov al,a[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add b,ax</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>因此这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。对于程序中的<code>b dw 0</code></p>
<ul>
<li>指令：<code>mov ax,b</code>相当于：<code>mov ax,cs:[8]</code></li>
<li>指令：<code>mov b,2</code>相当于：<code>mov word ptr cs:[8],2</code></li>
<li>指令：<code>inc b</code>相当于：<code>inc word ptr cs:[8]</code></li>
</ul>
<p>使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。我们称这种标号为数据标号。</p>
<h3 id="在其他段中使用数据标号"><a href="#在其他段中使用数据标号" class="headerlink" title="在其他段中使用数据标号"></a>在其他段中使用数据标号</h3><p>下面程序将data段中a标号处8个数据累加，结果储存在b中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">    a db 1, 2, 3, 4, 5, 6, 7, 8         </span><br><span class="line">    b dw 0                              </span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax,data</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,8</span><br><span class="line">s:      mov al,a[si]</span><br><span class="line">        mov ah,0</span><br><span class="line">        add b,ax</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：后面加有”:”的地址标号只能在代码段中使用，不能在其他代码段中使用。</li>
<li>如果想在代码段中直接使用数据标号访问数据，则需要用伪命令assume将标号所在的段和一个段寄存器联系起来<ul>
<li>只是编译器的工作需要，类系c语言中要有函数原型，assume并没有将段寄存器和某个段相联系</li>
<li>我们在程序中还要使用指令对寄存器进行设置</li>
</ul>
</li>
</ul>
<p>对于这个程序，编译器对相关指令的编译如下：</p>
<ul>
<li>指令：<code>mov al,a[si]</code>，编译为<code>mov al,ds:[si+0]</code></li>
<li>指令：<code>mov b,ax</code>，编译为<code>mov ds:[8],ax</code></li>
<li>在执行这些指令前，ds必须为data的段地址<code>mov ax,data;mov ds,ax</code></li>
</ul>
<h3 id="直接定址表-1"><a href="#直接定址表-1" class="headerlink" title="直接定址表"></a>直接定址表</h3><p>我们希望对数据建立某种映射关系，如果我们直接使用条件判断语句明显是可行的。但程序将要执行多条比较、转移指令。程序混乱。</p>
<p>因此我们可以建立一张表。假设我们要一次储存字符”0”<del>“F”，我们可以通过0</del>15直接查找对应字符。使用如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table db &#39;0123456789ABCDE&#39;</span><br><span class="line"></span><br><span class="line">mov ah,table[bx]</span><br><span class="line">等等</span><br></pre></td></tr></table></figure>

<p>以数值N为table表中的偏移，可以找到对应的字符</p>
<p>利用表，两个数据集合之间建立了一种映射关系，使我们可以用查表的方法根据给出的数据的到其在另一个集合中的对应数据。这样做的目的一般有以下3个：</p>
<ul>
<li>为了算法的清晰和简洁</li>
<li>为了加快运算速度<ul>
<li>如我们可以直接保存常见的三角函数，而不必计算</li>
</ul>
</li>
<li>为了使程序易于扩充</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>seg操作符，功能为取得某一标号的段地址</li>
<li>lea操作符，是mov的变种，功能为取有效地址(Load effect address)，即取偏移地址<ul>
<li>格式: lea 目的,源</li>
<li>leaw，两个字节</li>
<li>leal，4个字节</li>
<li>leaq，8个字节</li>
</ul>
</li>
<li>leave操作符，功能为将寄存器ebp(保留栈底指针)的内容复制到esp(保留栈顶指针)中，然后从栈中恢复ebp寄存器的旧值</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/universe/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/universe/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url">密码学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-04T00:00:00+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="密码学和数据安全导论"><a href="#密码学和数据安全导论" class="headerlink" title="密码学和数据安全导论"></a>密码学和数据安全导论</h2><p>可靠的密码体制必须遵守Auguste Kerekhoffs在1883年提出的一个假说，即Kerekhoffs原理:</p>
<blockquote>
<p>即使密钥外的整个系统的一切都是公开的，这个密码体制也必须是安全的。尤其是即使攻击者知道系统的加密算法和解密算法，此系统也必须是安全的。</p>
</blockquote>
<p>需要强调的是，设计上一个隐藏细节的系统看似是更安全的。但是历史经验告诉我们这样的系统其实是很脆弱的，系统的细节可以通过逆向工程破解。这就是说为什么即使攻击者知道加密算法，加密方案仍必须保持安全的原因。</p>
<h3 id="模运算与多种古典密码"><a href="#模运算与多种古典密码" class="headerlink" title="模运算与多种古典密码"></a>模运算与多种古典密码</h3><h4 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h4><p>几乎所有的加密算法都是基于有限个元素的运算。模运算就是在有限个数集中执行运算的简单方法：</p>
<p>定义：模运算</p>
<blockquote>
<p>假设$a, r, m \in Z$(其中Z是所有整数的集合)，并且m&gt;0。如果m除a-r，可记作：<br>$$a \equiv r \bmod m$$<br>其中m称为模数，r称为余数</p>
</blockquote>
<blockquote>
<p>其中$a \equiv b (\bmod m)$表示a与b对于m同余</p>
</blockquote>
<h5 id="等价类中所有成员的等价行为"><a href="#等价类中所有成员的等价行为" class="headerlink" title="等价类中所有成员的等价行为"></a>等价类中所有成员的等价行为</h5><p>对于一个给定模数m，选择等价类中任何一个元素用于计算的结果都是一样的。因此我们可以选择等价类中最易于计算的一个元素进行模运算</p>
<p>计算$3^8$模7的的结果：</p>
<ul>
<li>$3^8 = 6561 \equiv 2 \bmod 7$</li>
<li>下面使用等价类进行计算<br>$$3^8 = 3^4 \cdot 3^4 = 81 \cdot 81$$</li>
<li>然后将中间结果的81替换为同一等价类中的其他元素。在模数7的等价类中，最小的正元素是4(因为$81 = 11 \cdot 7 + 4$)，因此：<br>$$3^8 = 3^4 \cdot 3^4 \equiv 4 \cdot 4 \equiv 16 \bmod 7 \equiv 2 \bmod 7$$</li>
</ul>
<p>通用的规则是：应该尽量使用模化简，使计算的数值尽可能小，这样做总是极具计算优势</p>
<h4 id="整数环"><a href="#整数环" class="headerlink" title="整数环"></a>整数环</h4><p>定义：环</p>
<blockquote>
<p>整数环$Z_m$由以下两部分组成：</p>
<ul>
<li><ol>
<li>集合$Z_m = (0, 1, 2, …, m-1)$</li>
</ol>
</li>
<li><ol start="2">
<li>两种操作”+”和”×”，使得所有的$a, b \in Z_m$有<ul>
<li>1)$a + b \equiv c \bmod m, (c \in Z_m)$</li>
<li>2)$a \times b \equiv d \bmod m, (d \in Z_m)$</li>
</ul>
</li>
</ol>
</li>
</ul>
</blockquote>
<p>环具有以下特征：</p>
<ul>
<li>如果环内任何两个数相加或相乘得到的结果始终在环内，那么这个环是封闭的</li>
<li>加法和乘法是可结合的，例如对所有的$a, b, c \in Z_m$，都有$a + (b+c) = (a+b) + c$和$a \cdot (b \cdot c) = (a \cdot b) \cdot c$</li>
<li>加法中存在中性元素0，使得对每个$a \in Z_m$都有$a + 0 \equiv a \bmod m$</li>
<li>环中的任何元素a都存在一个负元素-a，使得$a + (-a) \equiv 0 \bmod m$，即加法逆元始终存在</li>
<li>乘法中存在中性元素1，使得对每个$a \in Z_m$都有$a \times 1 \equiv a \bmod m$</li>
<li>不是所有元素都存在乘法逆元，假设$a \in Z$，乘法逆元$a^{-1}$可以定义为：<br>$$a \times a^{-1} = 1 \mod m$$<br>如果某个元素的乘法逆元存在，则可以除以这个元素，因为$b/a \equiv b \cdot a^{-1} \bmod m$</li>
<li>寻找逆元比较困难，可以通过一种简单的方法判断一个元素a的逆元是否存在：<ul>
<li>当且仅当$gcd(a, m) = 1$，一个元素$a \in Z$存在乘法逆元$a^{01}$，其中gcd表示最大公约数(Greatest Common divisor)，$gcd(a, m) = 1$就表示a和m(模数)互质</li>
</ul>
</li>
</ul>
<h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><p>仿射密码是一种改善的移位密码，仿射密码的思路是将明文密码乘以密钥的一部分，然后再加上密钥的剩余部分</p>
<p>定义：仿射加密</p>
<blockquote>
<p>假设$x, y ,a, b \in Z_26$(26个字母)</p>
<p>加密：$e_k(x) = y \equiv a \cdot x + b \bmod 26$</p>
<p>解密：$d_k(y) = x \equiv a^{-1} \cdot (y-b) \bmod 26$</p>
<p>密钥为：$k = (a, b)$，且满足限制条件gcd(a, 26)=1</p>
</blockquote>
<p>gcd(a, 26)=1 这个限制是源于这样一个事实：加密时需要求密钥参数a的逆元。</p>
<p>通过尝试所有$a^{-1}$的可能值，直到$a \cdot a^{-1} \equiv 1 \bmod 26$即可得到逆元</p>
<p>因此仿射加密的确比移位加密复杂，但也是可暴力破解的<br>$$密钥空间 = (a的可能值) \times (b的可能值)$$</p>
<h2 id="序列密码"><a href="#序列密码" class="headerlink" title="序列密码"></a>序列密码</h2><p>对称密码学分成分组密码和序列密码两部分</p>
<ul>
<li>序列密码<ul>
<li>单独加密每个位</li>
</ul>
</li>
<li>分组密码<ul>
<li>每次使用相同的密钥加密整个明文位分组</li>
</ul>
</li>
</ul>
<h3 id="序列密码加密与解密"><a href="#序列密码加密与解密" class="headerlink" title="序列密码加密与解密"></a>序列密码加密与解密</h3><p>定义：序列密码</p>
<blockquote>
<p>明文、密文和密钥序列都是由单独的位组成，即$x_i, y_i, s_i \in {0, 1}$</p>
<p>加密：$y_i \equiv x_i + s_i \bmod 2$</p>
<p>解密：$x_i \equiv y_i + s_i \bmod 2$</p>
</blockquote>
<p>加密解密推导：加密和解密用的是相同的函数</p>
<p>$$\begin{aligned}<br>d(y_i) &amp;\equiv y_i + s_i \bmod 2 \<br>&amp;\equiv x_i + s_i + s_i \bmod 2 \<br>&amp;\equiv x_i + 2s_i \bmod 2 \<br>&amp;\equiv x_i + 0 \bmod 2 \<br>&amp;\equiv x_i \bmod 2 \<br>\end{aligned}$$</p>
<p>下面给出模2加法的真值表</p>
<table>
<thead>
<tr>
<th>$x_i$</th>
<th>$s_i$</th>
<th>$y_i \equiv x_i + s_i \bmod 2$</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>事实上模2加法与异或XOR是等价的，密文为0或1的概率是完全相等的</p>
<p>密钥序列$s_1, s_2, …,s_i$是序列密码安全的核心问题，在攻击者看来$s_i$必须的随机的</p>
<h3 id="随机数与牢不可破的分组密码"><a href="#随机数与牢不可破的分组密码" class="headerlink" title="随机数与牢不可破的分组密码"></a>随机数与牢不可破的分组密码</h3><h4 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h4><ul>
<li>真随机数生成器(TRNG)<ul>
<li>TRNG的突出特征是它是输出是不可复制的<ul>
<li>如拋100次硬币，世界上另一个人抛出和我相同的结果概率很低</li>
</ul>
</li>
<li>TRNG都是基于物理过程，主要例子包括抛硬币等</li>
</ul>
</li>
<li>(通用的)伪随机数生成器(PRNG)<ul>
<li>PRNG从一个初始种子值开始通过各种计算得到序列</li>
<li>PRNG并不是真正意义上的随机，因为它们是可以算出来的</li>
<li>对PRNG的一个一般要求是：必须有良好的统计属性<ul>
<li>即它的输出与真随机数序列相同</li>
</ul>
</li>
</ul>
</li>
<li>加密安全的伪随机数生成器(CSPRNG)<ul>
<li>是一种不可预测的PRNG，即计算后续位在计算上是不可行的</li>
</ul>
</li>
</ul>
<h4 id="一次一密"><a href="#一次一密" class="headerlink" title="一次一密"></a>一次一密</h4><p>一个完美的密钥应该具有的特征：无条件安全。定义如下</p>
<blockquote>
<p>如果一个密码体制在无限计算资源的情况下也不能被破译，则说明它是无条件安全的或信息论上安全的</p>
</blockquote>
<p>一下是个简单的无条件安全的密码，这个密码是<strong>一次一密(OTP)</strong>，定义如下</p>
<blockquote>
<p>一个序列密码成为一次一密，必须满足一下条件：</p>
<ul>
<li><ol>
<li>通过真随机数生成器得到密钥序列$s_1, s_2, …$</li>
</ol>
</li>
<li><ol start="2">
<li>只有合法的通信方才知道密钥序列</li>
</ol>
</li>
<li><ol start="3">
<li>每个密钥序列位$s_i$仅使用一次<br>一次一密是无条件安全的</li>
</ol>
</li>
</ul>
</blockquote>
<p>证明OTP是无条件安全的方法如下</p>
<p>$$\begin{aligned}<br>y_0 &amp;\equiv x_0 + s_0 \bmod 2 \<br>y_1 &amp;\equiv x_1 + s_1 \bmod 2 \<br>…<br>\end{aligned}$$</p>
<p>每个单独的关系都是有两个未知数的线性等式模2,它们无法求解</p>
<p>OTP缺点如下，导致它在实际中很少使用：</p>
<ul>
<li>需要真随机数生成器</li>
<li>每个密钥序列使用一次，需要多次交换密钥序列</li>
</ul>
<h4 id="关于实际序列密码"><a href="#关于实际序列密码" class="headerlink" title="关于实际序列密码"></a>关于实际序列密码</h4><p>我们处理实际序列密码的方式就是使用伪随机数生成器(PRNG)代替真随机数生成器。实际上，所有已知的实际加密算法都不是无条件安全的。但是我们可以做到 <strong>计算安全</strong> </p>
<p>定义：计算安全</p>
<blockquote>
<p>如果为破解一个密码体制，最好的一直算法需要至少t个操作，则说明次密码体制是计算安全的</p>
</blockquote>
<p>这个定义看似合理但是存在若干问题。首先人们不知道对应的最好算法是哪一个，因此我们不知道是否存在更强大的攻击。</p>
<h5 id="利用PRNG构建密码流"><a href="#利用PRNG构建密码流" class="headerlink" title="利用PRNG构建密码流"></a>利用PRNG构建密码流</h5><p>虽然PRNG可以用来生成密钥流，但对于序列密码而言都不足够，考虑下面的例子：</p>
<p>假设一个基于线性同余生成器的PRNG：</p>
<p>$$\begin{aligned}<br>S_0 &amp;\equiv  seed \<br>S_{i+1} &amp;\equiv AS_i + B \bmod m, i = 0, 1, … \<br>\end{aligned}$$</p>
<p>设其中选择的m为100位长，$S_i, A, B \in {0, 1, …, m-1}$，我们通过仔细选择这些参数是的此PRNG具有良好的统计属性。密钥包含值(A, B)，可可能包含种子$S_0$，并且每个值的长度都是100，总共密钥长度就为200位。发送方使用一下方式加密：</p>
<p>$$y_i \equiv x_i + s_i \bmod 2$$</p>
<p>其中$s_i$为PRNG输出符号$S_j$的二进制表示的位</p>
<p>攻击者可以轻易发起攻击，如果攻击者知道明文的前300位(通过头文件、常用语等猜出部分明文)。那他可以利用下式计算密钥序列的前300位：</p>
<p>$$s_i \equiv y_i + x_i \bmod m, i = 1, 2, …, 300$$</p>
<p>于是就得到了:$S_1 = {s_1, …, s_{100}}, S_2 = {s_1, …, s_{200}}, S_3 = {s_3, …, s_{300}}$。攻击者现在可以得到两个等式：</p>
<p>$$\begin{aligned}<br>S_2 \equiv AS_1 + B \bmod m \<br>S_3 \equiv AS_2 + B \bmod m<br>\end{aligned}$$</p>
<p>对于一个基于$Z_m$的线性等式系统，拥有两个未知数A，B，我们可以得到：</p>
<p>$$\begin{aligned}<br>A &amp;\equiv (S_2 - S_3)/(S_1 - S_2) \bmod m \<br>B &amp;\equiv S_2 - S_1(S_2 - S_3)/(S_1 - S_2) \bmod m<br>\end{aligned}$$</p>
<p>在$gcd((S_1 - S_2), m) \neq 1$情况下可以得到多个解，如果已知明文的第四片段信息就可以唯一测出密钥。</p>
<p>这种类型的攻击正是发明CSPRNG表示方法的原因</p>
<h5 id="利用CSPRNG构建密钥序列"><a href="#利用CSPRNG构建密钥序列" class="headerlink" title="利用CSPRNG构建密钥序列"></a>利用CSPRNG构建密钥序列</h5><p>CSPRNG可以确保密钥序列是不可预测的，但是相当一部分在密码学之外的伪随机数生成器不是密码学安全的，因此我们需要使用专门的伪随机数生成器来生成密码序列</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/01/universe/vimscript_backup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/01/universe/vimscript_backup/" itemprop="url">vimscript学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-01T00:00:00+08:00">
                2020-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Remenber to use <code>:h &lt;arg&gt;</code> for help</p>
<h2 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h2><ul>
<li><code>let</code> to init or assignment a variable(call it var below)</li>
<li><code>unlet</code> to delete a var</li>
<li><code>unlet</code> to delete a var and ignore warnning, if var did not exist</li>
</ul>
<p>You can add a prefix before :var to define its scope, like this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g:var  # as global</span><br><span class="line">a:var  # as a function arg</span><br><span class="line">l:var  # as a function var</span><br><span class="line">b:var  # as buffer var</span><br><span class="line">w:var  # as window var</span><br><span class="line">t:var  # as tab var</span><br><span class="line">s:var  # as script var, which useful in this script only</span><br><span class="line">v:var  # as vim build-in var</span><br></pre></td></tr></table></figure>

<h2 id="Data-type"><a href="#Data-type" class="headerlink" title="Data type"></a>Data type</h2><ul>
<li>Number</li>
<li>Float</li>
<li>String</li>
<li>Funcref<ul>
<li>reference of a function</li>
<li><code>let func = function(&quot;strlen&quot;)</code></li>
</ul>
</li>
<li>List</li>
<li>Dictionary</li>
</ul>
<h2 id="String-comparison"><a href="#String-comparison" class="headerlink" title="String comparison"></a>String comparison</h2><ul>
<li><code>&lt;string&gt; == &lt;string&gt;</code> equal</li>
<li><code>&lt;string&gt; != &lt;string&gt;</code> not equal</li>
<li><code>&lt;string&gt; =~ &lt;pattern&gt;</code> matching pattern</li>
<li><code>&lt;string&gt; !~ &lt;pattern&gt;</code> not matching pattern</li>
<li><code>&lt;operator&gt;#</code> matching with case</li>
<li><code>&lt;operator&gt;?</code> matching with ignorecase</li>
</ul>
<p><code>&lt;string&gt;.&lt;string&gt;</code> to connect string</p>
<h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><p><code>If, For, While, Try/Catch</code></p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>Use <code>function</code> keywork to define a function, use <code>function!</code> to overwire a function. Be attention, function need to begin with capital letter.</p>
<ul>
<li><code>delfunction &lt;function&gt;</code> to delete a function</li>
<li><code>call &lt;function&gt;</code> to call a function </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/14/universe/the_nature_of_code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/14/universe/the_nature_of_code/" itemprop="url">用processing模拟自然系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-14T00:00:00+08:00">
                2020-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="随机游走"><a href="#随机游走" class="headerlink" title="随机游走"></a>随机游走</h2><ul>
<li>processing中的random()函数生成的随机数是均匀分布的</li>
<li>可以利用random函数生成非均匀分布的随机数<ul>
<li>创建一个非均匀的数组，用random来随机的取索引</li>
</ul>
</li>
<li>也可用random来取概率，但是注意数据类型(float和int有区别)</li>
<li>随机数的正态分布<ul>
<li><code>(float)generator.nextGaussian()</code>返回一个高斯随机数，nextGaussian返回值的类型是double</li>
</ul>
</li>
</ul>
<h3 id="Perlin噪声-一种更平滑的算法"><a href="#Perlin噪声-一种更平滑的算法" class="headerlink" title="Perlin噪声(一种更平滑的算法)"></a>Perlin噪声(一种更平滑的算法)</h3><p>Perlin生成的随机数更平滑，但仍有一定的随机性。</p>
<p>Processing内置了<code>noise()</code>函数，可以有1~3个参数。<br>分别表示一维、二维、三维随机数。</p>
<p>noise函数返回的结果总是在0~1之间，我们可以通过map函数来改变结果的范围，<br>可以吧一维的Perlin噪声当作随着时间推移而发生变化的线性序列。<br>通过往noise传入一个”指定的时间”来获取这个时间点上的噪声。</p>
<p>同理，二维噪声像个崎岖不平的面</p>
<h3 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h3><p><code>map(a, b, c, d)</code>, 原范围(a, b), 希望映射到的范围(c, d)</p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
