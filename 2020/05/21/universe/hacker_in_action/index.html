<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前置知识：汇编语言 系统篇栈溢出缓冲区是一片有限的、连续的内存区域。在C语言中最常见的缓冲区是数组。 因为在C和C++语言中没有考虑检查缓冲区的内在边界，所以使栈溢出成为可能。当输入的数据足够大时，将会溢出缓冲区的范围，从而改写从而改写其他缓存区域。 函数与栈调用函数的整个过程如下   把函数的参数压入栈    把函数的返回地址压入栈 主程序调用子程序，子程序结束后继续上次的位置执行主程序">
<meta property="og:type" content="article">
<meta property="og:title" content="黑客攻防学习">
<meta property="og:url" content="http://yoursite.com/2020/05/21/universe/hacker_in_action/index.html">
<meta property="og:site_name" content="Ring&#39;s Blog">
<meta property="og:description" content="前置知识：汇编语言 系统篇栈溢出缓冲区是一片有限的、连续的内存区域。在C语言中最常见的缓冲区是数组。 因为在C和C++语言中没有考虑检查缓冲区的内在边界，所以使栈溢出成为可能。当输入的数据足够大时，将会溢出缓冲区的范围，从而改写从而改写其他缓存区域。 函数与栈调用函数的整个过程如下   把函数的参数压入栈    把函数的返回地址压入栈 主程序调用子程序，子程序结束后继续上次的位置执行主程序">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-05-20T16:00:00.000Z">
<meta property="article:modified_time" content="2020-06-15T13:34:14.478Z">
<meta property="article:author" content="Travis TuRing">
<meta property="article:tag" content="hacker,汇编">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/05/21/universe/hacker_in_action/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>黑客攻防学习 | Ring's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ring's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/21/universe/hacker_in_action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Travis TuRing">
      <meta itemprop="description" content="Mens et Manus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ring's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          黑客攻防学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-21T00:00:00+08:00">2020-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 21:34:14" itemprop="dateModified" datetime="2020-06-15T21:34:14+08:00">2020-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>前置知识：汇编语言</p>
<h1 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h1><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>缓冲区是一片有限的、连续的内存区域。在C语言中最常见的缓冲区是数组。</p>
<p>因为在C和C++语言中没有考虑检查缓冲区的内在边界，所以使栈溢出成为可能。当输入的数据足够大时，将会溢出缓冲区的范围，从而改写从而改写其他缓存区域。</p>
<h3 id="函数与栈"><a href="#函数与栈" class="headerlink" title="函数与栈"></a>函数与栈</h3><p>调用函数的整个过程如下</p>
<ul>
<li><ol>
<li>把函数的参数压入栈</li>
</ol>
</li>
<li><ol start="2">
<li>把函数的返回地址压入栈<ul>
<li>主程序调用子程序，子程序结束后继续上次的位置执行主程序</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>调用函数</li>
</ol>
</li>
</ul>
<p>为了使函数可以引用栈上的数据，必须改变栈底指针EBP的值，把EBP的当前值压入栈，把当前的栈顶ESP复制到EBP，函数接受后再恢复。这样我们就可以方便地引用栈地址了。</p>
<p>接着编译器计算函数的局部变量所需的地址空间和栈上的保留空间，然后从ESP减去变量的大小，为程序保留必要的空间，最后把函数的局部变量压入栈(这我们举例：数组)。结构如下：</p>
<table>
<thead>
<tr>
<th>低内存地址，栈顶</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
</tr>
<tr>
<td>EBP</td>
</tr>
<tr>
<td>RET</td>
</tr>
<tr>
<td>参数</td>
</tr>
<tr>
<td>高内存地址，栈底</td>
</tr>
</tbody></table>
<h3 id="栈上的缓冲区溢出"><a href="#栈上的缓冲区溢出" class="headerlink" title="栈上的缓冲区溢出"></a>栈上的缓冲区溢出</h3><p>由上述结构可见，如果数组很大，将会溢出，然后改写其他缓存区域。</p>
<ul>
<li>控制EIP<ul>
<li>CPU执行什么指令由CS:IP的指向决定</li>
<li>我们只要精心设计溢出的数据，这些地址将写入缓冲器并改写保留在缓冲区的EBP和RET。当系统从栈中取出RET的值并放入EIP时，这个地址指向的指令将被执行。</li>
</ul>
</li>
</ul>
<h3 id="利用漏洞获得root权限"><a href="#利用漏洞获得root权限" class="headerlink" title="利用漏洞获得root权限"></a>利用漏洞获得root权限</h3><p>我们可以攻击以root权限运行的进程，通过溢出强制它执行shell，这个shell将继承root权限。然而缓冲区只认得机器指令(opcode)。为了把opcode插入缓存区，必须吧派生的shell的C代码编译成汇编指令，然后从可读的汇编指令中提取opcode。这些被称为shellcode或opcode的代码可以注入缓冲区，并可执行。</p>
<h4 id="地址问题"><a href="#地址问题" class="headerlink" title="地址问题"></a>地址问题</h4><p>当试图执行用户提交的shellcode时，所面临的问题是找出shellcode的起始地址。(想办法使EIP指向这个地址)</p>
<p>先介绍一种使用最广的方法：猜。每个程序的栈都以同样的地址开始。(现在大多数操作系统故意变化栈地址，从而使这类的攻击变得困难)知道这个地址就可以猜测shellcode的起始地址和RET的地址。</p>
<ul>
<li>首先要知道ESP的地址，那么根据这个地址来猜测当前地址和shellcode之间的偏移距离。从而的到shellcode的起始地址</li>
<li>通过尝试输入过长数据造成溢出，从造成故障的长度来猜测RET地址</li>
<li>最后把RET地址改为shellcode的起始地址以达到执行shellcode的目的</li>
</ul>
<p><strong>例1</strong> ：简单试炼，破解以下程序，假设我们不知道被攻击程序的内部结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// victim.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="built_in">array</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果每个程序的栈都是以同样的地址开始，则固定的程序RET地址不会改变，我们可以通过溢出找出RET地址<ul>
<li><code>$ ./victim.c $(printf &quot;%0524&quot; 0)</code>利用bash快速尝试输入多个0(长数据)</li>
</ul>
</li>
<li>假设我们的shellcode有40B，上一步在524个数据时溢出，那么我们可以将上一步的长数据改成<code>shellcode+(524-len(shellcode))个0+shellcode起始地址</code><ul>
<li>这里还没获得shellcode起始地址，我们先用别的地址测试填充0的个数是否正确</li>
</ul>
</li>
</ul>
<p>building…</p>
<h4 id="NOP法"><a href="#NOP法" class="headerlink" title="NOP法"></a>NOP法</h4><p>一个个猜太过麻烦，可以选用NOP法来增加潜在的偏移量的数量。思路就是创建一大段不运行的指令区，放在shellcode前面，当执行完NOP之后，就会执行shellcode。这样就不用精确地猜到偏移量了。</p>
<h3 id="战胜不可执行栈"><a href="#战胜不可执行栈" class="headerlink" title="战胜不可执行栈"></a>战胜不可执行栈</h3><p>前面所讲的漏洞利用程序能工作，是因为可以在栈上执行指令。许多操作系统不允许在栈上执行代码。当遇到不可执行栈的时候，可以用”返回libc”方法。</p>
<p>栈溢出原理上其实是利用了EIP指针，那么如果我们可以完全EIP指针，那么就可以把任意想执行的代码放入EIP。返回libc是把控制权交给特定的动态库函数。动态库函数不在栈上，所以我们就可以绕开不可执行栈的限制。</p>
<p>为了攻击成功，需要仔细挑选动态库函数。理论上，它必须符合以下两个条件：</p>
<ul>
<li>它必须的常见的动态库函数，在绝大多数程序中出现，才便于利用</li>
<li>函数库里的函数应该给予我们很大的灵活性，以便我们能派生shell或做其他事</li>
</ul>
<p>libc就是满足条件的一个库函数。我们只要把执行流程指向想用的库函数的地址，它将被执行。</p>
<p>以下以派生shell讨论。最好用的libc函数是system()。system()接受一个参数，然后用/bin/sh/执行这个参数。根据经验主程序执行一个函数(设为func)时，参数入栈的顺序和它在代码里的顺序相反，根据这点，我们需要进行以下工作：</p>
<ul>
<li>确定system()地址<ul>
<li>主程序执行一个函数func时，call func，会把返回地址RET压入栈</li>
</ul>
</li>
<li>确定/bin/sh地址(参数地址)<ul>
<li>第一个参数位于RET之后</li>
</ul>
</li>
<li>找出exit()地址，以便干净地退出被攻击的程序</li>
</ul>
<p>用memfetch工具可以找到/bin/sh的地址，memfetch的功能是把指定进程的内存数据全部转存到一个二进制文件中，我们可以在这个文件里找/bin/sh的地址</p>
<p>破解过程如下：</p>
<ul>
<li><ol>
<li>用垃圾数据填满缓冲区和返回地址之间的空间</li>
</ol>
</li>
<li><ol start="2">
<li>用system()的地址改写返回地址</li>
</ol>
</li>
<li><ol start="3">
<li>在system()后加上exit()的地址</li>
</ol>
</li>
<li><ol start="4">
<li>再加上/bin/sh的地址</li>
</ol>
</li>
</ul>
<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>shellcode是一组可注入(机械码)的程序，可以在被攻击的程序里运行。因为shellcode要直接操作寄存器和程序的函数，所以通常用汇编语言编写并翻译为十六进制操作码。之所以叫shellcode是因为通常用这种操作来派生root权限的shell。</p>
<h3 id="理解系统调用"><a href="#理解系统调用" class="headerlink" title="理解系统调用"></a>理解系统调用</h3><p>我们想让目标程序不同于设计者预期的方式运行，而操纵程序的方法之一是强制它产生系统调用(中断)。可以通过系统调用访问特定的操作系统的函数，如接受输入、处理输出、退出进程、执行二进制文件等。</p>
<p>通过系统调用可以直接访问系统内核，即可以访问读写文件之类的低级函数。系统调用也是受保护的内核模式与用户模式之间的接口。受保护的内核模式会阻止用户的应用程序干涉或危及操作系统。当用户模式下的程序企图访问内核的内存空间时，系统将产生异常。但是，某些程序在正常运行时，需要请求一些系统级的服务，这时系统调用就作为正常用户模式和内核模式之间的接口，在保证安全的情况下尽量相应这些请求。</p>
<p>在Linux里有两种方法来执行系统调用：</p>
<ul>
<li>间接方法：C库函数(libc)</li>
<li>直接方法：汇编指令(把适当的参数加载到寄存器，然后调用中断)执行系统调用</li>
</ul>
<p>在Linux里，程序通过<code>int 0x80</code>软中断来执行系统调用。当程序在用户模式下执行<code>int 0x80</code>时，CPU切换到内核模式并执行相应的系统调用。系统调用的过程如下：</p>
<ul>
<li><ol>
<li>把系统调用编号载入EAX，通过载入编号来调用对应系统函数</li>
</ol>
</li>
<li><ol start="2">
<li>把系统调用的参数压入其它寄存器</li>
</ol>
</li>
<li><ol start="3">
<li>执行<code>int 0x80</code>指令</li>
</ol>
</li>
<li><ol start="4">
<li>CPU切换到内核模式</li>
</ol>
</li>
<li><ol start="5">
<li>执行系统函数</li>
</ol>
</li>
</ul>
<p>思考下列程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -static -o exit exit.c</span></span><br></pre></td></tr></table></figure>

<p>反汇编生成的二进制文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gdb exit</span><br><span class="line">(gdb) disas _exit</span><br><span class="line">address &lt;line&gt;: mov 0x4(%esp,1),%ebx</span><br><span class="line">address &lt;line&gt;: mov $Oxfc,%eax          ;对应的系统调用编号被放入%EAX中</span><br><span class="line">address &lt;line&gt;: int $0x80               ;通过int 0x80指令得知发生了系统调用</span><br><span class="line">address &lt;line&gt;: mov $0x1,%eax           ;对应的系统调用编号被放入%EAX中</span><br><span class="line">address &lt;line&gt;: int $0x80</span><br><span class="line">address &lt;line&gt;: hlt</span><br><span class="line">address &lt;line&gt;: nop</span><br></pre></td></tr></table></figure>

<p>exit()对应的系统调用编号是1，exit_group()对应的系统调用编号是252。在反汇编生成的代码里还有一条指令，它把系统调用的参数加载到EBX。这个参数是0，是在系统调用之前入栈的<code>mov 0x4(%esp,1),%ebx</code></p>
<p><code>int 0x80</code>指令把CPU切换到内核模式，并且执行系统调用</p>
<h3 id="为exit-系统调用写shellcode"><a href="#为exit-系统调用写shellcode" class="headerlink" title="为exit()系统调用写shellcode"></a>为exit()系统调用写shellcode</h3><blockquote>
<p>较小的shellcode可以注入更多的缓冲区，可以用来攻击更多的程序，所以要使shellcode尽量保持简单、紧凑。当攻击问题程序的时候，不仅要把shellcode复制到缓冲区，如果碰到n字节长的缓冲区，不仅要把整个shellcode复制到它里面，还要加上调用shellcode的指令，因此shellcode的长度必须小于n。基于这个原因，shellcode应尽量小。</p>
</blockquote>
<p>因为实际环境中，shellcode没有其他指令为它设置参数，所以我们要精心设计。在上面exit()例子里，通过把0放入EBX可以达到设置的目的。所以我们的shellcode应该完成以下任务：</p>
<ul>
<li><ol>
<li>把0存到EBX<ul>
<li>参数</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>把1存到EAX<ul>
<li>系统调用编号</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>执行<code>int 0x80</code>指令来产生系统调用</li>
</ol>
</li>
</ul>
<p>先用汇编指令实现这3步，的到ELF格式的二进制文件，然后从这个二进制文件中提取操作码。</p>
<ul>
<li>生成目标文件</li>
<li>链接目标文件</li>
<li>从生成的文件提取操作码</li>
</ul>
<h3 id="可注入的shellcode"><a href="#可注入的shellcode" class="headerlink" title="可注入的shellcode"></a>可注入的shellcode</h3><p>攻击时，最有可能用来保存shellcode的内存区域是为了保存用户输入而分配的缓冲区，甚至可以更进一步将，这个缓冲区就是一个数组。所以如果shellcode中有空值(0x00)的存在，当把shellcode复制到缓冲区(字符数组)的时候会出现异常，因为数组里空值是用来终止字符串的。所以我们要想办法把空值去掉，或把有空值的操作码转换成非空值的操作码。下面介绍一种方法：</p>
<ul>
<li>直接用其他具有相同功能的指令代替这些产生空值的指令</li>
</ul>
<p>如果直译，shellcode使用如下汇编指令和对应的操作码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ebx,0       ;\xbb\x00\x00\x00\x00</span><br><span class="line">mov eax,1       ;\xb8\x00\x00\x00\x00</span><br><span class="line">int 0x80        ;\xcd\x80</span><br></pre></td></tr></table></figure>

<p>头两条是产生空值的罪魁祸首，我们可以用如下操作解决：</p>
<ul>
<li>第一条指令，我们可以用<code>xor</code>指令在不涉及空值的情况下给ebx赋值<ul>
<li><code>xor ebx ebx</code>，效果：ebx = ebx XOR ebx = 0000</li>
</ul>
</li>
<li>第二条指令汇编指令看似没有0的参与，为什么会出现空值呢？<ul>
<li>因为：这条指令使用了4B寄存器(EAX)，而我们复制了1B(1)到寄存器，默认情况下系统会自动用控制填充剩下部分</li>
<li>4B的EAX可以划分为2个2B(AX)和4个1B(AL、AH)，所以我们直接使用1B的AL就可以避免</li>
<li><code>mov al,1</code></li>
</ul>
</li>
</ul>
<h3 id="派生shell"><a href="#派生shell" class="headerlink" title="派生shell"></a>派生shell</h3><p>首先写派生shell的C程序。派生shell最方便、最快捷的方法是创建新进程。在Linux里有两种方法创建新进程：</p>
<ul>
<li><ol>
<li>通过现有进程创建它，并用它代替现有活动进程</li>
</ol>
</li>
<li><ol start="2">
<li>利用程序生成自己的副本，并在它的位置运行这个进程</li>
</ol>
</li>
</ul>
<p>下面是一个简单C程序的execve调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *cmd[<span class="number">2</span>];</span><br><span class="line">    cmd[<span class="number">0</span>] = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    cmd[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(cmd[<span class="number">0</span>], cmd, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在把它转换成原始十六进制指令，就像exit()一样。想观察execve的文档，提供的信息很有价值：</p>
<ul>
<li><code>int execve(const char* filename, char* const argv[], char* const envp[])</code></li>
<li>execve()执行filename(指针)指向的程序</li>
<li>argv是字符串数组，用来传递参数，envp是字符串数组，用来传递环境变量。argv和envp都以空指针结束</li>
</ul>
<p>执行execve()系统调用4个寄存器：1个用来保存系统调用值;3个用来保存系统调用参数。</p>
<p>在shellcode里不可以使用硬编码地址。我们希望shellcode容易移植，因此我们使用相对地址。下面介绍一种相对地址的实现方法</p>
<p>在shellcode里使用相对地址需要一些技巧。我们可以把shellcode在内存中的开始地址或shellcode的重要元素复制到寄存器，然后根据寄存器里的地址设计每条指令：</p>
<ul>
<li>shellcode以一条跳转指令开始，跳过shellcode，跳到调用指令</li>
<li>执行调用指令时，紧跟在调用指令之后的地址将被压入栈<ul>
<li>这里把想作为相对地址的基地址直接放在了调用指令之后</li>
<li>需要时可以从栈中找到地址</li>
</ul>
</li>
<li>当调用指令后，我们的的基地址将自动保存在栈上，而我们不必提前知道这个地址</li>
<li>之后，调用指令调用shellcode，执行<code>pop esi</code>把栈上的基地址送入ESI。至此就可以根据ESI的偏移量来引用shellcode里面的代码</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    jmp short GoToCall</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop esi     ;把&#39;&#x2F;bin&#x2F;sh&#39;送入esi，使用了相对地址</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">GoToCall:</span><br><span class="line">    call shellcode</span><br><span class="line">    db &#39;&#x2F;bin&#x2F;sh&#39;</span><br></pre></td></tr></table></figure>

<p>下面用真正的汇编指令替代伪代码。在编写过程中，还需要在字符串尾部保留一些占位符(这里是9B)，如下：</p>
<ul>
<li><code>/bin/shJAAAAKKKK</code></li>
</ul>
<p>这些占位符有什么用呢？我们将把系统调用所需的3个参数中的2个(将被载入ECX、EDX)保存在这些占位符里。因为字符串的第一个字节的地址保存在ESI里，所以对于替换和把这些值复制到寄存器来说，很容易就能确定它们所在内存中的位置。另外，可以通过”复制到占位符”方法，用空值有效终止这些字符串。步骤如下：</p>
<ul>
<li><ol>
<li>用xor EAX EAX的结果(空值)填充EAX</li>
</ol>
</li>
<li><ol start="2">
<li>把AL复制到紧挨着/bin/sh的字符位置(J)来终止/bin/sh字符串。<ul>
<li>因为EAX是空值，所以AL也是空值</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>得到保存在ESI里的字符串开头地址，把它复制到EBX</li>
</ol>
</li>
<li><ol start="4">
<li>把EBX里的值(字符串开头的地址)复制到AAAA占位符<ul>
<li>这是execve系统调用要求的、被执行文件的参数指针</li>
</ul>
</li>
</ol>
</li>
<li><ol start="5">
<li>用正确的偏移量吧保存在EAX中的空值复制到KKKK占位符</li>
</ol>
</li>
<li><ol start="6">
<li>把字符串的地址载入EBX</li>
</ol>
</li>
<li><ol start="7">
<li>把保存在AAAA占位符里的地址(一个指向字符串的指针)载入ECX</li>
</ol>
</li>
<li><ol start="8">
<li>把保存在KKKK占位符里的地址(一个指向空值的指针)载入EDX</li>
</ol>
</li>
<li><ol start="9">
<li>执行<code>int 0x80</code></li>
</ol>
</li>
</ul>
<p>得到汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    jmp short GoToCall</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop esi</span><br><span class="line"></span><br><span class="line">    xor eax, eax                ; 1</span><br><span class="line">    </span><br><span class="line">    mov byte [esi+7], al        ; 2</span><br><span class="line"></span><br><span class="line">    lea ebx, [esi]              ; 3</span><br><span class="line">    mov long [esi+8], ebx       ; 4</span><br><span class="line">    mov long [esi+12], eax      ; 5</span><br><span class="line">    mov byte al, 0x0b</span><br><span class="line">    mov ebx, esi</span><br><span class="line">    lea ecx, [esi + 8]</span><br><span class="line">    lea edx, [esi + 12]</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">GoToCall:</span><br><span class="line">    call shellcode</span><br><span class="line">    db &#39;&#x2F;bin&#x2F;shJAAAAKKKK&#39;</span><br></pre></td></tr></table></figure>

<p>编译并反汇编的到操作码</p>
<h2 id="格式化串漏洞"><a href="#格式化串漏洞" class="headerlink" title="格式化串漏洞"></a>格式化串漏洞</h2><p>何为格式化串：</p>
<ul>
<li><code>printf(&quot;%d %x&quot;, a, b);</code></li>
<li>printf是一个参数保存在栈上的函数，即a、b从栈中取出</li>
</ul>
<p>出现格式化串漏洞最常见的原因是，在C语言里没有处理带有可变参数的函数。</p>
<h3 id="什么是格式化串"><a href="#什么是格式化串" class="headerlink" title="什么是格式化串"></a>什么是格式化串</h3><p>当 <strong>printf系列函数</strong> 的格式化串里包含用户提交的数据时(如用户输入)，就可能出现格式化串漏洞。</p>
<p>攻击者可以提交很多格式符(而不给出对应的变量)，这样的话，栈上就没有和格式符相对应的参数，从而导致信息泄漏和执行任意代码。</p>
<p>如果我们不给格式符提供变量，将会出现奇怪的事情。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmt.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用如下形式执行<ul>
<li><code>./fmt &quot;%x %x %x %x&quot;</code></li>
</ul>
</li>
<li>就相当于用如下形式调用printf<ul>
<li><code>printf(&quot;%x %x %x %x&quot;);</code></li>
</ul>
</li>
<li>这个语句会透露出一些重要的信息：我们提供了格式符，但没提供对应的参数。printf也没有报错，而是输出一下内容：<ul>
<li><code>4015c98c 4001526c bffff944 bffff8e8</code></li>
</ul>
</li>
<li>攻击者可以利用它来获取栈上的数据</li>
</ul>
<p>有许多格式符，下面介绍一个：</p>
<ul>
<li>n，这个参数被视为指向整数指针(或整数变量)，在这个参数之前输出的字符的数量被保存到这个参数指针的地址里<ul>
<li><code>./fmt &quot;AAAAAAAAAA%n%n%n%n%n%n%n%n&quot;</code></li>
<li>%n格式符把它的参数作为内存地址，把前面输出的字符的数量写到这个地址</li>
<li>这意味着我们有机会改写某个内存地址的数据，从而控制程序的执行</li>
</ul>
</li>
</ul>
<p>利用%n格式符把控制的数据写入选择的地址。如果满足一下条件，就可以利用格式化串漏洞执行任意代码：</p>
<ul>
<li>我们能够控制参数，并可以把输出的字符的数量写入内存的任意区域</li>
<li>宽度格式符允许我们用任意长度填充输出。如：<code>&quot;%23d&quot;</code>。因此可以用选择的值改写单个字节</li>
<li>通常来说，我们可以猜测函数指针的地址，因此我们可以促成系统把提交的字符串当作代码执行</li>
</ul>
<h3 id="Building"><a href="#Building" class="headerlink" title="Building"></a>Building</h3><h3 id="格式化串技术概述"><a href="#格式化串技术概述" class="headerlink" title="格式化串技术概述"></a>格式化串技术概述</h3><ul>
<li><p>如果格式化串在栈上，当增加字符串的格式符时，可以为格式符提供参数</p>
<ul>
<li>一旦可以指定参数：</li>
<li>可以用%s从目标进程读取内存数据</li>
<li>可以用%n把输出的字符的数量写入任意地址</li>
<li>可以用宽度修饰符修改输出的字符的数量</li>
<li>可以用%hn修饰符每次写入16位数值</li>
</ul>
</li>
<li><p>直接参数访问允许多次重用同一格式化串里的栈参数，也允许直接用这些我们感兴趣的参数。直接参数访问使用$修饰符，如：</p>
<ul>
<li><code>%272$x</code>，将显示栈上第272个参数</li>
</ul>
</li>
<li><p>利用格式化串漏洞、写内存的技术，可以：</p>
<ul>
<li>改写保存的返回地址</li>
<li>改写其他特殊程序的函数指针</li>
<li>改写指向异常处理程序的指针</li>
<li>改写GOT(全局偏移表)条目</li>
<li>等等</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Web篇"><a href="#Web篇" class="headerlink" title="Web篇"></a>Web篇</h1><h2 id="解析应用程序"><a href="#解析应用程序" class="headerlink" title="解析应用程序"></a>解析应用程序</h2><ul>
<li>确定后端使用的技术<ul>
<li><ol>
<li>提取版本HTTP消息头中的版本信息，但后端程序员也可以伪造</li>
</ol>
</li>
<li><ol start="2">
<li>文件扩展名<ul>
<li>许多Web服务器将特殊的文件扩展名映射到特定的服务器组件中，不同组建处理错误的方式不同</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>目录名<ul>
<li>一些子目录名常常表示应用程序使用了相关技术</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>会话令牌<ul>
<li>许多Web服务器和Web应用程序平台默认生成的会话令牌名称会揭示其使用的技术</li>
</ul>
</li>
</ol>
</li>
<li>等等</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/hacker-%E6%B1%87%E7%BC%96/" rel="tag"># hacker,汇编</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/18/Major/algorithm/algorithm_tips/" rel="prev" title="算法技巧">
      <i class="fa fa-chevron-left"></i> 算法技巧
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/29/universe/Emacs_in_action/" rel="next" title="emacs快速入门">
      emacs快速入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#系统篇"><span class="nav-number">1.</span> <span class="nav-text">系统篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈溢出"><span class="nav-number">1.1.</span> <span class="nav-text">栈溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数与栈"><span class="nav-number">1.1.1.</span> <span class="nav-text">函数与栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈上的缓冲区溢出"><span class="nav-number">1.1.2.</span> <span class="nav-text">栈上的缓冲区溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用漏洞获得root权限"><span class="nav-number">1.1.3.</span> <span class="nav-text">利用漏洞获得root权限</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#地址问题"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">地址问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NOP法"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">NOP法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#战胜不可执行栈"><span class="nav-number">1.1.4.</span> <span class="nav-text">战胜不可执行栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shellcode"><span class="nav-number">1.2.</span> <span class="nav-text">shellcode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解系统调用"><span class="nav-number">1.2.1.</span> <span class="nav-text">理解系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为exit-系统调用写shellcode"><span class="nav-number">1.2.2.</span> <span class="nav-text">为exit()系统调用写shellcode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可注入的shellcode"><span class="nav-number">1.2.3.</span> <span class="nav-text">可注入的shellcode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生shell"><span class="nav-number">1.2.4.</span> <span class="nav-text">派生shell</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#格式化串漏洞"><span class="nav-number">1.3.</span> <span class="nav-text">格式化串漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是格式化串"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是格式化串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Building"><span class="nav-number">1.3.2.</span> <span class="nav-text">Building</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化串技术概述"><span class="nav-number">1.3.3.</span> <span class="nav-text">格式化串技术概述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Web篇"><span class="nav-number">2.</span> <span class="nav-text">Web篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解析应用程序"><span class="nav-number">2.1.</span> <span class="nav-text">解析应用程序</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Travis TuRing</p>
  <div class="site-description" itemprop="description">Mens et Manus</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Travis TuRing</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
