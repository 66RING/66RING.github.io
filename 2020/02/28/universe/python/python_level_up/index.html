<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="python提高GIL(全局解释器锁)保证多线程程序同一时间只有一个线程在执行。多个线程先强锁。 c语言写的python解释器存在GIL。 一面试题  描述python GIL的概念，以及它对python多线程的影响。编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否比单线程性能有提升，并解释原因  参考答案    python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython解释">
<meta property="og:type" content="article">
<meta property="og:title" content="Python补完计划">
<meta property="og:url" content="http://yoursite.com/2020/02/28/universe/python/python_level_up/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="python提高GIL(全局解释器锁)保证多线程程序同一时间只有一个线程在执行。多个线程先强锁。 c语言写的python解释器存在GIL。 一面试题  描述python GIL的概念，以及它对python多线程的影响。编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否比单线程性能有提升，并解释原因  参考答案    python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython解释">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-27T16:00:00.000Z">
<meta property="article:modified_time" content="2020-07-11T03:29:21.418Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/02/28/universe/python/python_level_up/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Python补完计划 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/28/universe/python/python_level_up/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python补完计划
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-28T00:00:00+08:00">2020-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-11 11:29:21" itemprop="dateModified" datetime="2020-07-11T11:29:21+08:00">2020-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="python提高"><a href="#python提高" class="headerlink" title="python提高"></a>python提高</h2><h3 id="GIL-全局解释器锁"><a href="#GIL-全局解释器锁" class="headerlink" title="GIL(全局解释器锁)"></a>GIL(全局解释器锁)</h3><p>保证多线程程序同一时间只有一个线程在执行。多个线程先强锁。</p>
<p>c语言写的python解释器存在GIL。</p>
<p>一面试题</p>
<blockquote>
<p>描述python GIL的概念，以及它对python多线程的影响。编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否比单线程性能有提升，并解释原因</p>
</blockquote>
<p>参考答案</p>
<blockquote>
<ul>
<li><ol>
<li>python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython解释器，难以移除GIL</li>
</ol>
</li>
<li><ol start="2">
<li>GIL：全局解释器锁。每个线程在执行的过程都需要先抢GIL，保证同一时刻只有一个线程可以执行</li>
</ol>
</li>
<li><ol start="3">
<li>线程释放GIL锁的情况：在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GIL python3.x使用计时器(执行时间到达阀值后，当前线程释放GIL)或python2.x的tickels计数到100</li>
</ol>
</li>
<li><ol start="4">
<li>python使用多进程可以利用多核CPU资源</li>
</ol>
</li>
<li><ol start="5">
<li>多线程爬取性能有提升，因为遇到IO阻塞(如网络)会自动释放GIL锁</li>
</ol>
</li>
</ul>
</blockquote>
<p>IO密集型程序适合用多线程</p>
<h3 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h3><p>赋值语句在python中一般都是引用</p>
<ul>
<li>深拷贝<code>copy.deepcopy</code><ul>
<li><code>import copy</code></li>
<li><code>b = copy.deepcopy(a)</code></li>
<li><code>id(a) != id(b)</code></li>
<li>如果拷贝的是元祖，且元祖里有可变的数据，设元祖a，则deepcopy结果<code>id(a)!=id(b)</code></li>
</ul>
</li>
<li>浅拷贝<code>copy.copy</code><ul>
<li><code>import copy</code></li>
<li><code>b = copy.copy(a)</code></li>
<li><code>id(a) != id(b)</code></li>
<li>但是如果拷贝的是元祖，且元祖里只有普通数据(不可变的)，设元祖a，则copy结果<code>id(a)==id(b)</code><ul>
<li>因为元祖是不可变类型，增删改都没用所以拷贝有什么用，所有就不拷贝</li>
</ul>
</li>
</ul>
</li>
<li>切片也是浅拷贝</li>
<li>字典<code>key: value</code>，value是指向别处的引用</li>
<li>浅拷贝和深拷贝的区别  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">c = [a, b]  <span class="comment"># c中的a、b都是引用，引用指向两个列表</span></span><br><span class="line">d = copy.deepcopy(c)</span><br><span class="line">e = copy.copy(c)</span><br><span class="line"><span class="comment"># 虽然id(c)!=id(e)但是e中的[1, 2]、[3, 4]仍是a、b的引用，仅仅是把c的东西原封不动复制到e</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="私有化"><a href="#私有化" class="headerlink" title="私有化"></a>私有化</h3><p>不同于面向对象的语言，python没有public、private等关键字。</p>
<ul>
<li>xx：共有变量</li>
<li>_x：单前置下划线，私有化属性或方法，<code>from somemodule import *</code>不会导入<code>_x</code>变量，类和对象子类可以访问</li>
<li>__xx：双前置下划线，私有化属性或方法，避免与子类中的属性冲突，无法在外部直接访问(名字重整所以访问不到)</li>
<li>__xx__：双前后下划线，用户名字空间的魔法对象属性，非私有</li>
<li>xx_：单后置下划线，用于避免与python关键词的冲突</li>
</ul>
<h3 id="import问题"><a href="#import问题" class="headerlink" title="import问题"></a>import问题</h3><p>程序执行时添加新的模块路径</p>
<p><code>sys.path</code>是个储存了模块路径的列表，因此可以使用列表操作改变搜索路径的优先级以及添加新路径</p>
<h4 id="重新导入模块问题"><a href="#重新导入模块问题" class="headerlink" title="重新导入模块问题"></a>重新导入模块问题</h4><p>import会防止模块重复导入，如果在程序执行期间修改了模块，即使使用import再次导入，修改的模块不会更新。需要使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"></span><br><span class="line">reload(somemodule)  <span class="comment"># 使用这种方式在不退出程序的情况下重新导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是对于from aa import bb这样的需求没有办法</span></span><br></pre></td></tr></table></figure>


<h4 id="多模块导入问题"><a href="#多模块导入问题" class="headerlink" title="多模块导入问题"></a>多模块导入问题</h4><p>在大型项目中一般会把很长的代码拆分成很多小的模块，这时模块间的数据传递就需要注意。一般把公共数据放在一个模块，这样方便访问、修改。</p>
<p><code>import aa</code>，<code>aa.bb = a</code>和<code>from aa import bb</code>，<code>bb=a</code>的区别</p>
<ul>
<li><code>import aa</code>使aa指向模块，则<code>aa.bb = a</code>是对模块aa的bb赋值，会改变aa中bb的值</li>
<li><code>from aa import bb</code>使得变量bb <strong>指向</strong> 模块aa中的同名变量bb，如果使用<code>bb = a</code>使得bb的指向改变，不会改变aa中的bb的值</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="多继承以及MRO顺序"><a href="#多继承以及MRO顺序" class="headerlink" title="多继承以及MRO顺序"></a>多继承以及MRO顺序</h4><ul>
<li>调用父类方法的方式<ul>
<li><ol>
<li>通过父类的名字调用<ul>
<li>缺点是会根据类递归的调用，无形中造成资源浪费。如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class A:</span><br><span class="line">    __init__(self):</span><br><span class="line">        new_socket</span><br><span class="line">Class B(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        A.__init__(self)</span><br><span class="line">Class C(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        A.__init__(self)</span><br><span class="line">Class D(B, C):</span><br><span class="line">    __init__(self):</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        C.__init__(self) </span><br><span class="line"><span class="comment"># B和C的init分别调用A的init导致多创建一个socket，造成浪费</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>通过<code>super().xxx</code>调用<ul>
<li>不是更具类递归的调用，而是根据<code>ClassName.__mro__</code>中的顺序调用，保证了每个类只调用一次</li>
<li>如果多继承了多个同名方法，则根据<code>ClassName.__mro__</code>中的顺序决定super().xxx调用的是哪个(先后顺序)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class A:</span><br><span class="line">    __init__(self):</span><br><span class="line">        new_socket</span><br><span class="line">Class B(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        supter.__init__(self)</span><br><span class="line">Class C(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        super.__init__(self)</span><br><span class="line">Class D(B, C):</span><br><span class="line">    __init__(self):</span><br><span class="line">        super().__init__(self)</span><br><span class="line"><span class="comment"># 其中print(D.__mro__)=(D, B, C, A, object)</span></span><br><span class="line"><span class="comment"># 那么如果从D开始，如果父类都有调用super，则会根据mro中的顺序调用，即D、B、C、A</span></span><br></pre></td></tr></table></figure></li>
<li><code>super(ClassName, self)</code>，会从ClassName往后开始调用，如<code>super(B, self)</code>则顺序是B、C、A。默认从当前类开始</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><ul>
<li><code>func(a, *args, **kwargs)</code><ul>
<li>一个<code>*</code>号以元祖的形式传递参数，变量名是args，<code>*</code>号只是告诉编译器</li>
<li>两个<code>*</code>号以字典的形式传递参数，变量名是kwargs<ul>
<li><strong>接收关键字参数</strong> ：如<code>func(1, 2, 3, 4, age=&#39;12&#39;, name=&#39;ring&#39;)</code><ul>
<li>args=(2, 3, 4)</li>
<li>kwargs={‘age’: ‘12’, ‘name’: ‘ring’}</li>
</ul>
</li>
<li>需要注意的是如果传的是一个字典，它并不是关键字参数，而是一个字典(一个整体)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="静态方法和属性方法"><a href="#静态方法和属性方法" class="headerlink" title="静态方法和属性方法"></a>静态方法和属性方法</h4><ul>
<li>类对象和实例对象<ul>
<li>创建一个对象会从模板类中调用<code>__new__</code>分配内存空间，<code>__init__</code>初始化内存空间，<code>__class__</code>指向创建这个实例对象的类对象</li>
<li>对于公有的方法、属性存储在类对象中<ul>
<li>如方法<code>__inti__(self)</code>就不必每个实例都有一份，放在类对象中即可</li>
</ul>
</li>
<li>对于特有的方法、属性存储在类对象中<ul>
<li>如初始化name=ring，那么对于这个实例的name是ring，别的实例有所区别</li>
</ul>
</li>
</ul>
</li>
<li>类方法、实例方法、静态方法<ul>
<li>实例方法：一般的方法<ul>
<li>很难修改类属性，若<code>obj.class_state=&quot;xx&quot;</code>原来<code>class_state</code>是一个类属性。这个方法将导致实例里面新增一个名为<code>class_state</code>的属性<ul>
<li>要修改也是可以的<code>obj.__class__.class_state=&quot;xx&quot;</code>就可以修改<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">        <span class="comment"># 实例方法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span>  <span class="comment"># 默认传实例对象的引用self</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    ```  </span><br><span class="line">* 类方式：用`@classmethod`装饰</span><br><span class="line">    ``` python</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">        @classmethod  # 类方法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(cls)</span>:</span>  <span class="comment"># python解释器默认把类对象引用cls传入</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>可以修改类属性</li>
</ul>
</li>
<li>静态方法：用<code>@staticmethod</code>装饰<ul>
<li>相当于在类外定义一个函数， <strong>不让python解释权默认传入类对象或实例对象</strong> 。写在类中是为例在不同类中区分开来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="property属性"><a href="#property属性" class="headerlink" title="property属性"></a>property属性</h4><ul>
<li>用装饰器创建<ul>
<li>让代码更简洁，调用一个函数像取值、赋值一样</li>
<li>在普通方法前用<code>@property</code>修饰，如。把调用方法改成”调用属性”，但实际还是调用方法，只是可读性更高  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 必须返回一个值，且参数只有self</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.func  <span class="comment"># 可以通过a.func调用，而不用a.func()</span></span><br></pre></td></tr></table></figure></li>
<li>新式类(继承object，python3默认继承)中有3中property装饰器  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>   <span class="comment"># 获取值</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 要同名，且传入新值value</span></span><br><span class="line">        print(<span class="string">"some"</span>)  <span class="comment"># 设置值</span></span><br><span class="line">    <span class="comment"># 如可以调用xxx.func = 100</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"some"</span>)  <span class="comment"># 删除值</span></span><br><span class="line">    <span class="comment"># 如可以调用del xxx.func</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过类属性创建<ul>
<li><code>property(arg1, arg2, arg3, arg4)</code><ul>
<li>参数1是方法名，调用<code>对象.属性</code>时自动触发执行</li>
<li>(可选)参数2是方法名，调用<code>对象.属性=xx</code>时自动触发执行</li>
<li>(可选)参数3是方法名，调用<code>del 对象.属性</code>时自动触发执行</li>
<li>(可选)参数4是字符串，调用<code>对象.属性.__doc__</code>时此参数是该属性的描述信息<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    FUNC = property(func)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.FUNC</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="修改私有属性"><a href="#修改私有属性" class="headerlink" title="修改私有属性"></a>修改私有属性</h4><p>私有属性(在以<code>__</code>开头的变量)之所以无法访问是因为python悄悄改了变量名。如把<code>__func</code>改成了<code>_className__func</code>。所以使用这个改后的名就可以访问私有属性。这机制叫做名字重整。</p>
<h4 id="魔法属性-方法"><a href="#魔法属性-方法" class="headerlink" title="魔法属性/方法"></a>魔法属性/方法</h4><ul>
<li><code>__doc__</code>和<code>help()</code><ul>
<li>使用<code>var.__doc__</code>或<code>help(var)</code>可以查看写在开头的描述</li>
</ul>
</li>
<li><code>__module__</code>和<code>__class__</code><ul>
<li><code>__class__</code>表示当前操作的对象的类是什么</li>
<li><code>__module__</code>表示当前操作的对象是在哪个模块</li>
</ul>
</li>
<li><code>__init__</code><ul>
<li><strong>初始化</strong> 方法，创建类对象时自动触发执行</li>
</ul>
</li>
<li><code>__del__</code><ul>
<li>对象释放时，自动触发执行</li>
</ul>
</li>
<li><code>__call__</code><ul>
<li>对象后面加括号，触发执行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = classA()</span><br><span class="line">obj()   <span class="comment"># obj.__call__()</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>__dict__</code><ul>
<li>类或对象的所有属性</li>
</ul>
</li>
<li><code>__str__</code><ul>
<li>如果一个类中定义了<code>__str__</code>方法，那么打印对象时，默认输出改方法的返回值</li>
</ul>
</li>
<li><code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem</code><ul>
<li>如果类中实现了这3个方法，则可以当字典用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(key)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(key)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(key)</span><br><span class="line"></span><br><span class="line">odj = A()</span><br><span class="line">res = obj[<span class="string">'k1'</span>]   <span class="comment"># __getitem__</span></span><br><span class="line">obj[<span class="string">'k2'</span>] = <span class="string">'abc'</span> <span class="comment"># __setitem__</span></span><br><span class="line"><span class="keyword">del</span> obj[<span class="string">'k3'</span>]     <span class="comment"># __delitem__</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>__getslice__</code>、<code>__setslice__</code>、<code>__delslice__</code><ul>
<li>如果类中实现了这3个方法，则可以用于分片操作，如列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setslice__</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delslice__</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">odj = A()</span><br><span class="line">obj[<span class="number">-1</span>:<span class="number">1</span>]            <span class="comment"># __getslice__</span></span><br><span class="line">obj[<span class="number">0</span>:<span class="number">1</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># __setslice__</span></span><br><span class="line"><span class="keyword">del</span> obj[<span class="number">0</span>:<span class="number">2</span>]         <span class="comment"># __delslice__</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h4 id="with与上下文管理器"><a href="#with与上下文管理器" class="headerlink" title="with与上下文管理器"></a>with与上下文管理器</h4><p>使用with打开文件能够保证最终文件都会关闭。如果采用传统的<code>f = open()</code>则需要try-catch辅助。with是一种更简洁的写法。</p>
<ul>
<li>上下文管理器<ul>
<li>任何实现了<code>__enter__()</code>和<code>__exit__()</code>方法的对象都可称之为上下文管理器。</li>
<li><code>__enter__()</code>返回资源对象</li>
<li><code>__exit__()</code>处理一些清理工作</li>
</ul>
</li>
</ul>
<p>当一个对象实现了上下文管理器，就可以使用with语句了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> obj(args) <span class="keyword">as</span> f:  </span><br><span class="line">    <span class="comment"># obj()创建实例对象</span></span><br><span class="line">    <span class="comment"># with自动调用了obj(上下文管理器)的__enter__方法，enter的返回值赋给f</span></span><br><span class="line">    <span class="comment"># 如果产生了异常，将自动调用__exit__方法</span></span><br></pre></td></tr></table></figure>


<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>多层函数嵌套、往往内部函数用到外部函数的变量，一个特殊的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(a*x + b)</span><br><span class="line">    <span class="keyword">return</span> solve</span><br><span class="line"></span><br><span class="line">ans = func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 创造单独空间，包含参数a, b和solve函数。a, b相当于solve的全局变量</span></span><br><span class="line"><span class="comment"># 类似类，但比类开销小</span></span><br><span class="line">ans(<span class="number">0</span>)</span><br><span class="line">ans(<span class="number">1</span>)</span><br><span class="line">ans(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x  <span class="comment"># 告诉解释器x不是solve中的，否则由于x=10的存在。会导致解释器认为x这个局部变量在声明前使用</span></span><br><span class="line">        print(x)</span><br><span class="line">        x = <span class="number">10</span>  </span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> solve</span><br></pre></td></tr></table></figure>


<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>有时候我们需要进行一下重复的过程, 比如计算函数用时. 如果我们直接把逻辑写在函数内部, 逻辑混乱且可读性不高。这时我们就可以使用装饰器</p>
<h4 id="装饰器的基本实现过程"><a href="#装饰器的基本实现过程" class="headerlink" title="装饰器的基本实现过程"></a>装饰器的基本实现过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  # 等价于test=set_func(test)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<h4 id="有参数的装饰器实现过程"><a href="#有参数的装饰器实现过程" class="headerlink" title="有参数的装饰器实现过程"></a>有参数的装饰器实现过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(a)</span>:</span>  <span class="comment"># 参数100会传到这</span></span><br><span class="line">        func(a)</span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h4 id="不定参数的装饰器实现过程"><a href="#不定参数的装饰器实现过程" class="headerlink" title="不定参数的装饰器实现过程"></a>不定参数的装饰器实现过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 参数会传到这，这里的星号是告诉解释器</span></span><br><span class="line"></span><br><span class="line">        func(*args, **kwargs)  <span class="comment"># 这里的星号是拆包!!!，否则就是一个列表、一个字典</span></span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(age, num, *args, &amp;&amp;kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h4 id="带有返回值的装饰器实现"><a href="#带有返回值的装饰器实现" class="headerlink" title="带有返回值的装饰器实现"></a>带有返回值的装饰器实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 比包里调用，返回出去</span></span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(age, num, *args, &amp;&amp;kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h4 id="给装饰器的参数"><a href="#给装饰器的参数" class="headerlink" title="给装饰器的参数"></a>给装饰器的参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">option</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> call_func</span><br><span class="line">    <span class="keyword">return</span> set_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@option(args)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(age, num, *args, &amp;&amp;kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>装饰器需要一个函数指针，即@后跟函数名，由于option(args)不符合，所以先向下执行option(args)，返回的函数指针。@心满意足，用来装饰test函数</p>
<h4 id="多个装饰器对同一个函数进行装饰"><a href="#多个装饰器对同一个函数进行装饰" class="headerlink" title="多个装饰器对同一个函数进行装饰"></a>多个装饰器对同一个函数进行装饰</h4><p>先装下面的后装上面的。理解上面的实现过程。</p>
<p>执行效果是先执行上面的再执行下面的。所以装饰的顺序和想要的逻辑执行顺序相同即可。</p>
<h4 id="使用类当作装饰器"><a href="#使用类当作装饰器" class="headerlink" title="使用类当作装饰器"></a>使用类当作装饰器</h4><p>原理同闭包。只是变量名指向的不是函数，而是实例对象。</p>
<p>然后使用<code>变量名()</code>调用的是<code>实例对象.__call__()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.func()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/26/universe/how_to_makefile/" rel="prev" title="How to makefile">
      <i class="fa fa-chevron-left"></i> How to makefile
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/02/universe/js_ts/typescript/" rel="next" title="TypeScript">
      TypeScript <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#python提高"><span class="nav-number">1.</span> <span class="nav-text">python提高</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GIL-全局解释器锁"><span class="nav-number">1.1.</span> <span class="nav-text">GIL(全局解释器锁)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝、浅拷贝"><span class="nav-number">1.2.</span> <span class="nav-text">深拷贝、浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有化"><span class="nav-number">1.3.</span> <span class="nav-text">私有化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import问题"><span class="nav-number">1.4.</span> <span class="nav-text">import问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重新导入模块问题"><span class="nav-number">1.4.1.</span> <span class="nav-text">重新导入模块问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多模块导入问题"><span class="nav-number">1.4.2.</span> <span class="nav-text">多模块导入问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象"><span class="nav-number">1.5.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多继承以及MRO顺序"><span class="nav-number">1.5.1.</span> <span class="nav-text">多继承以及MRO顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可变参数"><span class="nav-number">1.5.2.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法和属性方法"><span class="nav-number">1.5.3.</span> <span class="nav-text">静态方法和属性方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#property属性"><span class="nav-number">1.5.4.</span> <span class="nav-text">property属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改私有属性"><span class="nav-number">1.5.5.</span> <span class="nav-text">修改私有属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#魔法属性-方法"><span class="nav-number">1.5.6.</span> <span class="nav-text">魔法属性&#x2F;方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#with与上下文管理器"><span class="nav-number">1.5.7.</span> <span class="nav-text">with与上下文管理器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">1.6.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修改数据"><span class="nav-number">1.6.1.</span> <span class="nav-text">修改数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰器"><span class="nav-number">1.7.</span> <span class="nav-text">装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰器的基本实现过程"><span class="nav-number">1.7.1.</span> <span class="nav-text">装饰器的基本实现过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有参数的装饰器实现过程"><span class="nav-number">1.7.2.</span> <span class="nav-text">有参数的装饰器实现过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不定参数的装饰器实现过程"><span class="nav-number">1.7.3.</span> <span class="nav-text">不定参数的装饰器实现过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带有返回值的装饰器实现"><span class="nav-number">1.7.4.</span> <span class="nav-text">带有返回值的装饰器实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#给装饰器的参数"><span class="nav-number">1.7.5.</span> <span class="nav-text">给装饰器的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个装饰器对同一个函数进行装饰"><span class="nav-number">1.7.6.</span> <span class="nav-text">多个装饰器对同一个函数进行装饰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用类当作装饰器"><span class="nav-number">1.7.7.</span> <span class="nav-text">使用类当作装饰器</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
