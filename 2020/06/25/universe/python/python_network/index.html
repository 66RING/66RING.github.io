<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="python, network," />










<meta name="description" content="Socket基本使用 创建套接字对象socket.socket(AddressFamily, Type)  udp: s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM) tcp: s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) 其中AF_INET表示IPv4，SOCK_DGRAM表示u">
<meta property="og:type" content="article">
<meta property="og:title" content="python 网络编程">
<meta property="og:url" content="http://yoursite.com/2020/06/25/universe/python/python_network/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Socket基本使用 创建套接字对象socket.socket(AddressFamily, Type)  udp: s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM) tcp: s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM) 其中AF_INET表示IPv4，SOCK_DGRAM表示u">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-24T16:00:00.000Z">
<meta property="article:modified_time" content="2020-07-11T03:28:32.075Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="python, network">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/06/25/universe/python/python_network/"/>





  <title>python 网络编程 | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/25/universe/python/python_network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">python 网络编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-25T00:00:00+08:00">
                2020-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Socket基本使用"><a href="#Socket基本使用" class="headerlink" title="Socket基本使用"></a>Socket基本使用</h2><ul>
<li><p>创建套接字对象<code>socket.socket(AddressFamily, Type)</code></p>
<ul>
<li>udp: <code>s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</code></li>
<li>tcp: <code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code></li>
<li>其中<code>AF_INET</code>表示IPv4，<code>SOCK_DGRAM</code>表示udp，<code>SOCK_STREAM</code>表示tcp</li>
</ul>
</li>
<li><p>绑定端口<code>s.bind((ip, port))</code>让程序使用固定的端口负责接收</p>
</li>
<li><p>发送数据</p>
<ul>
<li>udp: <code>s.sendto(data, (ip, port))</code>，如果没绑定端口则由系统随机分配</li>
<li>tcp: <code>s.send(data)</code></li>
</ul>
</li>
<li><p>接收数据</p>
<ul>
<li><ol>
<li>创建套接字</li>
</ol>
</li>
<li><ol start="2">
<li>必须绑定端口，让程序使用固定的端口负责接收</li>
</ol>
</li>
<li><ol start="3">
<li>接收<code>s.recvfrom(size)</code>，返回元祖<code>(data, src_ip)</code></li>
</ol>
</li>
</ul>
</li>
<li><p>单工：只能收/发</p>
</li>
<li><p>办双工：能收发，要收就不能发，要发就不能收</p>
</li>
<li><p>全双工：能收发，如打电话</p>
</li>
</ul>
<p>套接字可以同时收发，是全双工</p>
<h3 id="Socket中使用tcp"><a href="#Socket中使用tcp" class="headerlink" title="Socket中使用tcp"></a>Socket中使用tcp</h3><p>和udp的方法有些不同</p>
<ul>
<li>建立连接<ul>
<li><code>s.connect((ip, port))</code></li>
</ul>
</li>
<li>发送数据<ul>
<li>tcp: <code>s.send(data)</code></li>
</ul>
</li>
</ul>
<h3 id="tcp服务器"><a href="#tcp服务器" class="headerlink" title="tcp服务器"></a>tcp服务器</h3><p>一般需要以下步骤：</p>
<ul>
<li><p>创建套接字</p>
</li>
<li><p>bind绑定ip和port</p>
</li>
<li><p>listen使套接字变为被动链接</p>
<ul>
<li>被动：即可以让别人来呼叫</li>
</ul>
</li>
<li><p>accept等待客户端的链接</p>
<ul>
<li>返回一个元祖，<code>(client_socket, client_addr)</code><ul>
<li>可以通过<code>client_socket</code>向客户端发送数据</li>
</ul>
</li>
</ul>
</li>
<li><p>recv/send收发数据</p>
<ul>
<li>不同与recvfrom，recv只返回data，因为accept的时候已经知道来源地址了</li>
</ul>
</li>
<li><p>同时为多个客户端服务，并且多次服务一个客户端</p>
<ul>
<li>由于accept会阻塞进程(类似input)，如何同时为多个服务？<ul>
<li>多任务</li>
</ul>
</li>
<li>一个客户端不一定只需要一次服务，如何多次服务一个客户端？<ul>
<li>当一个客户端不需要服务的时候，即客户端调用close的时候，会使服务端recv解堵塞，返回空，以此做判断依据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h4><ul>
<li>三次握手：建立连接<ul>
<li>C: 服务器你准备好没？SYN</li>
<li>S: 准备好了SYN ACK，你呢？SYN</li>
<li>C: 我也好了SYN ACK</li>
</ul>
</li>
<li>四次挥手<ul>
<li>C: 拜拜<code>close()</code>，不再给你发数据了哦</li>
<li>S: 好的(recv不等收了)知道了</li>
<li>S: 我也不发了(close，也许会延时，所以是4次)</li>
<li>C: 好的(recv不用等待接收了)</li>
<li>服务器和客户端的接收都关了</li>
</ul>
</li>
<li>为什么一般是客户端先关闭的原因：<ul>
<li>客户端的消息这么知道服务器收到了？服务器发生确认。那服务器的确认如何知道被收到了？客户端发送确认…无穷无尽也</li>
<li>所以采用发起消息的一方设置超时时间(等待)，所以如果是服务器发起消息(close)那服务器就要进入等待(额外开销浪费)</li>
</ul>
</li>
</ul>
<h3 id="一个简单下载器的实现"><a href="#一个简单下载器的实现" class="headerlink" title="一个简单下载器的实现"></a>一个简单下载器的实现</h3><ul>
<li>服务端<ul>
<li>根据用户需求寻找文件</li>
<li>将文件数据发送给客户</li>
</ul>
</li>
<li>客户端<ul>
<li>在本地新建一个同名文件</li>
<li>将从服务接收(recv)到的数据写入(二进制模式)文件即完成下载任务</li>
</ul>
</li>
</ul>
<h3 id="TCP注意点"><a href="#TCP注意点" class="headerlink" title="TCP注意点"></a>TCP注意点</h3><ul>
<li>tcp服务器一般绑定端口<ul>
<li>否则客户端找不到服务器</li>
</ul>
</li>
<li>tcp客户端一般不绑定端口<ul>
<li>因为连接服务器只需服务器的ip、port等。而且如果绑定不利于客户端多开</li>
</ul>
</li>
<li>tcp服务通过listen将socket创建出来的主动套接字变为被动是必要的</li>
<li>关闭listen后的套接字意味着被动套接字关闭了，新的客户端不能连接，但之前已经连接成功的客户端正常通信</li>
</ul>
<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><h3 id="Thread的基本使用"><a href="#Thread的基本使用" class="headerlink" title="Thread的基本使用"></a>Thread的基本使用</h3><p>对于单核cpu，可以在程序间快速切换，以达到多任务的效果，如：qq执行0.00001s，然后切换到微信。如此快速切换以致于人无法察觉，来实现多任务。但本质操作系统调度，一次执行一个任务，这样的方式称为并发。</p>
<p>对于多核cpu，每个核功能同单核，多个核在可以同时多个任务。这些在不同核中执行的进程的方式称为并行。真正意义的多任务。</p>
<p>thread使用需要引入threading模块：<code>import threading</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=func_pointer1, args=(args,))  <span class="comment"># 返回对象，参数以元祖方式传入</span></span><br><span class="line">t2 = threading.Thread(target=func_pointer2, args=(args,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>

<p>创建子线程t1、t2，通过start()来开始执行子线程，开启后执行下一行，子线程在后台执行，子线程执行完后主线程关闭。这样就实现了t1、t2多任务。</p>
<ul>
<li><code>threading.enumerate()</code><ul>
<li>以列表形式返回正在运行的线程</li>
<li>查看线程数量:<code>len(threading.enumerate())</code></li>
</ul>
</li>
<li><code>t.start()</code><ul>
<li>start实际上是调用了<code>threading.Thread</code>的<code>run(self)</code>方法，所以可以通过继承然后重载run方法</li>
</ul>
</li>
<li>多线程间是共享全局变量的<ul>
<li>同时对一个数据进行写入操作会存在问题，因为写入操作大致可分为这么几个步骤：读取数据、操作数据、写入数据。由于cpu在线程间切换，如果操作数据后切换到另一个进程，然后才写入数据，将导致问题。</li>
<li>互斥锁解决资源竞争<ul>
<li>创建互斥锁：<code>mutex = threading.Lock()</code></li>
<li>锁定：<code>mutex.acquire()</code>，如果已经上锁会阻塞直到解锁</li>
<li>释放：<code>mutex.release()</code></li>
</ul>
</li>
<li>多个互斥锁会出现的问题<ul>
<li>死锁：线程A等线程B用完资源，偏偏资源B在等A用完资源，的状态叫做死锁，如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">()</span>:</span></span><br><span class="line">    mutexA.acquire()</span><br><span class="line">    mutexB.acquire()</span><br><span class="line">    mutexB.release()</span><br><span class="line">    mutexA.release()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcB</span><span class="params">()</span>:</span></span><br><span class="line">    mutexB.acquire()</span><br><span class="line">    mutexA.acquire()</span><br><span class="line">    mutexA.release()</span><br><span class="line">    mutexB.release()</span><br></pre></td></tr></table></figure></li>
<li>避免死锁：<ul>
<li>程序设计时尽量避免(银行家算法等)</li>
<li>添加超时时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程方式"><a href="#进程方式" class="headerlink" title="进程方式"></a>进程方式</h3><p>需要<code>multiprocessing</code>模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">p = multiprocessing.Process(target=func_pointer, args=(args,))</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>由于是进程，所有可以在shell中查看<code>ps -aux</code>，也可以进行任何进程操作<ul>
<li>但是耗费的资源也比线程大</li>
</ul>
</li>
<li>进程间是互相独立的，进程间如何通信呢？<ul>
<li>队列，直接在内存中操作<ul>
<li><strong>multiprocessing.Queue()</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">q = multiprocessing.Queue()</span><br><span class="line">q.put(arg)</span><br><span class="line">q.get()</span><br><span class="line">q.get_nowait()</span><br><span class="line">q.full()</span><br><span class="line">q.empty()</span><br></pre></td></tr></table></figure></li>
<li>当队列为空时get方法会阻塞，get_nowait方法会引发异常来告诉你队列为空</li>
<li>如果队列满了put方法会阻塞</li>
</ul>
</li>
<li>使用队列来减少进程的耦合(解耦)<ul>
<li>进程A往queue填数据，只需关注写</li>
<li>进程B从queue取数据，只需关注读</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h4><p>一个可以容纳很多进程的特殊容器。它 <strong>重复利用进程池里的进程</strong> ，因为进程并非越多越好，会增加操作系统调度的压力。进程池减轻了进程创建和销毁的负担。</p>
<ul>
<li>进程池创建<ul>
<li><code>from multiprocessing import Pool</code></li>
<li><code>po = Pool(n)</code>，设置最对创建的个数，这里是n<ul>
<li>可以往里添加无数个，但最对同时运行n个进程，其他存起来</li>
</ul>
</li>
<li>添加到进程池：<code>po.apply_async(func_pointer, (args,))</code></li>
<li>进程池关闭<code>po.close()</code></li>
<li><code>po.join()</code>等到进程池中所有子进程执行完成， <strong>join必须放在close之后</strong><ul>
<li>因为使用进程池不会阻塞主进程，所以可能子进程还没结束，主进程先结束了，导致所以子进程结束</li>
</ul>
</li>
</ul>
</li>
<li>进程池里的任务产生的异常不会产生错误信息</li>
<li>显示进度<ul>
<li>通过队列在进程间通信，子进程完成后写入队列，主进程从队列读，统计<ul>
<li><strong>进程的队列要使用 <code>multiprocessing.Manager().Queue()</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="协程方式"><a href="#协程方式" class="headerlink" title="协程方式"></a>协程方式</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li>可迭代<ul>
<li><code>isinstance(ar, Iterable)</code></li>
<li>必须实现<code>__iter__</code>方法， <strong>返回一个迭代器</strong> ，<code>return Iterator(self)</code>，如果这个类本身是个迭代器(实现了<code>__next__</code>)则可以返回self</li>
</ul>
</li>
<li>迭代器<ul>
<li><code>isinstance(ar, Iterator)</code></li>
<li>必须实现<code>__iter__</code>方法和 <strong><code>__next__</code>方法</strong></li>
<li>使用<code>raise StopIteration</code>来表示迭代结束</li>
<li><code>iter(Iterable)</code>方法气质其实调用了类的<code>__iter__()</code>，返回类的迭代器，for in就是调用了<code>__iter__()</code>获得迭代器的</li>
<li><code>next(Iterator)</code>方法调用迭代器的<code>__next__()</code>方法</li>
<li>转换成list转化成tuple也是使用了迭代器</li>
</ul>
</li>
</ul>
<p>迭代器储存生成这个数据的方式，而不是生成这个数据的结果。占用极小的内存空间</p>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是一种特殊的迭代器</p>
<ul>
<li>列表式创建生成器：<code>nums = (x for x in range(10))</code><ul>
<li>不同于<code>nums = [x for x in range(10)]</code>直接返回结果，生成器返回生成数据的方式</li>
</ul>
</li>
<li>函数变成生成器<ul>
<li>使用<code>yield</code>返回生成器对象<ul>
<li>yield相当于返回值后把函数暂停，下次使用将从上一次的位置继续向下走</li>
<li>获取生成器return的结果，一般捕获异常，<code>except StopIteration as ret</code>，然后使用<code>ret.value</code>取得返回值</li>
</ul>
</li>
</ul>
</li>
<li>通过<code>send</code>启动生成器：<code>gen.send(args)</code><ul>
<li>同一会执行一次<code>__next__</code>，但区别于<code>next</code>，<code>send</code>能往里传参数</li>
<li><code>ret = yield x</code>，由于<code>yield x</code>返回给外面，没有返回值，所以<code>ret=None</code>。send传递的参数args使得<code>ret=args</code><ul>
<li>一般用于更新状态</li>
</ul>
</li>
<li>第一次迭代使用send会出错</li>
</ul>
</li>
</ul>
<h4 id="使用yield实现多任务"><a href="#使用yield实现多任务" class="headerlink" title="使用yield实现多任务"></a>使用yield实现多任务</h4><p>使用yield把普通函数转化成生成器，这样对于一个含有无限循环的函数，每轮yield后就会暂停，让下一行代码执行。这就实现了用函数实现并行。</p>
<p>但不同于操作系统级的并行(上下文切换开销相当大)，这样的多任务就像使用一个函数一样简单。</p>
<p>开销：$进程&gt;线程&gt;协程$</p>
<p>但这样存在一个问题，如果有100个这样的函数要写100个调用？这时需要使用<code>gevent</code></p>
<p>geven是一个基于协程的并发库</p>
<ul>
<li><code>greenlet</code>：对yield进行了封装<ul>
<li>创建greenlet对象：<code>gr1 = greenlet(func_pointer)</code>，对函数进行封装，传入普通函数就行，不需要yield返回了。</li>
<li>切换：<code>gr1.switch()</code>切换到gr1(封装的函数)<ul>
<li>如果在函数1中<code>switch</code>到函数2，函数2switch到函数1，就和yield效果一样</li>
</ul>
</li>
</ul>
</li>
<li><code>gevent</code>：对greenlet进行封装<ul>
<li>创建：<code>g1 = gevent.spawn(func, arg1, arg2, ...)</code></li>
<li>特点：遇到<code>gevent.sleep()</code>会切换，greenlet遇到延时会等待<ul>
<li>因此在结尾写上<code>g1.join()</code>(等待g1执行完成，实现了geven.sleep)，使它遇到了延时，它就自动切换执行</li>
<li><code>geven.joinall([list])</code>，把所有geven对象放入列表就会等待列表内所有</li>
</ul>
</li>
<li><code>monkey.patch_all()</code>，是否所有的延时都要手动换成<code>geven.sleep</code>？<ul>
<li>使用<code>monkey.patch_all()</code>它会自动将延时换成<code>geven.sleep</code>，包括网络延时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>报文格式</p>
<ul>
<li>请求行<ul>
<li>方法 URL 版本</li>
<li>包含一系列必要信息</li>
</ul>
</li>
<li>首部行(optional)<ul>
<li>首部字段: 值</li>
<li>相当于指定配置</li>
</ul>
</li>
<li>空行<ul>
<li>通过空行来分割头和body</li>
<li>浏览器通过<code>\r\n</code>解析换行</li>
</ul>
</li>
<li>实体主体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- 请求行 ---</span><br><span class="line">GET &#x2F;some&#x2F;dir HTTP&#x2F;1.1</span><br><span class="line">--- 首部行 ---</span><br><span class="line">Host: www.some.com           # 指明对象所在的主机, 该首部行的Web高速缓存所要求的</span><br><span class="line">Connection: close            # 非持续连接</span><br><span class="line">User-agent: Mozilla&#x2F;5.0      # 发送请求的浏览器类型</span><br><span class="line"># 还会有很多的配置，首部行是连续的，如果遇到空行则说明首部行结束，进入body</span><br></pre></td></tr></table></figure>

<p>当请求一个页面的时候，返回html，html不会有图片(css、视频或且它等)的数据但会有图片的超链接。浏览器解析到超链接会自动发送一个新的请求，因此可以从一个请求中生出很多个请求。</p>
<ul>
<li>多进程web服务器<ul>
<li>因为子进程会复制父进程的资源，所有子进程里close了父进程里还有close</li>
</ul>
</li>
<li>多线程web服务器<ul>
<li>如果是使用多线程Thread，不会复制父进程资源，子线程里close了父进程就不需要close了</li>
</ul>
</li>
<li>不论是多进程还是多线程，都要创建一个子进程/线程，如果有很多人同时请求服务(如双11)开销相当大</li>
<li>使用协程的web服务器<ul>
<li><ol>
<li>使用gevent</li>
</ol>
</li>
<li><ol start="2">
<li>非阻塞方式使用socket实现单进程单线程监听多个套接字<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s.setblocking(<span class="literal">False</span>)  <span class="comment"># 使用非阻塞方式</span></span><br><span class="line">client_socket_list = list()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       new_socket, new_addr = s.accept() </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">        print(ret)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_socket.setblocking(<span class="literal">False</span>)  <span class="comment"># 新socket使用非阻塞方式</span></span><br><span class="line">        client_socket_list.append(new_socket)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> client_socket <span class="keyword">in</span> client_socket_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            recv_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">            print(ret)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> recv_data:</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 对方关闭了</span></span><br><span class="line">                client_socket.close()</span><br><span class="line">                client_socket_list.remove(client_socket)</span><br></pre></td></tr></table></figure>
<ul>
<li>但这么做列表越大效率越低</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><ul>
<li>长连接<ul>
<li>用同一个连接获取数据</li>
<li>http1.1</li>
</ul>
</li>
<li>短连接<ul>
<li>获取一个数据建立一个连接</li>
<li>http1.0</li>
</ul>
</li>
</ul>
<p>我们之前每一轮都关闭连接，虽然说是HTTP1.1，实际我们一直用短连接的方式传输</p>
<p>短连接模式，浏览器通过接受close知道包的内容范围。但如果使用长连接，连接不close，浏览器如何知道包的范围？</p>
<p>使用长连接，需要在header中标注<code>Content-Length</code>，告诉浏览器包的长度，这样浏览器在获取全部内容后主动断开连接，服务器再断开。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>在单进程单线程服务多用户的实例中，使用列表把所有连接存储起来。但这样随着列表变大，效率将变低。因为需要拷贝fc(文件描述符)到内核的内存空间，这样轮循+拷贝的方式效率相当低。</p>
<p>epoll有个特殊的内存空间，操作系统和应用程序共用。在这个内存中的所有要监听的套接字检测时不采用轮循而是方式事件通知的方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> select  <span class="comment"># 引入模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建epoll对象</span></span><br><span class="line">epl = select.epoll()  <span class="comment"># 创建这样的共享内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将监听套接字对应的fd注册到epoll</span></span><br><span class="line">epl.register(your_socket.fileno(), <span class="comment"># fileno()返回fd</span></span><br><span class="line">            select.EPOLLIN)  <span class="comment"># EPOLLIN表示监听是否有输入</span></span><br><span class="line"></span><br><span class="line">epl.poll()  <span class="comment"># 默认阻塞，知道OS检测到数据到来，通过事件通知的方式告诉程序，才会解阻塞</span></span><br><span class="line"><span class="comment"># 返回列表，一次通知多个[(fd, event), (套接字对应的文件描述符, 对应的事件)]</span></span><br></pre></td></tr></table></figure>

<h2 id="python提高"><a href="#python提高" class="headerlink" title="python提高"></a>python提高</h2><h3 id="GIL-全局解释器锁"><a href="#GIL-全局解释器锁" class="headerlink" title="GIL(全局解释器锁)"></a>GIL(全局解释器锁)</h3><p>保证多线程程序同一时间只有一个线程在执行。多个线程先强锁。</p>
<p>c语言写的python解释器存在GIL。</p>
<p>一面试题</p>
<blockquote>
<p>描述python GIL的概念，以及它对python多线程的影响。编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否比单线程性能有提升，并解释原因</p>
</blockquote>
<p>参考答案</p>
<blockquote>
<ul>
<li><ol>
<li>python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython解释器，难以移除GIL</li>
</ol>
</li>
<li><ol start="2">
<li>GIL：全局解释器锁。每个线程在执行的过程都需要先抢GIL，保证同一时刻只有一个线程可以执行</li>
</ol>
</li>
<li><ol start="3">
<li>线程释放GIL锁的情况：在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GIL python3.x使用计时器(执行时间到达阀值后，当前线程释放GIL)或python2.x的tickels计数到100</li>
</ol>
</li>
<li><ol start="4">
<li>python使用多进程可以利用多核CPU资源</li>
</ol>
</li>
<li><ol start="5">
<li>多线程爬取性能有提升，因为遇到IO阻塞(如网络)会自动释放GIL锁</li>
</ol>
</li>
</ul>
</blockquote>
<p>IO密集型程序适合用多线程</p>
<h3 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h3><p>赋值语句在python中一般都是引用</p>
<ul>
<li>深拷贝<code>copy.deepcopy</code><ul>
<li><code>import copy</code></li>
<li><code>b = copy.deepcopy(a)</code></li>
<li><code>id(a) != id(b)</code></li>
<li>如果拷贝的是元祖，且元祖里有可变的数据，设元祖a，则deepcopy结果<code>id(a)!=id(b)</code></li>
</ul>
</li>
<li>浅拷贝<code>copy.copy</code><ul>
<li><code>import copy</code></li>
<li><code>b = copy.copy(a)</code></li>
<li><code>id(a) != id(b)</code></li>
<li>但是如果拷贝的是元祖，且元祖里只有普通数据(不可变的)，设元祖a，则copy结果<code>id(a)==id(b)</code><ul>
<li>因为元祖是不可变类型，增删改都没用所以拷贝有什么用，所有就不拷贝</li>
</ul>
</li>
</ul>
</li>
<li>切片也是浅拷贝</li>
<li>字典<code>key: value</code>，value是指向别处的引用</li>
<li>浅拷贝和深拷贝的区别  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">c = [a, b]  <span class="comment"># c中的a、b都是引用，引用指向两个列表</span></span><br><span class="line">d = copy.deepcopy(c)</span><br><span class="line">e = copy.copy(c)</span><br><span class="line"><span class="comment"># 虽然id(c)!=id(e)但是e中的[1, 2]、[3, 4]仍是a、b的引用，仅仅是把c的东西原封不动复制到e</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="私有化"><a href="#私有化" class="headerlink" title="私有化"></a>私有化</h3><p>不同于面向对象的语言，python没有public、private等关键字。</p>
<ul>
<li>xx：共有变量</li>
<li>_x：单前置下划线，私有化属性或方法，<code>from somemodule import *</code>不会导入<code>_x</code>变量，类和对象子类可以访问</li>
<li>__xx：双前置下划线，私有化属性或方法，避免与子类中的属性冲突，无法在外部直接访问(名字重整所以访问不到)</li>
<li>__xx__：双前后下划线，用户名字空间的魔法对象属性，非私有</li>
<li>xx_：单后置下划线，用于避免与python关键词的冲突</li>
</ul>
<h3 id="import问题"><a href="#import问题" class="headerlink" title="import问题"></a>import问题</h3><p>程序执行时添加新的模块路径</p>
<p><code>sys.path</code>是个储存了模块路径的列表，因此可以使用列表操作改变搜索路径的优先级以及添加新路径</p>
<h4 id="重新导入模块问题"><a href="#重新导入模块问题" class="headerlink" title="重新导入模块问题"></a>重新导入模块问题</h4><p>import会防止模块重复导入，如果在程序执行期间修改了模块，即使使用import再次导入，修改的模块不会更新。需要使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"></span><br><span class="line">reload(somemodule)  <span class="comment"># 使用这种方式在不退出程序的情况下重新导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是对于from aa import bb这样的需求没有办法</span></span><br></pre></td></tr></table></figure>


<h4 id="多模块导入问题"><a href="#多模块导入问题" class="headerlink" title="多模块导入问题"></a>多模块导入问题</h4><p>在大型项目中一般会把很长的代码拆分成很多小的模块，这时模块间的数据传递就需要注意。一般把公共数据放在一个模块，这样方便访问、修改。</p>
<p><code>import aa</code>，<code>aa.bb = a</code>和<code>from aa import bb</code>，<code>bb=a</code>的区别</p>
<ul>
<li><code>import aa</code>使aa指向模块，则<code>aa.bb = a</code>是对模块aa的bb赋值，会改变aa中bb的值</li>
<li><code>from aa import bb</code>使得变量bb <strong>指向</strong> 模块aa中的同名变量bb，如果使用<code>bb = a</code>使得bb的指向改变，不会改变aa中的bb的值</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="多继承以及MRO顺序"><a href="#多继承以及MRO顺序" class="headerlink" title="多继承以及MRO顺序"></a>多继承以及MRO顺序</h4><ul>
<li>调用父类方法的方式<ul>
<li><ol>
<li>通过父类的名字调用<ul>
<li>缺点是会根据类递归的调用，无形中造成资源浪费。如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class A:</span><br><span class="line">    __init__(self):</span><br><span class="line">        new_socket</span><br><span class="line">Class B(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        A.__init__(self)</span><br><span class="line">Class C(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        A.__init__(self)</span><br><span class="line">Class D(B, C):</span><br><span class="line">    __init__(self):</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        C.__init__(self) </span><br><span class="line"><span class="comment"># B和C的init分别调用A的init导致多创建一个socket，造成浪费</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>通过<code>super().xxx</code>调用<ul>
<li>不是更具类递归的调用，而是根据<code>ClassName.__mro__</code>中的顺序调用，保证了每个类只调用一次</li>
<li>如果多继承了多个同名方法，则根据<code>ClassName.__mro__</code>中的顺序决定super().xxx调用的是哪个(先后顺序)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class A:</span><br><span class="line">    __init__(self):</span><br><span class="line">        new_socket</span><br><span class="line">Class B(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        supter.__init__(self)</span><br><span class="line">Class C(A):</span><br><span class="line">    __init__(self):</span><br><span class="line">        super.__init__(self)</span><br><span class="line">Class D(B, C):</span><br><span class="line">    __init__(self):</span><br><span class="line">        super().__init__(self)</span><br><span class="line"><span class="comment"># 其中print(D.__mro__)=(D, B, C, A, object)</span></span><br><span class="line"><span class="comment"># 那么如果从D开始，如果父类都有调用super，则会根据mro中的顺序调用，即D、B、C、A</span></span><br></pre></td></tr></table></figure></li>
<li><code>super(ClassName, self)</code>，会从ClassName往后开始调用，如<code>super(B, self)</code>则顺序是B、C、A。默认从当前类开始</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><ul>
<li><code>func(a, *args, **kwargs)</code><ul>
<li>一个<code>*</code>号以元祖的形式传递参数，变量名是args，<code>*</code>号只是告诉编译器</li>
<li>两个<code>*</code>号以字典的形式传递参数，变量名是kwargs<ul>
<li><strong>接收关键字参数</strong> ：如<code>func(1, 2, 3, 4, age=&#39;12&#39;, name=&#39;ring&#39;)</code><ul>
<li>args=(2, 3, 4)</li>
<li>kwargs={‘age’: ‘12’, ‘name’: ‘ring’}</li>
</ul>
</li>
<li>需要注意的是如果传的是一个字典，它并不是关键字参数，而是一个字典(一个整体)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="静态方法和属性方法"><a href="#静态方法和属性方法" class="headerlink" title="静态方法和属性方法"></a>静态方法和属性方法</h4><ul>
<li>类对象和实例对象<ul>
<li>创建一个对象会从模板类中调用<code>__new__</code>分配内存空间，<code>__init__</code>初始化内存空间，<code>__class__</code>指向创建这个实例对象的类对象</li>
<li>对于公有的方法、属性存储在类对象中<ul>
<li>如方法<code>__inti__(self)</code>就不必每个实例都有一份，放在类对象中即可</li>
</ul>
</li>
<li>对于特有的方法、属性存储在类对象中<ul>
<li>如初始化name=ring，那么对于这个实例的name是ring，别的实例有所区别</li>
</ul>
</li>
</ul>
</li>
<li>类方法、实例方法、静态方法<ul>
<li>实例方法：一般的方法<ul>
<li>很难修改类属性，若<code>obj.class_state=&quot;xx&quot;</code>原来<code>class_state</code>是一个类属性。这个方法将导致实例里面新增一个名为<code>class_state</code>的属性<ul>
<li>要修改也是可以的<code>obj.__class__.class_state=&quot;xx&quot;</code>就可以修改<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">        <span class="comment"># 实例方法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span>  <span class="comment"># 默认传实例对象的引用self</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    ```  </span><br><span class="line">* 类方式：用`@classmethod`装饰</span><br><span class="line">    ``` python</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">        @classmethod  # 类方法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(cls)</span>:</span>  <span class="comment"># python解释器默认把类对象引用cls传入</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>可以修改类属性</li>
</ul>
</li>
<li>静态方法：用<code>@staticmethod</code>装饰<ul>
<li>相当于在类外定义一个函数， <strong>不让python解释权默认传入类对象或实例对象</strong> 。写在类中是为例在不同类中区分开来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="property属性"><a href="#property属性" class="headerlink" title="property属性"></a>property属性</h4><ul>
<li>用装饰器创建<ul>
<li>让代码更简洁，调用一个函数像取值、赋值一样</li>
<li>在普通方法前用<code>@property</code>修饰，如。把调用方法改成”调用属性”，但实际还是调用方法，只是可读性更高  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 必须返回一个值，且参数只有self</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.func  <span class="comment"># 可以通过a.func调用，而不用a.func()</span></span><br></pre></td></tr></table></figure></li>
<li>新式类(继承object，python3默认继承)中有3中property装饰器  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>   <span class="comment"># 获取值</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">    @property.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self, value)</span>:</span>  <span class="comment"># 要同名，且传入新值value</span></span><br><span class="line">        print(<span class="string">"some"</span>)  <span class="comment"># 设置值</span></span><br><span class="line">    <span class="comment"># 如可以调用xxx.func = 100</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"some"</span>)  <span class="comment"># 删除值</span></span><br><span class="line">    <span class="comment"># 如可以调用del xxx.func</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>通过类属性创建<ul>
<li><code>property(arg1, arg2, arg3, arg4)</code><ul>
<li>参数1是方法名，调用<code>对象.属性</code>时自动触发执行</li>
<li>(可选)参数2是方法名，调用<code>对象.属性=xx</code>时自动触发执行</li>
<li>(可选)参数3是方法名，调用<code>del 对象.属性</code>时自动触发执行</li>
<li>(可选)参数4是字符串，调用<code>对象.属性.__doc__</code>时此参数是该属性的描述信息<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    FUNC = property(func)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.FUNC</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="修改私有属性"><a href="#修改私有属性" class="headerlink" title="修改私有属性"></a>修改私有属性</h4><p>私有属性(在以<code>__</code>开头的变量)之所以无法访问是因为python悄悄改了变量名。如把<code>__func</code>改成了<code>_className__func</code>。所以使用这个改后的名就可以访问私有属性。这机制叫做名字重整。</p>
<h4 id="魔法属性-方法"><a href="#魔法属性-方法" class="headerlink" title="魔法属性/方法"></a>魔法属性/方法</h4><ul>
<li><code>__doc__</code>和<code>help()</code><ul>
<li>使用<code>var.__doc__</code>或<code>help(var)</code>可以查看写在开头的描述</li>
</ul>
</li>
<li><code>__module__</code>和<code>__class__</code><ul>
<li><code>__class__</code>表示当前操作的对象的类是什么</li>
<li><code>__module__</code>表示当前操作的对象是在哪个模块</li>
</ul>
</li>
<li><code>__init__</code><ul>
<li><strong>初始化</strong> 方法，创建类对象时自动触发执行</li>
</ul>
</li>
<li><code>__del__</code><ul>
<li>对象释放时，自动触发执行</li>
</ul>
</li>
<li><code>__call__</code><ul>
<li>对象后面加括号，触发执行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = classA()</span><br><span class="line">obj()   <span class="comment"># obj.__call__()</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>__dict__</code><ul>
<li>类或对象的所有属性</li>
</ul>
</li>
<li><code>__str__</code><ul>
<li>如果一个类中定义了<code>__str__</code>方法，那么打印对象时，默认输出改方法的返回值</li>
</ul>
</li>
<li><code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem</code><ul>
<li>如果类中实现了这3个方法，则可以当字典用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(key)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(key)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(key)</span><br><span class="line"></span><br><span class="line">odj = A()</span><br><span class="line">res = obj[<span class="string">'k1'</span>]   <span class="comment"># __getitem__</span></span><br><span class="line">obj[<span class="string">'k2'</span>] = <span class="string">'abc'</span> <span class="comment"># __setitem__</span></span><br><span class="line"><span class="keyword">del</span> obj[<span class="string">'k3'</span>]     <span class="comment"># __delitem__</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>__getslice__</code>、<code>__setslice__</code>、<code>__delslice__</code><ul>
<li>如果类中实现了这3个方法，则可以用于分片操作，如列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setslice__</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delslice__</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">odj = A()</span><br><span class="line">obj[<span class="number">-1</span>:<span class="number">1</span>]            <span class="comment"># __getslice__</span></span><br><span class="line">obj[<span class="number">0</span>:<span class="number">1</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># __setslice__</span></span><br><span class="line"><span class="keyword">del</span> obj[<span class="number">0</span>:<span class="number">2</span>]         <span class="comment"># __delslice__</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h4 id="with与上下文管理器"><a href="#with与上下文管理器" class="headerlink" title="with与上下文管理器"></a>with与上下文管理器</h4><p>使用with打开文件能够保证最终文件都会关闭。如果采用传统的<code>f = open()</code>则需要try-catch辅助。with是一种更简洁的写法。</p>
<ul>
<li>上下文管理器<ul>
<li>任何实现了<code>__enter__()</code>和<code>__exit__()</code>方法的对象都可称之为上下文管理器。</li>
<li><code>__enter__()</code>返回资源对象</li>
<li><code>__exit__()</code>处理一些清理工作</li>
</ul>
</li>
</ul>
<p>当一个对象实现了上下文管理器，就可以使用with语句了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> obj(args) <span class="keyword">as</span> f:  </span><br><span class="line">    <span class="comment"># obj()创建实例对象</span></span><br><span class="line">    <span class="comment"># with自动调用了obj(上下文管理器)的__enter__方法，enter的返回值赋给f</span></span><br><span class="line">    <span class="comment"># 如果产生了异常，将自动调用__exit__方法</span></span><br></pre></td></tr></table></figure>


<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>多层函数嵌套、往往内部函数用到外部函数的变量，一个特殊的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(a*x + b)</span><br><span class="line">    <span class="keyword">return</span> solve</span><br><span class="line"></span><br><span class="line">ans = func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 创造单独空间，包含参数a, b和solve函数。a, b相当于solve的全局变量</span></span><br><span class="line"><span class="comment"># 类似类，但比类开销小</span></span><br><span class="line">ans(<span class="number">0</span>)</span><br><span class="line">ans(<span class="number">1</span>)</span><br><span class="line">ans(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x  <span class="comment"># 告诉解释器x不是solve中的，否则由于x=10的存在。会导致解释器认为x这个局部变量在声明前使用</span></span><br><span class="line">        print(x)</span><br><span class="line">        x = <span class="number">10</span>  </span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">return</span> solve</span><br></pre></td></tr></table></figure>


<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>有时候我们需要进行一下重复的过程, 比如计算函数用时. 如果我们直接把逻辑写在函数内部, 逻辑混乱且可读性不高。这时我们就可以使用装饰器</p>
<h4 id="装饰器的基本实现过程"><a href="#装饰器的基本实现过程" class="headerlink" title="装饰器的基本实现过程"></a>装饰器的基本实现过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@set_func  # 等价于test=set_func(test)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<h4 id="有参数的装饰器实现过程"><a href="#有参数的装饰器实现过程" class="headerlink" title="有参数的装饰器实现过程"></a>有参数的装饰器实现过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(a)</span>:</span>  <span class="comment"># 参数100会传到这</span></span><br><span class="line">        func(a)</span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h4 id="不定参数的装饰器实现过程"><a href="#不定参数的装饰器实现过程" class="headerlink" title="不定参数的装饰器实现过程"></a>不定参数的装饰器实现过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 参数会传到这，这里的星号是告诉解释器</span></span><br><span class="line"></span><br><span class="line">        func(*args, **kwargs)  <span class="comment"># 这里的星号是拆包!!!，否则就是一个列表、一个字典</span></span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(age, num, *args, &amp;&amp;kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h4 id="带有返回值的装饰器实现"><a href="#带有返回值的装饰器实现" class="headerlink" title="带有返回值的装饰器实现"></a>带有返回值的装饰器实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)  <span class="comment"># 比包里调用，返回出去</span></span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(age, num, *args, &amp;&amp;kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">test = set_func(test)</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h4 id="给装饰器的参数"><a href="#给装饰器的参数" class="headerlink" title="给装饰器的参数"></a>给装饰器的参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">option</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> call_func</span><br><span class="line">    <span class="keyword">return</span> set_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@option(args)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(age, num, *args, &amp;&amp;kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>装饰器需要一个函数指针，即@后跟函数名，由于option(args)不符合，所以先向下执行option(args)，返回的函数指针。@心满意足，用来装饰test函数</p>
<h4 id="多个装饰器对同一个函数进行装饰"><a href="#多个装饰器对同一个函数进行装饰" class="headerlink" title="多个装饰器对同一个函数进行装饰"></a>多个装饰器对同一个函数进行装饰</h4><p>先装下面的后装上面的。理解上面的实现过程。</p>
<p>执行效果是先执行上面的再执行下面的。所以装饰的顺序和想要的逻辑执行顺序相同即可。</p>
<h4 id="使用类当作装饰器"><a href="#使用类当作装饰器" class="headerlink" title="使用类当作装饰器"></a>使用类当作装饰器</h4><p>原理同闭包。只是变量名指向的不是函数，而是实例对象。</p>
<p>然后使用<code>变量名()</code>调用的是<code>实例对象.__call__()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.func()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>


<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>p116~p150</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python-network/" rel="tag"># python, network</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/23/universe/python/python_hack/" rel="next" title="python hack">
                <i class="fa fa-chevron-left"></i> python hack
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/13/universe/linux/linux_kernel/" rel="prev" title="深入理解linux内核">
                深入理解linux内核 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>
    <a href="https://github.com/66RING/66RING.github.io/edit/myblog/source/_posts/universe/python/python_network.md" target="_blank">编辑</a>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket基本使用"><span class="nav-number">1.</span> <span class="nav-text">Socket基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket中使用tcp"><span class="nav-number">1.1.</span> <span class="nav-text">Socket中使用tcp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp服务器"><span class="nav-number">1.2.</span> <span class="nav-text">tcp服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP三次握手和四次挥手"><span class="nav-number">1.2.1.</span> <span class="nav-text">TCP三次握手和四次挥手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个简单下载器的实现"><span class="nav-number">1.3.</span> <span class="nav-text">一个简单下载器的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP注意点"><span class="nav-number">1.4.</span> <span class="nav-text">TCP注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多任务"><span class="nav-number">2.</span> <span class="nav-text">多任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread的基本使用"><span class="nav-number">2.1.</span> <span class="nav-text">Thread的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程方式"><span class="nav-number">2.2.</span> <span class="nav-text">进程方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程池"><span class="nav-number">2.2.1.</span> <span class="nav-text">进程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程方式"><span class="nav-number">2.3.</span> <span class="nav-text">协程方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器"><span class="nav-number">2.3.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器"><span class="nav-number">2.3.2.</span> <span class="nav-text">生成器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用yield实现多任务"><span class="nav-number">2.3.3.</span> <span class="nav-text">使用yield实现多任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">3.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#长连接"><span class="nav-number">3.1.</span> <span class="nav-text">长连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">3.2.</span> <span class="nav-text">epoll</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python提高"><span class="nav-number">4.</span> <span class="nav-text">python提高</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GIL-全局解释器锁"><span class="nav-number">4.1.</span> <span class="nav-text">GIL(全局解释器锁)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝、浅拷贝"><span class="nav-number">4.2.</span> <span class="nav-text">深拷贝、浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有化"><span class="nav-number">4.3.</span> <span class="nav-text">私有化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import问题"><span class="nav-number">4.4.</span> <span class="nav-text">import问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重新导入模块问题"><span class="nav-number">4.4.1.</span> <span class="nav-text">重新导入模块问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多模块导入问题"><span class="nav-number">4.4.2.</span> <span class="nav-text">多模块导入问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象"><span class="nav-number">4.5.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多继承以及MRO顺序"><span class="nav-number">4.5.1.</span> <span class="nav-text">多继承以及MRO顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可变参数"><span class="nav-number">4.5.2.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法和属性方法"><span class="nav-number">4.5.3.</span> <span class="nav-text">静态方法和属性方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#property属性"><span class="nav-number">4.5.4.</span> <span class="nav-text">property属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修改私有属性"><span class="nav-number">4.5.5.</span> <span class="nav-text">修改私有属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#魔法属性-方法"><span class="nav-number">4.5.6.</span> <span class="nav-text">魔法属性&#x2F;方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#with与上下文管理器"><span class="nav-number">4.5.7.</span> <span class="nav-text">with与上下文管理器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">4.6.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修改数据"><span class="nav-number">4.6.1.</span> <span class="nav-text">修改数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰器"><span class="nav-number">4.7.</span> <span class="nav-text">装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰器的基本实现过程"><span class="nav-number">4.7.1.</span> <span class="nav-text">装饰器的基本实现过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有参数的装饰器实现过程"><span class="nav-number">4.7.2.</span> <span class="nav-text">有参数的装饰器实现过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不定参数的装饰器实现过程"><span class="nav-number">4.7.3.</span> <span class="nav-text">不定参数的装饰器实现过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带有返回值的装饰器实现"><span class="nav-number">4.7.4.</span> <span class="nav-text">带有返回值的装饰器实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#给装饰器的参数"><span class="nav-number">4.7.5.</span> <span class="nav-text">给装饰器的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个装饰器对同一个函数进行装饰"><span class="nav-number">4.7.6.</span> <span class="nav-text">多个装饰器对同一个函数进行装饰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用类当作装饰器"><span class="nav-number">4.7.7.</span> <span class="nav-text">使用类当作装饰器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库"><span class="nav-number">5.</span> <span class="nav-text">数据库</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
