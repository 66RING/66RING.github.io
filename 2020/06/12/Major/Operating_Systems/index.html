<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概述shell对外暴露的接口，操作系统对外提供服务 特征  并发 同时存在多个运行的程序   共享 操作系统控制如何”同时”访问 文件互斥   虚拟 让每个用户&#x2F;程序都觉得有一个计算机专门为它提供服务   异步 程序执行不是一贯到底的，向前推进的速度有系统调度 但是只要环境相同，每次运行的结果一定相同   相互联系也相互区别   Microkernel:微内核架构设计 只放基本的功能 文件管理、网">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2020/06/12/Major/Operating_Systems/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概述shell对外暴露的接口，操作系统对外提供服务 特征  并发 同时存在多个运行的程序   共享 操作系统控制如何”同时”访问 文件互斥   虚拟 让每个用户&#x2F;程序都觉得有一个计算机专门为它提供服务   异步 程序执行不是一贯到底的，向前推进的速度有系统调度 但是只要环境相同，每次运行的结果一定相同   相互联系也相互区别   Microkernel:微内核架构设计 只放基本的功能 文件管理、网">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-06-11T16:00:00.000Z">
<meta property="article:modified_time" content="2020-07-03T10:04:13.632Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="计算机,操作系统">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/06/12/Major/Operating_Systems/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>操作系统 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/12/Major/Operating_Systems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-12 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-12T00:00:00+08:00">2020-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-03 18:04:13" itemprop="dateModified" datetime="2020-07-03T18:04:13+08:00">2020-07-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>shell对外暴露的接口，操作系统对外提供服务</p>
<p>特征</p>
<ul>
<li>并发<ul>
<li>同时存在多个运行的程序</li>
</ul>
</li>
<li>共享<ul>
<li>操作系统控制如何”同时”访问</li>
<li>文件互斥</li>
</ul>
</li>
<li>虚拟<ul>
<li>让每个用户/程序都觉得有一个计算机专门为它提供服务</li>
</ul>
</li>
<li>异步<ul>
<li>程序执行不是一贯到底的，向前推进的速度有系统调度</li>
<li>但是只要环境相同，每次运行的结果一定相同</li>
</ul>
</li>
<li>相互联系也相互区别</li>
</ul>
<ul>
<li>Microkernel:微内核架构设计<ul>
<li>只放基本的功能</li>
<li>文件管理、网路协议栈等都是放在外围以服务的形式存在，服务和服务之间通过内核的消息传递机制</li>
<li>相互隔离，很灵活，小巧</li>
<li>代价就是性能</li>
</ul>
</li>
<li>外核设计<ul>
<li>内核分成两块，<ul>
<li>Exokernel(外核)与硬件打交道：完成硬件功能的复制。</li>
<li>建立在exokernel之上，跟具体应用打交道，再通过它访问exokernel，来访问硬件<ul>
<li>可对应用进行相应的设计，使得速度更快</li>
<li>完成应用隔离</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>虚拟机</li>
</ul>
<h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><ul>
<li>计算机启动</li>
</ul>
<p>os存放在硬盘中，需要bootload将它放入内存。bootloader又由bios负责放入内存。</p>
<ul>
<li>bios提供各种支持：检测外设，初始化检查，把bootloader放入内存，让它执行</li>
<li>bootloader：加载os，从硬盘到内存</li>
</ul>
<p>应用间接与外设打交道，之所以应用不能直接访问外设是因为应用是不可信任的，而操作系统是可信任的;另一方面操作系统外为上层提供一致的接口，使得上层应用不用关注底层细节，通用可移植，提高效率。由此设计一下三个基本概念</p>
<ul>
<li><p>三个基本概念</p>
<ul>
<li>中断<ul>
<li>产生的源头：外设产生</li>
<li>处理的时间:异步事件，不会知道什么时候产生</li>
<li>响应：持续，对应用程序是透明的</li>
</ul>
</li>
<li>异常<ul>
<li>产生的源头：应用意想不到的行为</li>
<li>处理的时间：同步，一定在某个特定的指令可以产生，可以确定时间</li>
<li>响应：杀死或重新执行</li>
</ul>
</li>
<li>系统调用<ul>
<li>产生的源头：应用请求操作系统提供服务</li>
<li>处理的时间：同步或异步(返回点有可能是异步的)</li>
<li>响应：等待和持续</li>
</ul>
</li>
</ul>
</li>
<li><p>中断和异常的处理过程</p>
<ul>
<li>中断码<ul>
<li>查表</li>
</ul>
</li>
<li>保存和恢复<ul>
<li>程序执行过程中被中断，需要保存当前处理状态，便于恢复后继续执行</li>
</ul>
</li>
</ul>
</li>
<li><p>异常处理过程</p>
<ul>
<li>保存现场</li>
<li>异常处理<ul>
<li>异常编号，相应处理</li>
</ul>
</li>
<li>恢复现场</li>
</ul>
</li>
<li><p>系统调用过程</p>
<ul>
<li>访问系统调用接口</li>
<li>用户态切到内核态，控制权交给操作系统<ul>
<li>用户态：可执行权限低</li>
<li>内核态：可执行任何指令</li>
</ul>
</li>
<li>处理完成后返回成功失败</li>
</ul>
</li>
</ul>
<h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h2><h3 id="计算机体系结构及内存分层体系"><a href="#计算机体系结构及内存分层体系" class="headerlink" title="计算机体系结构及内存分层体系"></a>计算机体系结构及内存分层体系</h3><p>…</p>
<h3 id="地址空间与地址生成"><a href="#地址空间与地址生成" class="headerlink" title="地址空间与地址生成"></a>地址空间与地址生成</h3><ul>
<li>地址空间<ul>
<li>物理地址空间<ul>
<li>硬件支持的地址空间</li>
</ul>
</li>
<li>逻辑地址空间<ul>
<li>一个运行打程序所拥有的内存范围</li>
</ul>
</li>
</ul>
</li>
<li>地址空间生成<ul>
<li>cpu会根据逻辑地址查找物理地址，对应对应关系储存在MMU的表示映射关系的区域</li>
<li>CPU执行某条指令时，ALU根据指令的内容发送请求，携带逻辑地址。CPU中的MMU查找MMU对应的物理地址</li>
<li>逻辑地址和物理地址的联系又操作系统生成</li>
</ul>
</li>
<li>检查地址的安全<ul>
<li>确保每个程序访问的地址空间</li>
</ul>
</li>
</ul>
<h3 id="连续内存分配：内存碎片与分区的动态分配"><a href="#连续内存分配：内存碎片与分区的动态分配" class="headerlink" title="连续内存分配：内存碎片与分区的动态分配"></a>连续内存分配：内存碎片与分区的动态分配</h3><ul>
<li><p>外碎片</p>
<ul>
<li>分配单元之间的未使用内存</li>
</ul>
</li>
<li><p>内碎片</p>
<ul>
<li>在分配单元中的碎片</li>
</ul>
</li>
<li><p>简单的内存管理方法</p>
<ul>
<li>当一个程序准许运行在内存中时，分配一个连续的区间</li>
<li>分配一个连续的内存区间给运行的程序以访问数据</li>
</ul>
</li>
<li><p>分配策略</p>
<ul>
<li>首次适配算法<ul>
<li>碰到的第一个能够满足需求的空闲块，分配给程序</li>
<li>需求<ul>
<li>按照地址排序的空闲地址块列表</li>
<li>重新分配需要检查，看是否有空闲块能够合并</li>
</ul>
</li>
<li>优势<ul>
<li>简单</li>
<li>易于把大的空闲块留在结尾</li>
</ul>
</li>
<li>劣势<ul>
<li>容易产生外碎片</li>
<li>不确定性</li>
</ul>
</li>
</ul>
</li>
<li>最优适配算法<ul>
<li>寻找最适合的空闲块</li>
<li>需求<ul>
<li>按照大小排序的空闲地址块列表</li>
<li>重新分配需要检查，看是否有空闲块能够合并</li>
</ul>
</li>
<li>优势<ul>
<li>避免了把大的空闲块拆散</li>
<li>最小化外部碎片的产生</li>
<li>比较简单</li>
</ul>
</li>
<li>劣势<ul>
<li>重新分配慢</li>
<li>外碎片拆得很细，使得将来的利用可能性小</li>
<li>易产生很多没用的小碎片</li>
</ul>
</li>
</ul>
</li>
<li>最差适配算法<ul>
<li>与最优相反，找差距最大的空闲块</li>
<li>需求<ul>
<li>按照大小排序的空闲地址块列表</li>
<li>重新分配需要检查，看是否有空闲块能够合并</li>
</ul>
</li>
<li>优势<ul>
<li>分配时中等尺寸时效果最小</li>
</ul>
</li>
<li>劣势<ul>
<li>易于破碎大的空间，以致于(将来需要时)大分区无法被分配</li>
<li>重新分配慢</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="连续内存分配：压缩式与交换式碎片整理"><a href="#连续内存分配：压缩式与交换式碎片整理" class="headerlink" title="连续内存分配：压缩式与交换式碎片整理"></a>连续内存分配：压缩式与交换式碎片整理</h3><ul>
<li>压缩式碎片整理<ul>
<li>重置程序以合并孔洞</li>
<li>要求所有程序是动态可重置的</li>
<li>思考：<ul>
<li>何时重置</li>
<li>开销</li>
</ul>
</li>
</ul>
</li>
<li>交换式碎片整理(swaping)<ul>
<li>运行程序需要更多的内存</li>
<li>把硬盘当作内存的备份(虚拟内存)，将等待需求较长的程序挪到硬盘腾出内存</li>
<li>抢占等待的程序&amp;回收他们的内存</li>
<li>思考<ul>
<li>那些程序交换</li>
<li>何时换入换出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-4"><a href="#Part-4" class="headerlink" title="Part 4"></a>Part 4</h2><h3 id="非连续内存分配：分段"><a href="#非连续内存分配：分段" class="headerlink" title="非连续内存分配：分段"></a>非连续内存分配：分段</h3><ul>
<li><p>连续内存分配的缺点</p>
<ul>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片和内碎片的问题</li>
</ul>
</li>
<li><p>为什么需要非连续内存分配(优点)</p>
<ul>
<li>一个程序的物理地址空间是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码和数据</li>
<li>支持动态加载和动态链接</li>
</ul>
</li>
<li><p>非连续分配的缺点</p>
<ul>
<li>管理开销：如何建立虚拟地址和物理地址之间的转换<ul>
<li>软件方案</li>
<li>硬件方案<ul>
<li>分段</li>
<li>分页</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分段</p>
<ul>
<li>段访问机制<ul>
<li>程序访问内存需要一个二维数组(段号s，段内偏移addr)</li>
</ul>
</li>
<li>分段的寻址方案<ul>
<li>虚拟内存通过某种映射联系到物理地址</li>
<li>需要一个段表，操作系统建立</li>
<li>需要直到段的大小，防止偏移地址超出范围</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="非连续内存分配：页表"><a href="#非连续内存分配：页表" class="headerlink" title="非连续内存分配：页表"></a>非连续内存分配：页表</h3><p>页表其实就是一个大数组，每个运行的程序都有一个页表，每个页表有(page num, offset)</p>
<ul>
<li><p>属于程序运行状态，会动态变化</p>
</li>
<li><p>PIBR：页表基址寄存器</p>
</li>
<li><p>页表内容</p>
<ul>
<li>Flag标志位<ul>
<li>dirty bit：是否合法</li>
<li>resident bit：物理地址中是否存在</li>
<li>clock/reference bit</li>
</ul>
</li>
<li>帧号frame num：f</li>
</ul>
</li>
<li><p>CPU通过页号和偏移寻址到对应的页表项，把帧号和偏移组合形成物理地址</p>
</li>
<li><p>分页机制的性能问题：</p>
<ul>
<li>访问一个内存单元需要两次内存地址访问<ul>
<li>一次获取表项</li>
<li>一次访问数据</li>
</ul>
</li>
<li>页表可能很大，而且为了隔离每个程序要有自己的页表</li>
<li>页表空间大，因此访问效率页会有问题</li>
</ul>
</li>
<li><p>解决办法</p>
<ul>
<li>缓存近期访问的页帧转换表项(TLB)<ul>
<li>TLB使用关联内存实现，具备快速访问性能</li>
<li>如果TLB命中，物理页号可以很快获取</li>
<li>如果TLB未命中TLB miss，对应的表项被更新到TLB中<ul>
<li>多数编程(访问)的局部性可以降低TLB miss</li>
</ul>
</li>
</ul>
</li>
<li>间接访问</li>
</ul>
</li>
</ul>
<h3 id="非连续内存分配：页表-二级、多级页表"><a href="#非连续内存分配：页表-二级、多级页表" class="headerlink" title="非连续内存分配：页表-二级、多级页表"></a>非连续内存分配：页表-二级、多级页表</h3><p>速度问题解决了，空间上如何解决？那就需要页表分级</p>
<p>以二级页表举例，把一块大的页表分成两块，把大的page num分成两块：p1、p2。<br>通过一级表[p1]找到二级表的地址，在用二级表地址做索引，二级表[p2]找到frame num就可以找到物理地址。</p>
<p>整个过程多了寻址，导致开销增大，但是通过分级，当物理地址不存在时(在一级表就可以得出)，从而二级表不必保存这部分内容。以时间换空间。</p>
<p>多级页表同理</p>
<h3 id="非连续内存分配：页表-反向页表"><a href="#非连续内存分配：页表-反向页表" class="headerlink" title="非连续内存分配：页表-反向页表"></a>非连续内存分配：页表-反向页表</h3><p>前面所讲的页表的大小都和逻辑地址空间的大小有对应关系，逻辑空间寻址的范围越大，页表越多。</p>
<ul>
<li>大地址空间的问题：<ul>
<li>有大地址空间(64bits)，向前映射页表变得繁琐</li>
<li>不是让页表与逻辑空间的大小对应，而是让页表与物理地址空间大小对应</li>
</ul>
</li>
</ul>
<p>有什么办法使得页表项和逻辑地址空间没有那么大的关系，尽量和物理地址空间大小有关？这就是反向页表的想法。</p>
<p>前面都是以逻辑页号来索引页表(一个大数组)，能否用页帧号(物理页号)来查找对应的逻辑页的页号呢？这样就能省很多空间。</p>
<p>基于哈希查找的方案</p>
<h2 id="Part-5"><a href="#Part-5" class="headerlink" title="Part 5"></a>Part 5</h2><h3 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h3><p>理想中的存储器：更大、更快、更便宜的非易失性存储器</p>
<h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><ul>
<li>目标<ul>
<li>在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区储存管理配合</li>
</ul>
</li>
<li>原理<ul>
<li>把程序按照自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按照时间先后来运行<ul>
<li>必要部分(常用功能)的代码和数据常驻内存</li>
<li>可选部分(不常用功能)在其他程序模块中实现，平时存放在外存中，在需要时才装入内存</li>
<li>不存在调用关系的模块不必同时装入到内存，从而可以 <strong>相互覆盖</strong> 即这些模块共享一个分区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><ul>
<li>目标<ul>
<li>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源</li>
</ul>
</li>
<li>方法<ul>
<li>将暂时不能运行的程序送到外存，从而获得空闲内存空间</li>
<li>操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out)，而将外存中的某个进程的地址空间读入内存中(换入swap in)。换入换出内容的大小为整个程序的地址空间</li>
</ul>
</li>
<li>存在的问题<ul>
<li>交换的时机：只当内存空间不够或有不够的危险时换出</li>
<li>交换区的大小：必须足够大以存放所有用户进程的所有内存映像的拷贝</li>
<li>程序换入时的重定位：最好采用动态地址映射的方法</li>
</ul>
</li>
</ul>
<h3 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h3><ul>
<li><p>上面方法的不足</p>
<ul>
<li>覆盖技术：需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加程序员的负担</li>
<li>交换技术：以进程作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销</li>
</ul>
</li>
<li><p>虚存技术的目标：</p>
<ul>
<li>像覆盖技术那样，但做的更好，由操作系统完成，不需要程序员的干涉</li>
<li>像交换技术那样，但做的更好，只对进程的部分内容在内存和外存之间进行交换</li>
</ul>
</li>
<li><p>原理：利用程序的局部性</p>
</li>
<li><p>基本特征：</p>
<ul>
<li>大的用户空间：与外存相结合</li>
<li>部分交换：不同于交换技术，可以部分交换</li>
<li>不连续：物理内存分配不连续，虚拟地址空间使用不连续</li>
</ul>
</li>
<li><p>虚拟技术-虚拟页式内存管理</p>
<ul>
<li>基本思路：<ul>
<li>当程序需要调入内存运行时，不是将程序的所有页都装入内存，而是只装如部分页，就可启动程序而运行</li>
<li>在运行的过程中，如果发现运行的程序或要访问的数据不再内存，则发出缺页中断请求，系统在处理这个中断时，将外存中相应的页调入内存，使得程序能够运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为了事先虚拟页式内存管理，需要在页表项中多加几位：</p>
<table>
<thead>
<tr>
<th>逻辑页号</th>
<th>访问位</th>
<th>修改位</th>
<th>保护位</th>
<th>驻留位</th>
<th>物理页帧号</th>
</tr>
</thead>
</table>
<ul>
<li>驻留位<ul>
<li>表示改页是内存还是外存，如果为1,表示在内存中，可以访问，否则导致缺页中断</li>
</ul>
</li>
<li>保护位<ul>
<li>表示允许对该页做何种类型的访问，如只读、只写等</li>
</ul>
</li>
<li>修改位<ul>
<li>表示页在内存中是否修改过，当系统回收改物理页时，根据此位来决定是否把它的内存写回到外存(跟新外存的数据)</li>
</ul>
</li>
<li>访问位<ul>
<li>表明是否访问过。用于置换算法</li>
</ul>
</li>
</ul>
<h2 id="Part-6"><a href="#Part-6" class="headerlink" title="Part 6"></a>Part 6</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><ul>
<li><p>功能</p>
<ul>
<li>当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换</li>
</ul>
</li>
<li><p>目标</p>
<ul>
<li>尽可能减少页面换入换出的次数</li>
</ul>
</li>
<li><p>最优页面置换算法</p>
<ul>
<li>思路：当缺页发生时，选择等待时间最长的那个(将来长一段时间不会发生)，作为置换页面</li>
<li>这一种情况实际无法实现的原因是操作系统无法知道每个页面等待多长时间以后消失。所以只能尽可能接近，作为参考来比较其他算法</li>
</ul>
</li>
</ul>
<h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h3><ul>
<li>思路<ul>
<li>选择在内存中驻留时间最长的页面并淘汰之。即维护一个链表，链表记录所有的逻辑页，链首表示驻留时间最长。缺页时把链首淘汰，把新页添加到链尾</li>
</ul>
</li>
<li>性能较差，并且有Belady现象<ul>
<li>Belady现象<ul>
<li>在采用FIFO算法时，有时出现分配的物理页数增加，缺页率反而提高的异常现象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h3><ul>
<li>思路<ul>
<li>缺页发生时，替换最久未被使用的页，并淘汰之</li>
<li>利用局部性原理</li>
</ul>
</li>
<li>需要记录使用时间的先后顺序，开销较大。两种可能的实现方法：<ul>
<li>维护链表</li>
<li>堆栈，最新的压到栈顶，但是要查找一遍把已经存在的剔除</li>
</ul>
</li>
</ul>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>时钟页面置换算法，LRU的近似，对FIFO的一种改进。</p>
<ul>
<li>基本思路<ul>
<li>需要用到表项当中的访问位。当一个页面被装入内存时，把该位初始化为0。如果这个页面被访问到，则把该位置置为1</li>
<li>把各个页面组织成环形链表，指针指向最老的页面</li>
<li>当缺页发生时，考虑指针指向的最老的页面，如果它的访问位为0，则淘汰。如果访问位为1，则把它置为0,然后指针往下寻找</li>
</ul>
</li>
</ul>
<h3 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h3><p>时钟页面置换算法的访问并没有区分读还是写。实际中如果执行了写操作dirty bit会置为1，如果只是读dirty bit是0。那么dirty bit有什么用呢？</p>
<p>如果进行的是写操作，那么需要同时写到内存和硬盘(数据一致)。如果是只进行读操作，由于内容并没有改变，只需释放内存，然后换入即可。这种使用两个bit的算法就是二次机会法。</p>
<p>used bit、dirty bit的转变规则如下</p>
<table>
<thead>
<tr>
<th>如果</th>
<th>则</th>
</tr>
</thead>
<tbody><tr>
<td>used | dirty</td>
<td>used | dirty</td>
</tr>
<tr>
<td>0     0</td>
<td>替换的页</td>
</tr>
<tr>
<td>0     1</td>
<td>0     0</td>
</tr>
<tr>
<td>1     0</td>
<td>0     0</td>
</tr>
<tr>
<td>1     1</td>
<td>0     1</td>
</tr>
</tbody></table>
<h3 id="最不常用算法-LFU"><a href="#最不常用算法-LFU" class="headerlink" title="最不常用算法(LFU)"></a>最不常用算法(LFU)</h3><ul>
<li>基本思路<ul>
<li>缺页发生时，淘汰访问次数最少的页面</li>
</ul>
</li>
<li>维护计数器、顺序</li>
</ul>
<h3 id="局部页面替换算法的问题、工作集模型"><a href="#局部页面替换算法的问题、工作集模型" class="headerlink" title="局部页面替换算法的问题、工作集模型"></a>局部页面替换算法的问题、工作集模型</h3><p>如果局部性原理不成立，则各种置换算法效果没有区别。如果局部性原理成立，则可以通过工作集模型来表现。</p>
<ul>
<li><strong>工作集</strong> ：一个进程当前正在使用了逻辑页面集合，可以用一个二元函数$W(t, \Delta)$来表示<ul>
<li>t是当前的执行时刻</li>
<li>$\Delta$称为工作集窗口，即一个定长的页面访问的时间窗口</li>
<li>$W(t, \Delta)=$在当前时刻t之前的$\Delta$时间窗口当中的所有页面所组成的集合(随着t的变化， 该集合页不断地变化)</li>
<li>$|W(t, \Delta)|$值工作集的大小，即页面数目(不同页面的个数)</li>
</ul>
</li>
<li><strong>常驻集</strong> ：当前时刻，进程实际驻留在内存的页面集合<ul>
<li>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配进程的物理页的数目，以及所采用的页面置换算法</li>
<li>当常驻集的大小达到某个数目之后，在给他分配更多的物理页面，缺页率页不会明显下降</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    t: 0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line">pages: a c d c b a a b b d b</span><br><span class="line"></span><br><span class="line">若Delta&#x3D;4, t&#x3D;5, 则</span><br><span class="line">工作集大小&#x3D;4(dcba)</span><br><span class="line"></span><br><span class="line">若Delta&#x3D;3, t&#x3D;8, 则</span><br><span class="line">工作集大小&#x3D;2(abb)</span><br></pre></td></tr></table></figure>


<h3 id="全局置换算法"><a href="#全局置换算法" class="headerlink" title="全局置换算法"></a>全局置换算法</h3><p>把眼光放到整个系统的所有程序，而不仅仅是专注一个程序的页面置换。程序之间物理页需求不同，操作系统可以进行动态调节。</p>
<ul>
<li>缺页率页面置换算法<ul>
<li>可变分配策略：常驻集大小可变。如每个进程刚开始的时候，先根据程序大小给它分配一定数目的物理页面，然而在程序运行中，再动态调节常驻集大小<ul>
<li>当一个缺页中断发生时，被置换的页面可以是在其他进程当中。各个并发进程竞争地使用物理页面</li>
<li>优缺点：性能较好，但增加了系统开销</li>
<li>具体实现：可以使用缺页率算法来到动态调整常驻集大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-7"><a href="#Part-7" class="headerlink" title="Part 7"></a>Part 7</h2><h3 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h3><ul>
<li>进程控制块：操作系统管理控制进程所需的信息集合<ul>
<li>操作系统用 <strong>PCB(Process Control Block)</strong> 来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志<ul>
<li>进程的创建：为该进程生成一个PCB</li>
<li>进程的终止：回收它的PCB</li>
<li>进程的组织管理：通过PCB的组织管理来实现</li>
</ul>
</li>
<li>PCB含有以下三大类信息<ul>
<li>进程的标识信息</li>
<li>处理机状态信息</li>
<li>进程控制信息</li>
</ul>
</li>
<li>PCB的组织方式<ul>
<li>链表：经常有动态插入删除的操作系统</li>
<li>索引表(数组)：不常有动态插入删除的操作系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程的生命周期原理"><a href="#进程的生命周期原理" class="headerlink" title="进程的生命周期原理"></a>进程的生命周期原理</h3><ul>
<li>进程创建<ul>
<li>引起进程创建的3个主要事件<ul>
<li>系统初始化</li>
<li>用户请求创建一个新进程</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
</li>
</ul>
</li>
<li>进程运行<ul>
<li>一个就绪的进程开始运行</li>
</ul>
</li>
<li>进程等待<ul>
<li>一个进程没有就绪，就进入等待，让其他进程先执行</li>
</ul>
</li>
<li>进程唤醒<ul>
<li>等待的进程就绪</li>
</ul>
</li>
<li>进程结束</li>
</ul>
<h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><ul>
<li>进程挂起<ul>
<li>进程没有占用内存空间，叫做进程挂起</li>
<li>阻塞挂起状态：进程在外存并等待某时间的提出</li>
<li>就绪挂起状态：进程在外存，但只要进入内存即可运行</li>
</ul>
</li>
<li>状态队列把进程管理起来<ul>
<li>一个队列只存一种状态的进程</li>
</ul>
</li>
</ul>
<h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><p>线程就是进程中的一条执行流程</p>
<ul>
<li>特性<ul>
<li>线程间可以并发执行</li>
<li>线程间共享相同的地址空间</li>
</ul>
</li>
<li>优点<ul>
<li>一个进程中可以同时存在多个线程</li>
<li>各个线程之间可以并发地执行</li>
<li>各个线程之间可以共享相同地址空间和文件等资源</li>
</ul>
</li>
<li>缺点<ul>
<li>一个线程崩溃，会导致其所属进程的所有线程崩溃</li>
<li>如：浏览器如果使用一个页面一个进程，则该页面崩溃不会影响其他页面</li>
</ul>
</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式</p>
<ul>
<li>用户线程：在用户空间实现<ul>
<li>在用户空间实现的线程机制不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理</li>
<li>操作系统只能感知到线程所属的进程</li>
<li>缺点：<ul>
<li>如果一个线程发起系统调用而阻塞，则整个进程进入等待。因为操作系统只能感知到进程，所以操作系统阻塞了进程，导致所有的线程阻塞</li>
<li>当一个线程开始运行后，除非它主动交出CPU的使用权，否则它所在的进程当中的其他线程将无法使用。因为用户进程没有打断线程的特权</li>
<li>由于时间分片分配给进程，故与其他进程比，在多个线程执行时，每个线程得到的时间片少，执行会慢。</li>
</ul>
</li>
</ul>
</li>
<li>内核线程：在内核中实现</li>
<li>轻量级进程：在内核中实现，支持用户线程<ul>
<li>内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程有一个单独的内核线程来支持</li>
</ul>
</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>各个进程共享CPU资源，不同时刻进程需要切换，让别的进程能够执行。这个切换过程称为进程的上下文切换。</p>
<h2 id="Part-8"><a href="#Part-8" class="headerlink" title="Part 8"></a>Part 8</h2><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul>
<li>FCFS：先来先服务</li>
<li>SPN(SJF) SRT：短进程优先 短剩余时间优先<ul>
<li>可抢占，导致长进程可能一直得不到执行</li>
</ul>
</li>
<li>HRRN：最高响应比优先<ul>
<li>$R=(w+s)/s$，w是等待时间，s是执行时间。不可抢占，一定程度防止了长进程得不到执行的问题</li>
</ul>
</li>
<li>Round Robin：轮循<ul>
<li>各个进程轮流占用CPU</li>
<li>会引入额外的上下文切换开销，时间片太小切换太频繁，时间片太大等待时间太久</li>
</ul>
</li>
<li>Multilevel Feedback Queue：多级反馈队列<ul>
<li>不同级别队列可以采用不同的调度方案，根据进程特点划分</li>
</ul>
</li>
<li>Fair Share Scheduling：公平共享调度</li>
</ul>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><ul>
<li>实时系统<ul>
<li>定义：正确性依赖于其时间和功能两方面的一种操作系统。即因为是实时的，如果不能在规定时间完成，则失去时效性</li>
<li>强实时系统<ul>
<li>需要在保证的时间内完成重要的任务，必须完成</li>
</ul>
</li>
<li>弱实时系统<ul>
<li>要求重要的进程优先级更高，尽量完成，非必须</li>
</ul>
</li>
<li>性能指标<ul>
<li>时间约束的及时性(deadline)</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>主要特征：时间约束的可预测性</li>
</ul>
</li>
</ul>
<h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3><p>举个例子：设优先级$T1&gt;T2&gt;T3$，T3先执行并访问一块共享资源(上锁)，但还没解锁CPU就调度去执行T1。当T1也要访问这共享资源时，要等T3使用完毕(解锁)。但这时由于T2优先级高于T3，T2想要执行了，抢占了CPU，那么T1的执行时间被T2延长了。</p>
<ul>
<li>解决办法<ul>
<li>优先级继承<ul>
<li>低优先级任务继承高优先级任务的优先级依赖于他们共享的资源，即在上面这个例子中，由于T1要等待T3访问完毕，所以T3的优先级得到动态的提升和T1一样。</li>
</ul>
</li>
<li>优先级天花板<ul>
<li>资源的优先级和所有可能锁定该资源的任务中优先级最高的那个任务的优先级相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-9"><a href="#Part-9" class="headerlink" title="Part 9"></a>Part 9</h2><h3 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h3><ul>
<li>临界区：进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时不会被执行的代码区域</li>
<li>互斥：访问临界区的进程只有一个</li>
<li>死锁：两个或以上的进程，在互相等待完成待定任务</li>
<li>饥饿：一个可执行进程持续得不到执行</li>
<li>原子操作：一次不存在中断或者失败的执行(不可在”分”的最小单位，原子)</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>并发存在的问题：同时对一个数据进行写入操作会存在问题，因为写入操作大致可分为这么几个步骤：读取数据、操作数据、写入数据。由于cpu在线程间切换，如果操作数据后切换到另一个进程，然后才写入数据，将导致问题。</p>
<p>为了解决上面的并发问题，引入互斥锁机制，使得共享的数据一次只能一个进程操作，其他需要等待正在使用的进程使用结束</p>
<ul>
<li>上锁操作执行顺序(也存在上下文切换)问题:<ul>
<li>方案一：<ul>
<li><ol>
<li>判断是否操作共享资源</li>
</ol>
</li>
<li><ol start="2">
<li>判断是否有锁</li>
</ol>
</li>
<li><ol start="3">
<li>上锁</li>
</ol>
</li>
<li>存在问题，如果A先执行1、2，然后切换到B。B也会成功执行1、2进入3的区域。这时A和B都可以执行3，并没有起到锁的保护机制：只让一个进程操作</li>
</ul>
</li>
<li>方案二：<ul>
<li><ol>
<li>上锁</li>
</ol>
</li>
<li><ol start="2">
<li>判断是否有锁</li>
</ol>
</li>
<li><ol start="3">
<li>判断是否操作共享资源</li>
</ol>
</li>
<li>存在问题，A执行了1二话不说先上锁，然后切换到B。B也二话不说先上锁，这时A和B都被对方锁住，谁都不会执行</li>
<li>这种由于进程切换导致谁都不执行的现象称为饥饿</li>
</ul>
</li>
<li>方案三：使用临界区</li>
</ul>
</li>
</ul>
<h3 id="临界区的创建"><a href="#临界区的创建" class="headerlink" title="临界区的创建"></a>临界区的创建</h3><ul>
<li>禁用硬件中断<ul>
<li>虽然在临界区中执行时不会被随意切换了，但对于外设的事件也得不到相应</li>
<li>而且对于多核CPU，要屏蔽所有CPU的相应中断能力，所在多CPU情况下无法解决互斥问题</li>
</ul>
</li>
<li>基于软件的解决方法<ul>
<li>设有两个线程T0、T1,它们的结构通常为<code>while(1){进入临界区;执行临界区代码;退出临界区}</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;  <span class="comment">// 指示该谁进入临界区</span></span><br><span class="line"><span class="keyword">bool</span> flag[];  <span class="comment">// 指示进程是否准备好进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 进入临界区的代码</span></span><br><span class="line">    flag[i] = TRUE;</span><br><span class="line">    <span class="built_in">turn</span> = j;</span><br><span class="line">    <span class="keyword">while</span>(flag[j]&amp;&amp;<span class="built_in">turn</span>==j);</span><br><span class="line">        <span class="comment">//操作</span></span><br><span class="line">    <span class="comment">// 退出临界区的代码</span></span><br><span class="line">    flag[i] = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>更高级的抽象：基于硬件的一些原子操作<ul>
<li>Test-and-Set：这是一条完成读和写的机器指令<ul>
<li><ol>
<li>从内存读值</li>
</ol>
</li>
<li><ol start="2">
<li>测试该值是否为1(返回bool)</li>
</ol>
</li>
<li><ol start="3">
<li>内存值设置为1</li>
</ol>
</li>
</ul>
</li>
<li>交换exchange<ul>
<li>交换两个内存中的值</li>
</ul>
</li>
<li>上面两条指令都是原子操作，不会被切换、中断</li>
<li>缺点：<ul>
<li>忙等消耗处理器时间</li>
<li>当进程离开临界区并且多个进程在等待的时候可能导致饥饿(抢lock抢不到)</li>
<li>死锁：如果一个低优先级的进程拥有临界区并且一个高优先级进程也要求，那么高优先级进程会获得处理器并等待临界区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-10"><a href="#Part-10" class="headerlink" title="Part 10"></a>Part 10</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>抽象数据类型<ul>
<li>一个整形(sem)，两个原子操作</li>
<li>P()：sem减1,如果sem&lt;0，等待，否则继续</li>
<li>V()：sem加1,如果sem&lt;=0(说明有有一些进程在等待)，唤醒一个等待的P</li>
</ul>
</li>
</ul>
<h4 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h4><ul>
<li>信号量是整数</li>
<li>信号量的被保护的变量<ul>
<li>初始化完成后，唯一改变一个信号量的值的方法是通过P()和V()</li>
<li>操作必须是原子</li>
</ul>
</li>
<li>P()能够阻塞，V()不会阻塞</li>
<li>我们假定信号量是”公平的”<ul>
<li>没有线程被阻塞在P()仍然堵塞V()被无限频繁调用(在同一信号量)</li>
</ul>
</li>
<li>两种类型信号量<ul>
<li>二进制信号量：可以是0或1</li>
<li>一般/计数信号量：可是任何非负数<ul>
<li>允许多个执行P操作的进程进入后续操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex-&gt;P()</span><br><span class="line">临界区</span><br><span class="line">mutex-&gt;V()</span><br></pre></td></tr></table></figure>


<h4 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h4><p>基本结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::P()&#123;</span><br><span class="line">    sem--;</span><br><span class="line">    <span class="keyword">if</span>(sem&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        把这个线程放入等待队列q;</span><br><span class="line">        block(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::V()&#123;</span><br><span class="line">    sem++;</span><br><span class="line">    <span class="keyword">if</span>(sem&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        从等待队列中取出一个线程t</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>building</p>
<ul>
<li>目的：分离互斥和条件同步的关注</li>
<li>什么是管程：<ul>
<li>一个锁：指定临界区</li>
<li>0或多个条件变量：等待/通知信号量用于管理并发访问共享数据</li>
</ul>
</li>
<li>一般方法<ul>
<li>收集在对象/模块中的相关共享数据</li>
<li>定义方法来访问共享数据</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 计算机,操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/10/universe/att_vs_Intel_assembly_language/" rel="prev" title="AT&T与Intel汇编语言的比较">
      <i class="fa fa-chevron-left"></i> AT&T与Intel汇编语言的比较
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/20/Major/cpp_level_up/" rel="next" title="Major/cpp_level_up">
      Major/cpp_level_up <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-2"><span class="nav-number">2.</span> <span class="nav-text">Part 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-3"><span class="nav-number">3.</span> <span class="nav-text">Part 3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机体系结构及内存分层体系"><span class="nav-number">3.1.</span> <span class="nav-text">计算机体系结构及内存分层体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址空间与地址生成"><span class="nav-number">3.2.</span> <span class="nav-text">地址空间与地址生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连续内存分配：内存碎片与分区的动态分配"><span class="nav-number">3.3.</span> <span class="nav-text">连续内存分配：内存碎片与分区的动态分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连续内存分配：压缩式与交换式碎片整理"><span class="nav-number">3.4.</span> <span class="nav-text">连续内存分配：压缩式与交换式碎片整理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-4"><span class="nav-number">4.</span> <span class="nav-text">Part 4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非连续内存分配：分段"><span class="nav-number">4.1.</span> <span class="nav-text">非连续内存分配：分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非连续内存分配：页表"><span class="nav-number">4.2.</span> <span class="nav-text">非连续内存分配：页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非连续内存分配：页表-二级、多级页表"><span class="nav-number">4.3.</span> <span class="nav-text">非连续内存分配：页表-二级、多级页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非连续内存分配：页表-反向页表"><span class="nav-number">4.4.</span> <span class="nav-text">非连续内存分配：页表-反向页表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-5"><span class="nav-number">5.</span> <span class="nav-text">Part 5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟内存的起因"><span class="nav-number">5.1.</span> <span class="nav-text">虚拟内存的起因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖技术"><span class="nav-number">5.2.</span> <span class="nav-text">覆盖技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换技术"><span class="nav-number">5.3.</span> <span class="nav-text">交换技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚存技术"><span class="nav-number">5.4.</span> <span class="nav-text">虚存技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-6"><span class="nav-number">6.</span> <span class="nav-text">Part 6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最优页面置换算法"><span class="nav-number">6.1.</span> <span class="nav-text">最优页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#先进先出算法-FIFO"><span class="nav-number">6.2.</span> <span class="nav-text">先进先出算法(FIFO)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最近最久未使用算法-LRU"><span class="nav-number">6.3.</span> <span class="nav-text">最近最久未使用算法(LRU)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时钟页面置换算法"><span class="nav-number">6.4.</span> <span class="nav-text">时钟页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二次机会法"><span class="nav-number">6.5.</span> <span class="nav-text">二次机会法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最不常用算法-LFU"><span class="nav-number">6.6.</span> <span class="nav-text">最不常用算法(LFU)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部页面替换算法的问题、工作集模型"><span class="nav-number">6.7.</span> <span class="nav-text">局部页面替换算法的问题、工作集模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局置换算法"><span class="nav-number">6.8.</span> <span class="nav-text">全局置换算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-7"><span class="nav-number">7.</span> <span class="nav-text">Part 7</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程控制结构"><span class="nav-number">7.1.</span> <span class="nav-text">进程控制结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的生命周期原理"><span class="nav-number">7.2.</span> <span class="nav-text">进程的生命周期原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程挂起"><span class="nav-number">7.3.</span> <span class="nav-text">进程挂起</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程管理"><span class="nav-number">7.4.</span> <span class="nav-text">线程管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的实现"><span class="nav-number">7.5.</span> <span class="nav-text">线程的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文切换"><span class="nav-number">7.6.</span> <span class="nav-text">上下文切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-8"><span class="nav-number">8.</span> <span class="nav-text">Part 8</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调度算法"><span class="nav-number">8.1.</span> <span class="nav-text">调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实时调度"><span class="nav-number">8.2.</span> <span class="nav-text">实时调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级反转"><span class="nav-number">8.3.</span> <span class="nav-text">优先级反转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-9"><span class="nav-number">9.</span> <span class="nav-text">Part 9</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一些概念："><span class="nav-number">9.1.</span> <span class="nav-text">一些概念：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步"><span class="nav-number">9.2.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#临界区的创建"><span class="nav-number">9.3.</span> <span class="nav-text">临界区的创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-10"><span class="nav-number">10.</span> <span class="nav-text">Part 10</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-number">10.1.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量的使用"><span class="nav-number">10.1.1.</span> <span class="nav-text">信号量的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量的实现"><span class="nav-number">10.1.2.</span> <span class="nav-text">信号量的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管程"><span class="nav-number">10.2.</span> <span class="nav-text">管程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
